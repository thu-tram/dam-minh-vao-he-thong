<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>If Statements - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html" class="active"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="942-câu-lệnh-if-trong-assembly"><a class="header" href="#942-câu-lệnh-if-trong-assembly">9.4.2. Câu lệnh if trong Assembly</a></h3>
<p>Hãy cùng xem hàm <code>getSmallest</code> dưới dạng assembly. Để tiện theo dõi, hàm được nhắc lại dưới đây:</p>
<pre><code class="language-c">int getSmallest(int x, int y) {
    int smallest;
    if ( x &gt; y ) {
        smallest = y;
    }
    else {
        smallest = x;
    }
    return smallest;
}
</code></pre>
<p>Mã assembly tương ứng được trích xuất từ GDB trông như sau:</p>
<pre><code>(gdb) disas getSmallest
Dump of assembler code for function getSmallest:
0x07f4 &lt;+0&gt;:    sub  sp, sp, #0x20
0x07f8 &lt;+4&gt;:    str  w0, [sp, #12]
0x07fc &lt;+8&gt;:    str  w1, [sp, #8]
0x0800 &lt;+12&gt;:   ldr  w1, [sp, #12]
0x0804 &lt;+16&gt;:   ldr  w0, [sp, #8]
0x0808 &lt;+20&gt;:   cmp  w1, w0
0x080c &lt;+24&gt;:   b.le 0x81c &lt;getSmallest+40&gt;
0x0810 &lt;+28&gt;:   ldr  w0, [sp, #8]
0x0814 &lt;+32&gt;:   str  w0, [sp, #28]
0x0818 &lt;+36&gt;:   b    0x824 &lt;getSmallest+48&gt;
0x081c &lt;+40&gt;:   ldr  w0, [sp, #12]
0x0820 &lt;+44&gt;:   str  w0, [sp, #28]
0x0824 &lt;+48&gt;:   ldr  w0, [sp, #28]
0x0828 &lt;+52&gt;:   add  sp, sp, #0x20
0x082c &lt;+56&gt;:   ret
</code></pre>
<p>Đây là một cách hiển thị khác của code assembly so với những gì ta đã thấy trước đây. Ở đây, ta thấy <strong>địa chỉ</strong> gắn với mỗi lệnh, nhưng không thấy <strong>byte</strong> code máy. Đoạn assembly này đã được chỉnh sửa nhẹ để đơn giản hơn. Theo quy ước, GCC đặt tham số thứ nhất và thứ hai của hàm vào các thanh ghi <code>x0</code> và <code>x1</code>. Vì các tham số của <code>getSmallest</code> có kiểu <code>int</code>, compiler sẽ đặt chúng vào <em>component register</em> tương ứng là <code>w0</code> và <code>w1</code>. Để dễ theo dõi, ta sẽ gọi các tham số này lần lượt là <code>x</code> và <code>y</code>.</p>
<p>Hãy lần theo một vài dòng đầu của đoạn assembly trên. Lưu ý rằng trong ví dụ này, chúng ta sẽ <strong>không</strong> vẽ stack ra minh họa. Đây là một bài tập để bạn tự thực hành kỹ năng theo dõi stack bằng cách tự vẽ.</p>
<ul>
<li>Lệnh <code>sub</code> mở rộng call stack thêm 32 byte (<code>0x20</code>).</li>
<li>Các lệnh <code>str</code> tại <code>&lt;getSmallest+4&gt;</code> và <code>&lt;getSmallest+8&gt;</code> lưu <code>x</code> và <code>y</code> vào các vị trí <code>sp + 12</code> và <code>sp + 8</code> trên stack.</li>
<li>Các lệnh <code>ldr</code> tại <code>&lt;getSmallest+12&gt;</code> và <code>&lt;getSmallest+16&gt;</code> nạp <code>x</code> và <code>y</code> vào các thanh ghi <code>w1</code> và <code>w0</code>. Lưu ý rằng nội dung ban đầu của <code>w0</code> và <code>w1</code> đã bị hoán đổi.</li>
<li>Lệnh <code>cmp</code> so sánh <code>w1</code> với <code>w0</code> (tức so sánh <code>x</code> với <code>y</code>) và thiết lập các cờ điều kiện thích hợp.</li>
<li>Lệnh <code>b.le</code> tại <code>&lt;getSmallest+24&gt;</code> cho biết nếu <code>x &lt;= y</code> thì lệnh tiếp theo sẽ thực thi ở <code>&lt;getSmallest+40&gt;</code> (<code>pc = 0x81c</code>). Ngược lại, <code>pc</code> sẽ trỏ tới lệnh kế tiếp trong tuần tự, tức <code>0x810</code>.</li>
</ul>
<p>Các lệnh tiếp theo sẽ phụ thuộc vào việc chương trình <strong>có</strong> thực hiện nhánh tại <code>&lt;getSmallest+24&gt;</code> hay không.</p>
<p><strong>Trường hợp 1:</strong> Nhánh <strong>không</strong> được thực hiện. Khi đó, <code>pc = 0x810</code> (<code>&lt;getSmallest+28&gt;</code>), và các lệnh sau sẽ chạy:</p>
<ul>
<li><code>ldr</code> tại <code>&lt;getSmallest+28&gt;</code> nạp <code>y</code> vào <code>w0</code>.</li>
<li><code>str</code> tại <code>&lt;getSmallest+32&gt;</code> lưu <code>y</code> vào <code>sp + 28</code>.</li>
<li><code>b</code> tại <code>&lt;getSmallest+36&gt;</code> đặt <code>pc = 0x824</code>.</li>
<li><code>ldr</code> tại <code>&lt;getSmallest+48&gt;</code> nạp <code>y</code> vào <code>w0</code>.</li>
<li>Hai lệnh cuối thu nhỏ stack về kích thước ban đầu và trả về từ hàm. Lúc này, <code>y</code> nằm trong thanh ghi trả về <code>w0</code>, và <code>getSmallest</code> trả về <code>y</code>.</li>
</ul>
<p><strong>Trường hợp 2:</strong> Nhánh <strong>được</strong> thực hiện tại <code>&lt;getSmallest+24&gt;</code>. Khi đó, <code>pc = 0x81c</code> (<code>&lt;getSmallest+40&gt;</code>), và các lệnh sau sẽ chạy:</p>
<ul>
<li><code>ldr</code> tại <code>&lt;getSmallest+40&gt;</code> nạp <code>x</code> vào <code>w0</code>.</li>
<li><code>str</code> tại <code>&lt;getSmallest+44&gt;</code> lưu <code>x</code> vào <code>sp + 28</code>.</li>
<li><code>ldr</code> tại <code>&lt;getSmallest+48&gt;</code> nạp <code>x</code> vào <code>w0</code>.</li>
<li>Hai lệnh cuối thu nhỏ stack về kích thước ban đầu và trả về từ hàm. Lúc này, <code>x</code> nằm trong thanh ghi trả về <code>w0</code>, và <code>getSmallest</code> trả về <code>x</code>.</li>
</ul>
<p>Ta có thể chú thích đoạn assembly trên như sau:</p>
<pre><code>0x07f4 &lt;+0&gt;:   sub  sp, sp, #0x20          // mở rộng stack thêm 32 byte
0x07f8 &lt;+4&gt;:   str  w0, [sp, #12]          // lưu x tại sp+12
0x07fc &lt;+8&gt;:   str  w1, [sp, #8]           // lưu y tại sp+8
0x0800 &lt;+12&gt;:  ldr  w1, [sp, #12]          // w1 = x
0x0804 &lt;+16&gt;:  ldr  w0, [sp, #8]           // w0 = y
0x0808 &lt;+20&gt;:  cmp  w1, w0                 // so sánh x và y
0x080c &lt;+24&gt;:  b.le 0x81c &lt;getSmallest+40&gt; // nếu (x &lt;= y) thì nhảy tới &lt;getSmallest+40&gt;
0x0810 &lt;+28&gt;:  ldr  w0, [sp, #8]           // w0 = y
0x0814 &lt;+32&gt;:  str  w0, [sp, #28]          // lưu y tại sp+28 (smallest)
0x0818 &lt;+36&gt;:  b    0x824 &lt;getSmallest+48&gt; // nhảy tới &lt;getSmallest+48&gt;
0x081c &lt;+40&gt;:  ldr  w0, [sp, #12]          // w0 = x
0x0820 &lt;+44&gt;:  str  w0, [sp, #28]          // lưu x tại sp+28 (smallest)
0x0824 &lt;+48&gt;:  ldr  w0, [sp, #28]          // w0 = smallest
0x0828 &lt;+52&gt;:  add  sp, sp, #0x20          // thu gọn stack
0x082c &lt;+56&gt;:  ret                         // trả về smallest
</code></pre>
<p>Chuyển ngược đoạn assembly này về code C thu được:</p>
<h4 id="dạng-goto-của-getsmallest"><a class="header" href="#dạng-goto-của-getsmallest"><strong>Dạng goto của <code>getSmallest()</code></strong></a></h4>
<pre><code class="language-c">int getSmallest(int x, int y) {
    int smallest = y;
    if (x &lt;= y) {
        goto assign_x;
    }
    smallest = y;
    goto done;

assign_x:
    smallest = x;

done:
    return smallest;
}
</code></pre>
<h4 id="mã-c-tương-đương"><a class="header" href="#mã-c-tương-đương"><strong>Mã C tương đương</strong></a></h4>
<pre><code class="language-c">int getSmallest(int x, int y) {
    int smallest = y;
    if (x &lt;= y) {
        smallest = x;
    }
    else {
        smallest = y;
    }
    return smallest;
}
</code></pre>
<p>Trong các ví dụ trên, biến <code>smallest</code> tương ứng với thanh ghi <code>w0</code>. Nếu <code>x</code> nhỏ hơn hoặc bằng <code>y</code>, code sẽ thực thi câu lệnh <code>smallest = x</code>, câu lệnh này gắn với nhãn <code>goto</code> là <code>assign_x</code> trong dạng goto của hàm. Ngược lại, câu lệnh <code>smallest = y</code> sẽ được thực thi. Nhãn <code>goto</code> <code>done</code> được dùng để chỉ ra rằng giá trị trong <code>smallest</code> sẽ được trả về.</p>
<p>Lưu ý rằng bản dịch C ở trên của code assembly có hơi khác so với hàm <code>getSmallest</code> gốc. Những khác biệt này không quan trọng; khi xem xét kỹ cả hai hàm, ta thấy chúng tương đương về mặt logic. Tuy nhiên, compiler trước tiên sẽ chuyển mỗi câu lệnh <code>if</code> thành một dạng <code>goto</code> tương đương, dẫn đến một phiên bản hơi khác nhưng vẫn tương đương. Các ví dụ dưới đây cho thấy dạng chuẩn của câu lệnh <code>if</code> và dạng <code>goto</code> tương đương.</p>
<h4 id="câu-lệnh-if-trong-c"><a class="header" href="#câu-lệnh-if-trong-c"><strong>Câu lệnh <code>if</code> trong C</strong></a></h4>
<pre><code class="language-c">if (condition) {
    then_statement;
}
else {
    else_statement;
}
</code></pre>
<h4 id="dạng-goto-tương-đương-của-compiler"><a class="header" href="#dạng-goto-tương-đương-của-compiler"><strong>Dạng <code>goto</code> tương đương của compiler</strong></a></h4>
<pre><code class="language-c">    if (!condition) {
        goto else;
    }
    then_statement;
    goto done;
else:
    else_statement;
done:
</code></pre>
<p><strong>Bảng 2.</strong> Dạng chuẩn của câu lệnh if và dạng goto tương đương.</p>
<p>Khi dịch code sang assembly, compiler sẽ tạo một nhánh (<em>branch</em>) khi điều kiện đúng. Điều này khác với cấu trúc của câu lệnh <code>if</code>, nơi một “jump” (nhảy) tới <code>else</code> xảy ra khi điều kiện <em>không</em> đúng. Dạng <code>goto</code> thể hiện rõ sự khác biệt logic này.</p>
<p>Xét bản dịch <code>goto</code> ban đầu của hàm <code>getSmallest</code>, ta thấy:</p>
<ul>
<li><code>x &lt;= y</code> tương ứng với <code>!(condition)</code>.</li>
<li><code>smallest = x</code> là <code>else_statement</code>.</li>
<li><code>smallest = y</code> là <code>then_statement</code>.</li>
<li>Dòng cuối của hàm là <code>return smallest</code>.</li>
</ul>
<p>Viết lại phiên bản gốc của hàm với các chú thích trên:</p>
<pre><code class="language-c">int getSmallest(int x, int y) {
    int smallest;
    if (x &gt; y) {     // !(x &lt;= y)
        smallest = y; // then_statement
    }
    else {
        smallest = x; // else_statement
    }
    return smallest;
}
</code></pre>
<p>Phiên bản này giống hệt với hàm <code>getSmallest</code> ban đầu. Hãy nhớ rằng một hàm được viết theo nhiều cách khác nhau ở mức code C vẫn có thể được dịch ra cùng một tập lệnh assembly.</p>
<h4 id="lệnh-conditional-select"><a class="header" href="#lệnh-conditional-select">Lệnh Conditional Select</a></h4>
<p>Lệnh điều kiện cuối cùng mà chúng ta tìm hiểu là <strong>conditional select</strong> (<code>csel</code>).<br />
Các lệnh <code>cmp</code>, <code>tst</code> và <code>b</code> thực hiện <strong>conditional transfer of control</strong> (chuyển điều khiển có điều kiện) trong chương trình. Nói cách khác, luồng thực thi của chương trình sẽ rẽ nhánh theo nhiều hướng. Điều này có thể gây bất lợi cho việc tối ưu hóa code, vì các lệnh nhánh thường tốn kém để thực thi do gây gián đoạn <strong>instruction pipeline</strong> (chi tiết sẽ được đề cập trong <a href="../C5-Arch/pipelining_advanced.html#_pipelining_hazards_control_hazards">mục Kiến trúc</a>).</p>
<p>Ngược lại, lệnh <code>csel</code> thực hiện <strong>conditional transfer of data</strong> (chuyển dữ liệu có điều kiện). Nói cách khác, CPU sẽ thực thi <em>cả</em> <code>then_statement</code> và <code>else_statement</code>, sau đó đặt dữ liệu vào thanh ghi thích hợp dựa trên kết quả của điều kiện.</p>
<p>Việc sử dụng <strong>biểu thức ba ngôi</strong> (<em>ternary expression</em>) trong C thường khiến compiler sinh ra lệnh <code>csel</code> thay cho các lệnh nhánh. Với câu lệnh if-then-else chuẩn, biểu thức ba ngôi có dạng:</p>
<pre><code class="language-c">result = (condition) ? then_expression : else_expression;
</code></pre>
<p>Hãy dùng dạng này để viết lại hàm <code>getSmallest</code> dưới dạng biểu thức ba ngôi. Lưu ý rằng phiên bản mới này hoạt động giống hệt hàm <code>getSmallest</code> ban đầu:</p>
<pre><code class="language-c">int getSmallest_csel(int x, int y) {
    return x &gt; y ? y : x;
}
</code></pre>
<p>Mặc dù thay đổi này có vẻ không lớn, nhưng hãy xem code assembly được tạo ra. Nhớ rằng tham số thứ nhất và thứ hai (<code>x</code> và <code>y</code>) lần lượt được lưu trong các thanh ghi <code>w0</code> và <code>w1</code>:</p>
<pre><code>(gdb) disas getSmallest_csel
Dump of assembler code for function getSmallest_csel:
0x0860 &lt;+0&gt;:  sub  sp, sp, #0x10      // mở rộng stack thêm 16 byte
0x0864 &lt;+4&gt;:  str  w0, [sp, #12]      // lưu x tại sp+12
0x0868 &lt;+8&gt;:  str  w1, [sp, #8]       // lưu y tại sp+8
0x086c &lt;+12&gt;: ldr  w0, [sp, #8]       // w0 = y
0x0870 &lt;+16&gt;: ldr  w2, [sp, #12]      // w2 = x
0x0874 &lt;+20&gt;: ldr  w1, [sp, #12]      // w1 = x
0x0878 &lt;+24&gt;: cmp  w2, w0             // so sánh x và y
0x087c &lt;+28&gt;: csel w0, w1, w0, le     // nếu (x &lt;= y) w0 = x, ngược lại w0 = y
0x0880 &lt;+32&gt;: add  sp, sp, #0x10      // khôi phục sp
0x0884 &lt;+36&gt;: ret                     // trả về (w0)
</code></pre>
<p>Mã assembly này <strong>không có lệnh nhảy</strong>. Sau khi so sánh <code>x</code> và <code>y</code>, <code>x</code> chỉ được đưa vào thanh ghi trả về <code>w0</code> nếu <code>x &lt;= y</code>.</p>
<p>Cấu trúc của lệnh <code>csel</code> là:</p>
<pre><code>csel D, R1, R2, C // nếu (C) D = R1, ngược lại D = R2
</code></pre>
<p>Trong đó:</p>
<ul>
<li><code>D</code> là thanh ghi đích.</li>
<li><code>R1</code> và <code>R2</code> là hai thanh ghi chứa các giá trị cần chọn.</li>
<li><code>C</code> là điều kiện cần đánh giá.</li>
</ul>
<p>Tương tự như lệnh nhánh, thành phần <code>C</code> trong lệnh <code>csel</code> chỉ ra điều kiện để thực hiện chọn giá trị. Các điều kiện này giống hệt như trong <a href="conditional_control_loops.html#_conditional_branch_instruction_suffixes">bảng hậu tố lệnh nhánh có điều kiện</a>.</p>
<p>Với hàm <code>getSmallest</code> gốc, <strong>bộ tối ưu hóa nội bộ</strong> của compiler (xem Chương 12) sẽ thay thế các lệnh <code>b</code> bằng một lệnh <code>csel</code> nếu bật tối ưu hóa mức 1 (<code>-O1</code>):</p>
<pre><code>// biên dịch với: gcc -O1 -o getSmallest getSmallest.c
Dump of assembler code for function getSmallest:
0x0734 &lt;+0&gt;:  cmp  w0, w1            // so sánh x và y
0x0738 &lt;+4&gt;:  csel w0, w0, w1, le    // nếu (x &lt;= y) w0 = x, ngược lại w0 = y
0x073c &lt;+8&gt;:  ret                    // trả về (w0)
</code></pre>
<p>Nói chung, compiler rất thận trọng khi tối ưu hóa lệnh nhánh thành <code>csel</code>, đặc biệt trong các trường hợp có <strong>side effect</strong> hoặc liên quan đến con trỏ. <strong>Bảng 3</strong> dưới đây cho thấy hai cách viết tương đương của một hàm <code>incrementX</code>:</p>
<h4 id="mã-c"><a class="header" href="#mã-c">Mã C</a></h4>
<pre><code class="language-c">int incrementX(int * x) {
    if (x != NULL) { // nếu x không NULL
        return (*x)++; // tăng giá trị *x
    }
    else { // nếu x là NULL
        return 1;
    }
}
</code></pre>
<h4 id="dạng-ba-ngôi-trong-c"><a class="header" href="#dạng-ba-ngôi-trong-c">Dạng ba ngôi trong C</a></h4>
<pre><code class="language-c">int incrementX2(int * x) {
    return x ? (*x)++ : 1;
}
</code></pre>
<p><strong>Bảng 3.</strong> Hai hàm cố gắng tăng giá trị của số nguyên <code>x</code>.</p>
<p>Mỗi hàm nhận một con trỏ tới số nguyên làm tham số và kiểm tra xem nó có phải <code>NULL</code> hay không. Nếu <code>x</code> không phải <code>NULL</code>, hàm sẽ tăng giá trị mà <code>x</code> trỏ tới và trả về giá trị đó. Ngược lại, hàm trả về 1.</p>
<p>Có thể bạn sẽ nghĩ rằng <code>incrementX2</code> sẽ dùng lệnh <code>csel</code> vì nó dùng biểu thức ba ngôi. Tuy nhiên, cả hai hàm đều sinh ra <strong>code assembly giống hệt nhau</strong>:</p>
<pre><code>// tham số x nằm trong thanh ghi x0
Dump of assembler code for function incrementX2:
0x0774 &lt;+0&gt;:  mov  w1, #0x1                   // w1 = 0x1
0x0778 &lt;+4&gt;:  cbz  x0, 0x788 &lt;incrementX2+20&gt; // nếu (x == 0) nhảy tới &lt;incrementX2+20&gt;
0x077c &lt;+8&gt;:  ldr  w1, [x0]                   // w1 = *x
0x0780 &lt;+12&gt;: add  w2, w1, #0x1               // w2 = w1 + 1
0x0784 &lt;+16&gt;: str  w2, [x0]                   // *x = w2
0x0788 &lt;+20&gt;: mov  w0, w1                     // w0 = *x
0x078c &lt;+24&gt;: ret                             // trả về (w0)
</code></pre>
<p>Hãy nhớ rằng lệnh <code>csel</code> <strong>thực thi cả hai nhánh</strong> của điều kiện. Nói cách khác, <code>x</code> sẽ luôn bị dereference (giải tham chiếu) dù điều kiện đúng hay sai. Nếu <code>x</code> là con trỏ null, việc dereference sẽ gây <strong>null pointer exception</strong> và dẫn đến <strong>segmentation fault</strong>. Để tránh rủi ro này, compiler chọn cách an toàn là dùng lệnh nhánh thay vì <code>csel</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C9-ARM64/preliminaries.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C9-ARM64/loops.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C9-ARM64/preliminaries.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C9-ARM64/loops.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
