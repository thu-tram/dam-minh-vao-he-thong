<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions in Assembly - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html" class="active"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="95-functions-trong-assembly"><a class="header" href="#95-functions-trong-assembly">9.5. Functions trong Assembly</a></h2>
<p>Trong phần trước, chúng ta đã lần theo quá trình thực thi của các hàm đơn giản trong assembly.<br />
Trong phần này, chúng ta sẽ thảo luận về sự tương tác giữa nhiều hàm trong assembly trong bối cảnh của một chương trình lớn hơn. Chúng ta cũng sẽ giới thiệu một số lệnh mới liên quan đến việc quản lý hàm.</p>
<p>Hãy bắt đầu bằng việc ôn lại cách <strong>call stack</strong> được quản lý.<br />
Hãy nhớ rằng <code>sp</code> là <strong>stack pointer</strong> (thanh ghi con trỏ stack) và luôn trỏ tới đỉnh của stack. Thanh ghi <code>x29</code> đại diện cho <strong>base pointer</strong> (còn gọi là <strong>frame pointer</strong> hoặc <code>FP</code>) và trỏ tới đáy của <em>stack frame</em> hiện tại.</p>
<p><strong>Stack frame</strong> (còn gọi là <strong>activation frame</strong> hoặc <strong>activation record</strong>) là phần của stack được cấp phát cho một lần gọi hàm. Hàm đang thực thi luôn nằm ở đỉnh stack, và stack frame của nó được gọi là <strong>active frame</strong>. Active frame được giới hạn bởi stack pointer (ở đỉnh stack, địa chỉ thấp hơn) và frame pointer (ở đáy frame, địa chỉ cao hơn). Activation record thường chứa các biến cục bộ của hàm.</p>
<p>Cuối cùng, <strong>return address</strong> là địa chỉ trong chương trình mà hàm gọi (ví dụ <code>main</code>) sẽ tiếp tục thực thi sau khi hàm được gọi (callee) kết thúc. Trên hệ thống A64, return address được lưu trong thanh ghi <code>x30</code> (còn gọi là <code>LR</code> — Link Register).</p>
<p>Hình 1 cho thấy các <em>stack frame</em> của <code>main</code> và một hàm mà nó gọi tên là <code>fname</code>. Chúng ta sẽ gọi hàm <code>main</code> là hàm <em>caller</em> (hàm gọi) và <code>fname</code> là hàm <em>callee</em> (hàm được gọi).</p>
<p><img src="_images/stackFrame.png" alt="an illustration of stack frames" /><br />
<strong>Hình 1.</strong> Quản lý stack frame</p>
<p>Trong Hình 1, <em>active frame</em> hiện tại thuộc về hàm callee (<code>fname</code>). Vùng của call stack nằm giữa <strong>stack pointer</strong> và <strong>frame pointer</strong> được dùng cho các biến cục bộ. Stack pointer sẽ thay đổi khi các giá trị cục bộ được <em>push</em> (đẩy) lên hoặc <em>pop</em> (lấy ra) khỏi stack. Frame pointer thường không được sử dụng trong code đã tối ưu hóa, và thường là tùy chọn. Do đó, các compiler như GCC thường tham chiếu các giá trị trên stack tương đối so với stack pointer.</p>
<p>Trong Hình 1, <em>active frame</em> được giới hạn phía dưới bởi <strong>base pointer</strong> của <code>fname</code>, tức <code>x29</code>, chứa địa chỉ stack <code>0xef30</code>. Giá trị lưu tại địa chỉ <code>0xef30</code> là giá trị frame pointer đã “lưu” (0xef50), vốn chỉ ra đáy của <em>activation frame</em> cho hàm <code>main</code>. Ngay bên dưới frame pointer là <strong>return address</strong> đã lưu (lưu trong <code>x30</code>), cho biết địa chỉ mà chương trình sẽ tiếp tục thực thi khi <code>main</code> thoát.</p>
<blockquote>
<h4 id="return-address-trỏ-tới-code-memory-không-phải-stack-memory"><a class="header" href="#return-address-trỏ-tới-code-memory-không-phải-stack-memory">Return address trỏ tới <em>code memory</em>, không phải <em>stack memory</em></a></h4>
<p>Hãy nhớ rằng vùng call stack (<em>stack memory</em>) của một chương trình khác với vùng code (<em>code memory</em>). Trong khi <code>sp</code> và <code>x29</code> trỏ tới địa chỉ trong stack memory, <code>pc</code> trỏ tới một địa chỉ trong <em>code memory</em>. Nói cách khác, return address là một địa chỉ trong <em>code memory</em>, không phải stack memory:</p>
<p><img src="_images/memparts.png" alt="The parts of a program's address space." /><br />
<strong>Hình 2.</strong> Các phần của không gian địa chỉ chương trình</p>
</blockquote>
<p><strong>Bảng 1</strong> liệt kê một số lệnh bổ sung mà compiler sử dụng để quản lý hàm cơ bản.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Translation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>bl addr &lt;fname&gt;</code></td><td style="text-align: left">Đặt <code>x30 = pc + 4</code> và đặt <code>pc = addr</code></td></tr>
<tr><td style="text-align: left"><code>blr R &lt;fname&gt;</code></td><td style="text-align: left">Đặt <code>x30 = pc + 4</code> và đặt <code>pc = R</code></td></tr>
<tr><td style="text-align: left"><code>ret</code></td><td style="text-align: left">Trả về giá trị trong <code>x0</code> và đặt <code>pc = x30</code></td></tr>
</tbody></table>
</div>
<p><strong>Bảng 1.</strong> Các lệnh quản lý hàm thông dụng</p>
<p>Các lệnh <code>bl</code> và <code>ret</code> đóng vai trò quan trọng trong quá trình một hàm gọi hàm khác. Cả hai lệnh này đều thay đổi <strong>instruction pointer</strong> (thanh ghi <code>pc</code>). Khi hàm caller thực thi lệnh <code>bl</code>, giá trị <code>pc + 4</code> được lưu vào thanh ghi <code>x30</code> để biểu diễn return address — tức địa chỉ chương trình mà caller sẽ tiếp tục thực thi khi hàm callee kết thúc. Lệnh <code>bl</code> cũng thay thế giá trị của <code>pc</code> bằng địa chỉ của hàm callee.</p>
<p>Lệnh <code>ret</code> khôi phục giá trị của <code>pc</code> từ giá trị đã lưu trong <code>x30</code>, đảm bảo chương trình tiếp tục thực thi tại địa chỉ chương trình được chỉ định trong hàm caller. Bất kỳ giá trị nào được hàm callee trả về sẽ được lưu trong thanh ghi <code>x0</code> hoặc <em>component register</em> <code>w0</code>. Lệnh <code>ret</code> thường là lệnh cuối cùng được thực thi trong bất kỳ hàm nào.</p>
<h3 id="951-function-parameters"><a class="header" href="#951-function-parameters">9.5.1. Function Parameters</a></h3>
<p>Các tham số hàm thường được nạp sẵn vào các thanh ghi trước khi gọi hàm. Tám tham số đầu tiên của một hàm được lưu trong các thanh ghi <code>x0</code>...<code>x7</code>. Nếu một hàm cần nhiều hơn bảy tham số, các tham số còn lại sẽ lần lượt được lưu vào call stack dựa trên kích thước của chúng (offset 4 byte cho dữ liệu 32-bit, offset 8 byte cho dữ liệu 64-bit).</p>
<h3 id="952-tracing-through-an-example"><a class="header" href="#952-tracing-through-an-example">9.5.2. Tracing Through an Example</a></h3>
<p>Vận dụng kiến thức về quản lý hàm, hãy lần theo ví dụ mã nguồn đã được giới thiệu ở đầu chương này:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int assign() {
    int y = 40;
    return y;
}

int adder() {
    int a;
    return a + 2;
}

int main(void) {
    int x;
    assign();
    x = adder();
    printf(&quot;x is: %d\n&quot;, x);
    return 0;
}
</code></pre>
<p>Chúng ta biên dịch code này với lệnh:</p>
<pre><code>gcc -o prog prog.c
</code></pre>
<p>và dùng <code>objdump -d</code> để xem code assembly tương ứng. Lệnh sau sẽ xuất ra một tệp khá lớn chứa nhiều thông tin không cần thiết. Hãy dùng <code>less</code> và chức năng tìm kiếm để trích xuất các hàm <code>adder</code>, <code>assign</code> và <code>main</code>:</p>
<pre><code class="language-assembly">0000000000000724 &lt;assign&gt;:
 724:   d10043ff        sub     sp, sp, #0x10
 728:   52800500        mov     w0, #0x28                       // #40
 72c:   b9000fe0        str     w0, [sp, #12]
 730:   b9400fe0        ldr     w0, [sp, #12]
 734:   910043ff        add     sp, sp, #0x10
 738:   d65f03c0        ret

000000000000073c &lt;adder&gt;:
 73c:   d10043ff        sub     sp, sp, #0x10
 740:   b9400fe0        ldr     w0, [sp, #12]
 744:   11000800        add     w0, w0, #0x2
 748:   910043ff        add     sp, sp, #0x10
 74c:   d65f03c0        ret

0000000000000750 &lt;main&gt;:
 750:   a9be7bfd        stp     x29, x30, [sp, #-32]!
 754:   910003fd        mov     x29, sp
 758:   97fffff3        bl      724 &lt;assign&gt;
 75c:   97fffff8        bl      73c &lt;adder&gt;
 760:   b9001fa0        str     w0, [x29, #28]
 764:   90000000        adrp    x0, 0 &lt;_init-0x598&gt;
 768:   91208000        add     x0, x0, #0x820
 76c:   b9401fa1        ldr     w1, [x29, #28]
 770:   97ffffa8        bl      610 &lt;printf@plt&gt;
 774:   52800000        mov     w0, #0x0                        // #0
 778:   a8c27bfd        ldp     x29, x30, [sp], #32
 77c:   d65f03c0        ret
</code></pre>
<p>Mỗi hàm bắt đầu bằng một <strong>symbolic label</strong> (nhãn ký hiệu) tương ứng với tên được khai báo trong chương trình. Ví dụ, <code>&lt;main&gt;:</code> là nhãn ký hiệu cho hàm <code>main</code>. Địa chỉ của nhãn hàm cũng là địa chỉ của lệnh đầu tiên trong hàm đó.</p>
<p>Để tiết kiệm không gian trong các hình minh họa tiếp theo, chúng ta sẽ rút gọn địa chỉ code lệnh xuống 12 bit thấp, và địa chỉ stack xuống 16 bit thấp. Ví dụ, địa chỉ stack <code>0xffffffffef50</code> sẽ được hiển thị là <code>0xef50</code>.</p>
<h3 id="953-tracing-through-main"><a class="header" href="#953-tracing-through-main">9.5.3. Tracing Through main</a></h3>
<p>Hình 3 cho thấy execution stack ngay trước khi thực thi hàm <code>main</code>.</p>
<p><img src="_images/procedures/Slide1.png" alt="slide1" /></p>
<p><strong>Hình 3.</strong> Trạng thái ban đầu của các thanh ghi CPU và call stack trước khi thực thi hàm <code>main</code></p>
<p>Hãy nhớ rằng stack phát triển về phía <em>địa chỉ thấp hơn</em>. Trong ví dụ này, cả frame pointer và stack pointer (<code>x29</code> và <code>sp</code>) đều chứa địa chỉ <code>0xef50</code>. Ban đầu, <code>pc</code> là địa chỉ của lệnh đầu tiên trong hàm <code>main</code>, tức <code>0x750</code>. Các thanh ghi <code>x30</code> và <code>w0</code> cũng được đánh dấu trong ví dụ này, và cả hai đều chứa các giá trị rác ban đầu.</p>
<p><img src="_images/procedures/Slide2.png" alt="slide2" /></p>
<p>Lệnh đầu tiên (<code>stp</code>) là một lệnh hợp thành gồm hai phần:</p>
<ul>
<li>Đầu tiên, toán hạng thứ hai (<code>[sp, #-32]!</code>) giảm giá trị stack pointer đi 32 byte, từ đó cấp phát không gian cho stack frame hiện tại. Sau khi toán hạng này được đánh giá, stack pointer được cập nhật thành <code>0xef30</code>.</li>
<li>Tiếp theo, lệnh <code>stp</code> lưu giá trị hiện tại của <code>x29</code> và <code>x30</code> vào các vị trí <code>sp</code> và <code>sp+8</code> tương ứng. Thanh ghi <code>pc</code> (program counter) tăng lên để trỏ tới lệnh tiếp theo.</li>
</ul>
<p><img src="_images/procedures/Slide3.png" alt="slide3" /></p>
<p>Lệnh tiếp theo (<code>mov x29, sp</code>) cập nhật giá trị của <code>x29</code> thành bằng <code>sp</code>. Như vậy, frame pointer (<code>x29</code>) giờ đây trỏ tới đầu của stack frame dành cho hàm <code>main</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide4.png" alt="slide4" /></p>
<p>Lệnh <code>bl</code> đầu tiên lưu giá trị <code>pc+4</code> (tức <code>0x75c</code>) vào thanh ghi <code>x30</code>. Đây là địa chỉ trong <code>main</code> mà chương trình sẽ tiếp tục thực thi sau khi hàm <code>assign</code> trả về. Tiếp theo, thanh ghi <code>pc</code> được cập nhật thành địa chỉ <code>0x724</code>, là địa chỉ của lệnh đầu tiên trong hàm <code>assign</code>.</p>
<p><img src="_images/procedures/Slide5.png" alt="slide5" /></p>
<p>Lệnh tiếp theo được thực thi là lệnh đầu tiên trong <code>assign</code>. Lệnh <code>sub</code> giảm giá trị stack pointer đi 16 byte. Lúc này, <code>x29</code> và <code>sp</code> xác định ranh giới của active stack frame dành cho hàm <code>assign</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide6.png" alt="slide6" /></p>
<p>Lệnh <code>mov</code> lưu giá trị hằng <code>0x28</code> vào thanh ghi <code>w0</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide7.png" alt="slide7" /></p>
<p>Lệnh <code>str</code> lưu giá trị <code>0x28</code> vào vị trí cách stack pointer 12 byte, tức địa chỉ <code>0xef2c</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide8.png" alt="slide8" /></p>
<p>Lệnh <code>ldr</code> nạp giá trị <code>0x28</code> từ địa chỉ stack <code>0xef2c</code> vào thanh ghi <code>w0</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide9.png" alt="slide9" /></p>
<p>Lệnh <code>add</code> giải phóng stack frame hiện tại và đưa <code>sp</code> trở lại giá trị trước đó, tức <code>0xef30</code>.</p>
<p><img src="_images/procedures/Slide10.png" alt="slide10" /></p>
<p>Lệnh <code>ret</code> thay thế giá trị trong <code>pc</code> bằng giá trị trong <code>x30</code>, tức <code>0x75c</code>. Kết quả là chương trình quay trở lại thực thi lệnh đầu tiên trong hàm <code>main</code> ngay sau lời gọi hàm <code>assign</code>.</p>
<p><img src="_images/procedures/Slide11.png" alt="slide11" /></p>
<p>Lệnh tiếp theo được thực thi là một lời gọi hàm tới <code>adder</code> (hay <code>bl 73c &lt;adder&gt;</code>). Do đó, thanh ghi <code>x30</code> được cập nhật với giá trị <code>pc+4</code>, tức <code>0x760</code>. Thanh ghi <code>pc</code> được thay bằng địa chỉ <code>0x73c</code>, cho biết chương trình sẽ tiếp tục thực thi bên trong hàm <code>adder</code>.</p>
<p><img src="_images/procedures/Slide12.png" alt="slide12" /></p>
<p>Lệnh đầu tiên trong hàm <code>adder</code> giảm giá trị stack pointer đi 16 byte, cấp phát stack frame mới cho hàm <code>adder</code>. Lưu ý rằng ranh giới của <em>active stack frame</em> cho hàm <code>adder</code> được xác định bởi các thanh ghi <code>sp</code> và <code>x29</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide13.png" alt="slide13" /></p>
<p>Điều xảy ra tiếp theo là rất quan trọng. Lệnh <code>ldr</code> nạp một giá trị <em>cũ</em> từ stack (tại <code>sp+12</code>) vào thanh ghi <code>w0</code>. Đây là hệ quả trực tiếp của việc lập trình viên quên khởi tạo biến <code>a</code> trong hàm <code>adder</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide14.png" alt="slide14" /></p>
<p>Lệnh <code>add</code> sau đó cộng <code>0x2</code> vào giá trị trong <code>w0</code> và lưu kết quả (<code>0x2A</code>) vào thanh ghi <code>w0</code>. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide15.png" alt="slide15" /></p>
<p>Lệnh <code>add</code> tiếp theo cộng thêm 16 byte vào stack pointer, qua đó hủy bỏ <em>active frame</em> của <code>adder</code> và khôi phục <code>sp</code> về giá trị trước đó. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide16.png" alt="slide16" /></p>
<p>Cuối cùng, lệnh <code>ret</code> ghi đè <code>pc</code> bằng địa chỉ trong thanh ghi <code>x30</code>, cho biết chương trình sẽ tiếp tục thực thi trong hàm <code>main</code> tại địa chỉ <code>0x760</code> trong code segment.</p>
<p><img src="_images/procedures/Slide17.png" alt="slide20" /></p>
<p>Quay lại hàm <code>main()</code>, lệnh <code>str</code> tại địa chỉ chương trình <code>0x760</code> lưu nội dung của thanh ghi <code>w0</code> (<code>0x2A</code>) vào vị trí trên call stack cách frame pointer (<code>x29</code>) 28 byte. Do đó, <code>0x2A</code> được lưu tại địa chỉ stack <code>0xef4c</code>.</p>
<p><img src="_images/procedures/Slide19.png" alt="slide18" /></p>
<p>Hai lệnh tiếp theo cùng nhau nạp một địa chỉ của một trang bộ nhớ vào thanh ghi <code>x0</code>. Vì địa chỉ dài 8 byte, thanh ghi 64-bit <code>x0</code> được sử dụng thay vì <em>component register</em> 32-bit <code>w0</code>. Lệnh <code>adrp</code> nạp địa chỉ (<code>0x0</code>) vào <code>x0</code>, trong khi lệnh <code>add</code> tại địa chỉ <code>0x768</code> cộng thêm giá trị <code>0x820</code> vào đó. Sau khi hai lệnh này thực thi, thanh ghi <code>x0</code> chứa địa chỉ bộ nhớ <code>0x820</code>. Lưu ý rằng giá trị lưu tại địa chỉ <code>0x820</code> là chuỗi <code>&quot;x is %d\n&quot;</code>.</p>
<p><img src="_images/procedures/Slide20.png" alt="slide20" /></p>
<p>Tiếp theo, lệnh <code>ldr</code> tại địa chỉ chương trình <code>0x76c</code> nạp giá trị <code>0x2A</code> (nằm tại offset 28 byte từ frame pointer) vào thanh ghi <code>w1</code>.</p>
<p><img src="_images/procedures/Slide21.png" alt="slide21" /></p>
<p>Lệnh tiếp theo gọi hàm <code>printf</code>. Để ngắn gọn, chúng ta sẽ không lần theo hàm <code>printf</code> (thuộc thư viện <code>stdio.h</code>). Tuy nhiên, theo trang hướng dẫn (<code>man -s3 printf</code>), <code>printf</code> có định dạng như sau:</p>
<pre><code>int printf(const char * format, ...)
</code></pre>
<p>Nói cách khác, đối số thứ nhất là một <strong>con trỏ</strong> trỏ tới một chuỗi xác định định dạng (<em>format</em>), và các đối số từ thứ hai trở đi chỉ định các giá trị sẽ được sử dụng trong định dạng đó. Các lệnh tại địa chỉ từ <code>0x764</code> đến <code>0x770</code> tương ứng với dòng lệnh trong hàm <code>main</code>:</p>
<pre><code class="language-c">printf(&quot;x is %d\n&quot;, x);
</code></pre>
<p>Khi hàm <code>printf</code> được gọi:</p>
<ul>
<li><strong>Return address</strong> (<code>pc+4</code> hay <code>0x774</code>) được lưu vào thanh ghi <code>x30</code>.</li>
<li>Thanh ghi <code>pc</code> được thay bằng địa chỉ <code>0x610</code>, là điểm bắt đầu của hàm <code>printf</code>.</li>
<li>Thanh ghi <code>sp</code> được cập nhật để phản ánh stack frame mới dành cho hàm <code>printf</code>.</li>
</ul>
<p>Tại một thời điểm nào đó, <code>printf</code> sẽ truy cập các đối số của nó, đó là chuỗi <code>&quot;x is %d\n&quot;</code> và giá trị <code>0x2A</code>. Hãy nhớ rằng, với bất kỳ hàm nào có <em>n</em> đối số, <strong>gcc</strong> sẽ đặt 8 đối số đầu tiên vào các thanh ghi <code>x0</code>–<code>x7</code>, và các đối số còn lại sẽ được đặt lên stack <em>bên dưới</em> frame pointer. Trong trường hợp này, tham số thứ nhất được lưu trong thanh ghi <code>x0</code> (vì nó là địa chỉ của một chuỗi), và tham số thứ hai được lưu trong <em>component register</em> <code>w1</code>.</p>
<p>Sau khi gọi <code>printf</code>, giá trị <code>0x2A</code> sẽ được xuất ra cho người dùng ở dạng số nguyên. Do đó, giá trị <strong>42</strong> được in ra màn hình. Stack pointer trở về giá trị trước đó, và <code>pc</code> được cập nhật bằng giá trị lưu trong thanh ghi <code>x30</code>, tức <code>0x774</code>.</p>
<p><img src="_images/procedures/Slide22.png" alt="slide23" /></p>
<p>Lệnh <code>mov</code> tại địa chỉ <code>0x774</code> nạp giá trị hằng <code>#0x0</code> vào <em>component register</em> <code>w0</code>. Đây là giá trị sẽ được trả về khi <code>main</code> kết thúc thực thi. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide23.png" alt="slide24" /></p>
<p>Lệnh <code>ldp</code> tại địa chỉ chương trình <code>0x778</code> trước tiên sao chép các giá trị tại <code>sp</code> và <code>sp+8</code> vào các thanh ghi <code>x29</code> và <code>x30</code>, khôi phục chúng về giá trị ban đầu trước khi <code>main</code> bắt đầu thực thi. Phần cuối của lệnh <code>ldp</code> (được chỉ định bởi toán hạng <code>[sp], #32</code>) tăng stack pointer thêm 32 byte, khôi phục <code>sp</code> về giá trị ban đầu trước khi <code>main</code> chạy. Do đó, khi lệnh <code>ldp</code> hoàn tất, stack pointer (<code>sp</code>), frame pointer (<code>x29</code>) và thanh ghi trả về (<code>x30</code>) đều đã trở lại giá trị ban đầu. Thanh ghi <code>pc</code> tăng lên để trỏ tới lệnh cuối cùng trong hàm <code>main</code>.</p>
<p><img src="_images/procedures/Slide24.png" alt="slide25" /></p>
<p>Lệnh cuối cùng được thực thi là <code>ret</code>. Với <code>0x0</code> trong thanh ghi trả về <code>w0</code>, chương trình trả về giá trị <strong>0</strong>, biểu thị việc kết thúc thành công.</p>
<p>Nếu bạn đã đọc kỹ phần này, bạn sẽ hiểu tại sao chương trình của chúng ta in ra giá trị <strong>42</strong>. Về bản chất, chương trình đã vô tình sử dụng các giá trị cũ trên stack, khiến nó hoạt động theo cách mà chúng ta không lường trước. Ví dụ này khá vô hại; tuy nhiên, ở các phần sau, chúng ta sẽ thảo luận cách tin tặc lợi dụng lời gọi hàm để khiến chương trình hoạt động sai lệch theo những cách thực sự nguy hiểm.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C9-ARM64/loops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C9-ARM64/recursion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C9-ARM64/loops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C9-ARM64/recursion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
