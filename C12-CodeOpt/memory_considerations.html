<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory Considerations - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html" class="active"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="123-các-yếu-tố-cần-lưu-ý-về-bộ-nhớ-memory-considerations"><a class="header" href="#123-các-yếu-tố-cần-lưu-ý-về-bộ-nhớ-memory-considerations">12.3. Các yếu tố cần lưu ý về bộ nhớ (Memory Considerations)</a></h2>
<p>Lập trình viên cần đặc biệt chú ý đến việc sử dụng bộ nhớ, nhất là khi dùng các <strong>data structure</strong> (cấu trúc dữ liệu) tiêu tốn nhiều bộ nhớ như <strong>matrix</strong> (ma trận) và <strong>array</strong> (mảng).<br />
Mặc dù trình biên dịch cung cấp nhiều tính năng tối ưu hóa mạnh mẽ, nhưng không phải lúc nào nó cũng có thể thực hiện các tối ưu hóa giúp cải thiện việc sử dụng bộ nhớ của chương trình.</p>
<p>Trong phần này, chúng ta sẽ sử dụng một chương trình cài đặt phép nhân ma trận–vector (<a href="_attachments/matrixVector.c">matrixVector.c</a>) để dẫn dắt thảo luận về các kỹ thuật và công cụ cải thiện việc sử dụng bộ nhớ.</p>
<p>Hàm <code>main</code> của chương trình thực hiện hai bước:</p>
<ol>
<li>Cấp phát và khởi tạo ma trận đầu vào, vector đầu vào và ma trận đầu ra.</li>
<li>Thực hiện phép nhân ma trận–vector.</li>
</ol>
<p>Khi chạy chương trình với kích thước ma trận–vector là 10.000 × 10.000, kết quả cho thấy hàm <code>matrixVectorMultiply</code> chiếm phần lớn thời gian thực thi:</p>
<pre><code class="language-bash">$ gcc -o matrixVector matrixVector.c
$ ./matrixVector 10000 10000
Time to allocate and fill matrices: 1.2827
Time to allocate vector: 9.6e-05
Time to matrix-vector multiply: 1.98402
</code></pre>
<p>Vì vậy, phần thảo luận sẽ tập trung vào hàm <code>matrixVectorMultiply</code>.</p>
<h3 id="1231-loop-interchange"><a class="header" href="#1231-loop-interchange">12.3.1. Loop Interchange</a></h3>
<p><strong>Loop interchange</strong> (hoán đổi vòng lặp) là kỹ thuật tối ưu hóa thay đổi thứ tự của vòng lặp ngoài và vòng lặp trong trong các vòng lặp lồng nhau để tối đa hóa <strong>cache locality</strong> (tính cục bộ của cache).<br />
Việc thực hiện tự động kỹ thuật này là khó đối với trình biên dịch. Trong GCC, có cờ <code>-floop-interchange</code> nhưng hiện tại không được bật mặc định.<br />
Do đó, lập trình viên nên chú ý đến cách code truy cập các cấu trúc dữ liệu phức hợp trong bộ nhớ như mảng và ma trận.</p>
<p>Ví dụ, hãy xem xét kỹ hơn hàm <code>matrixVectorMultiply</code> trong <a href="_attachments/matrixVector.c">matrixVector.c</a>:</p>
<h4 id="phiên-bản-gốc-matrixvectorc"><a class="header" href="#phiên-bản-gốc-matrixvectorc">Phiên bản gốc (<a href="_attachments/matrixVector.c">matrixVector.c</a>)</a></h4>
<pre><code class="language-c">void matrixVectorMultiply(int **m, int *v, int **res, int row, int col) {
    int i, j;
    // cycles through every matrix column in inner-most loop (inefficient)
    for (j = 0; j &lt; col; j++) {
        for (i = 0; i &lt; row; i++) {
            res[i][j] = m[i][j] * v[j];
        }
    }
}
</code></pre>
<h4 id="phiên-bản-hoán-đổi-vòng-lặp-matrixvector2c"><a class="header" href="#phiên-bản-hoán-đổi-vòng-lặp-matrixvector2c">Phiên bản hoán đổi vòng lặp (<a href="_attachments/matrixVector2.c">matrixVector2.c</a>)</a></h4>
<pre><code class="language-c">void matrixVectorMultiply(int **m, int *v, int **res, int row, int col) {
    int i, j;
    // cycles through every row of matrix in inner-most loop
    for (i = 0; i &lt; row; i++) {
        for (j = 0; j &lt; col; j++) {
            res[i][j] = m[i][j] * v[j];
        }
    }
}
</code></pre>
<p><strong>Bảng 1.</strong> Hoán đổi vòng lặp trong hàm <code>matrixVectorMultiply()</code>.</p>
<p>Các ma trận đầu vào và đầu ra được cấp phát động (theo phương pháp thứ hai đã thảo luận trong chương C).<br />
Kết quả là các hàng trong ma trận <strong>không nằm liên tiếp nhau</strong> trong bộ nhớ, trong khi các phần tử trong mỗi hàng thì <strong>liên tiếp</strong>.<br />
Thứ tự vòng lặp hiện tại khiến chương trình duyệt qua từng <strong>cột</strong> thay vì từng <strong>hàng</strong>.</p>
<p>Hãy nhớ rằng <a href="../C11-MemHierarchy/caching.html#_direct_mapped_caches">dữ liệu được nạp vào cache theo <em>block</em></a> chứ không phải từng phần tử riêng lẻ.<br />
Do đó, khi một phần tử <em>x</em> trong mảng <code>res</code> hoặc <code>m</code> được truy cập, <strong>các phần tử liền kề với x</strong> cũng được nạp vào cache.<br />
Việc duyệt qua từng “cột” của ma trận gây ra nhiều <strong>cache miss</strong> hơn, vì cache buộc phải nạp block mới ở mỗi lần truy cập.</p>
<p><strong>Bảng 2</strong> cho thấy việc thêm optimization flag hóa <strong>không</strong> làm giảm thời gian chạy của hàm.<br />
Tuy nhiên, chỉ cần đổi thứ tự vòng lặp (như trong ví dụ code ở trên và trong <a href="_attachments/matrixVector2.c">matrixVector2.c</a>) đã giúp hàm chạy nhanh hơn gần <strong>8 lần</strong> và cho phép trình biên dịch thực hiện thêm các tối ưu hóa khác.</p>
<h4 id="thời-gian-thực-thi-giây-cho-phép-nhân-ma-trận-10000--10000"><a class="header" href="#thời-gian-thực-thi-giây-cho-phép-nhân-ma-trận-10000--10000">Thời gian thực thi (giây) cho phép nhân ma trận 10.000 × 10.000</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Phiên bản</th><th>Chương trình</th><th>Unoptimized</th><th><code>-O1</code></th><th><code>-O2</code></th><th><code>-O3</code></th></tr></thead><tbody>
<tr><td>Original</td><td><code>matrixVector</code></td><td>2.01</td><td>2.05</td><td>2.07</td><td>2.08</td></tr>
<tr><td>With Loop Interchange</td><td><code>matrixVector2</code></td><td>0.27</td><td>0.08</td><td>0.06</td><td>0.06</td></tr>
</tbody></table>
</div>
<p><strong>Bảng 2.</strong> Thời gian (giây) thực hiện phép nhân ma trận 10.000 × 10.000 phần tử.</p>
<p>Công cụ <code>cachegrind</code> của Valgrind (được thảo luận trong <a href="../C11-MemHierarchy/cachegrind.html#_cache_analysis_and_valgrind">Chương 11</a>) là một cách tuyệt vời để xác định các vấn đề về <strong>data locality</strong> (tính cục bộ dữ liệu), và cho thấy sự khác biệt trong truy cập cache giữa hai phiên bản của hàm <code>matrixVectorMultiply</code> ở ví dụ trên.</p>
<h3 id="1232-một-số-tối-ưu-hóa-khác-của-trình-biên-dịch-để-cải-thiện-locality-fission-và-fusion"><a class="header" href="#1232-một-số-tối-ưu-hóa-khác-của-trình-biên-dịch-để-cải-thiện-locality-fission-và-fusion">12.3.2. Một số tối ưu hóa khác của trình biên dịch để cải thiện locality: Fission và Fusion</a></h3>
<p>Chạy lại chương trình đã cải tiến với dữ liệu 10.000 × 10.000 phần tử cho kết quả thời gian như sau:</p>
<pre><code class="language-bash">$ gcc -o matrixVector2 matrixVector2.c
$ ./matrixVector2 10000 10000
Time to allocate and fill matrices: 1.29203
Time to allocate vector: 0.000107
Time to matrix-vector multiply: 0.271369
</code></pre>
<p>Bây giờ, việc cấp phát và điền dữ liệu cho ma trận chiếm nhiều thời gian nhất.<br />
Đo đạc chi tiết hơn cho thấy phần <strong>điền dữ liệu</strong> cho ma trận mới là nguyên nhân chính.<br />
Hãy xem kỹ đoạn code này:</p>
<pre><code class="language-c">// fill matrices
for (i = 0; i &lt; rows; i++){
    fillArrayRandom(matrix[i], cols);
    fillArrayZeros(result[i], cols);
}
</code></pre>
<p>Để điền dữ liệu cho ma trận đầu vào và đầu ra, vòng lặp <code>for</code> duyệt qua tất cả các hàng và gọi hàm <code>fillArrayRandom</code> và <code>fillArrayZeros</code> cho từng hàng.<br />
Trong một số trường hợp, sẽ có lợi nếu trình biên dịch tách vòng lặp này thành hai vòng lặp riêng biệt — kỹ thuật này gọi là <strong>loop fission</strong>.</p>
<h4 id="phiên-bản-gốc"><a class="header" href="#phiên-bản-gốc">Phiên bản gốc</a></h4>
<pre><code class="language-c">for (i = 0; i &lt; rows; i++) {
    fillArrayRandom(matrix[i], cols);
    fillArrayZeros(result[i], cols);
}
</code></pre>
<h4 id="phiên-bản-với-loop-fission"><a class="header" href="#phiên-bản-với-loop-fission">Phiên bản với loop fission</a></h4>
<pre><code class="language-c">for (i = 0; i &lt; rows; i++) {
    fillArrayRandom(matrix[i], cols);
}

for (i = 0; i &lt; rows; i++) {
    fillArrayZeros(result[i], cols);
}
</code></pre>
<p><strong>Bảng 3.</strong> Ví dụ loop fission trên vòng lặp điền dữ liệu ma trận trong <code>main</code>.</p>
<p>Quá trình kết hợp hai vòng lặp chạy trên cùng một phạm vi thành một vòng lặp duy nhất (ngược lại với loop fission) được gọi là <strong>loop fusion</strong>.<br />
Loop fission và loop fusion là những ví dụ tối ưu hóa mà trình biên dịch có thể thực hiện để cải thiện <strong>data locality</strong>.</p>
<p>Các trình biên dịch cho bộ xử lý đa nhân cũng có thể dùng loop fission hoặc fusion để cho phép vòng lặp chạy hiệu quả hơn trên nhiều nhân.<br />
Ví dụ: trình biên dịch có thể dùng loop fission để gán hai vòng lặp cho hai nhân khác nhau.<br />
Ngược lại, nó có thể dùng loop fusion để gộp các thao tác phụ thuộc vào nhau vào cùng một vòng lặp, rồi phân phối cho mỗi nhân một tập con các lần lặp (giả sử dữ liệu giữa các lần lặp là độc lập).</p>
<p>Trong trường hợp của chúng ta, áp dụng loop fission thủ công <strong>không</strong> cải thiện trực tiếp hiệu năng; thời gian điền dữ liệu mảng hầu như không thay đổi.<br />
Tuy nhiên, nó giúp lộ ra một tối ưu hóa tinh tế hơn: vòng lặp chứa <code>fillArrayZeros</code> là <strong>không cần thiết</strong>.<br />
Hàm <code>matrixVectorMultiply</code> sẽ gán giá trị cho từng phần tử trong mảng <code>result</code>, nên việc khởi tạo trước tất cả bằng 0 là dư thừa.</p>
<h4 id="phiên-bản-trước-matrixvector2c"><a class="header" href="#phiên-bản-trước-matrixvector2c">Phiên bản trước (<a href="_attachments/matrixVector2.c">matrixVector2.c</a>)</a></h4>
<pre><code class="language-c">for (i = 0; i &lt; rows; i++) {
    matrix[i] = allocateArray(cols);
    result[i] = allocateArray(cols);
}

for (i = 0; i &lt; rows; i++) {
    fillArrayRandom(matrix[i], cols);
    fillArrayZeros(result[i], cols);
}
</code></pre>
<h4 id="phiên-bản-cập-nhật-với-calloc-matrixvector3c"><a class="header" href="#phiên-bản-cập-nhật-với-calloc-matrixvector3c">Phiên bản cập nhật với <code>calloc()</code> (<a href="_attachments/matrixVector3.c">matrixVector3.c</a>)</a></h4>
<pre><code class="language-c">for (i = 0; i &lt; rows; i++) {
    matrix[i] = allocateArray(cols);
    result[i] = allocateArray(cols);
}

for (i = 0; i &lt; rows; i++) {
    fillArrayRandom(matrix[i], cols);
    // fillArrayZeros(result[i], cols); // no longer needed
}
</code></pre>
<p><strong>Bảng 4.</strong> Loại bỏ lời gọi <code>fillArrayZeros</code> không cần thiết.</p>
<h3 id="1233-phân-tích-bộ-nhớ-với-massif"><a class="header" href="#1233-phân-tích-bộ-nhớ-với-massif">12.3.3. Phân tích bộ nhớ với Massif</a></h3>
<p>Việc thay đổi ở bước trước chỉ giúp giảm nhẹ thời gian chạy.<br />
Mặc dù đã loại bỏ bước điền toàn bộ phần tử trong ma trận kết quả bằng số 0, nhưng vẫn cần một lượng thời gian đáng kể để điền ma trận đầu vào bằng các số ngẫu nhiên:</p>
<pre><code class="language-bash">$ gcc -o matrixVector3 matrixVector3.c
$ ./matrixVector3 10000 10000
Time to allocate matrices: 0.049073
Time to fill matrices: 0.946801
Time to allocate vector: 9.3e-05
Time to matrix-vector multiply: 0.359525
</code></pre>
<p>Mặc dù mỗi mảng được lưu <strong>không liên tiếp</strong> trong bộ nhớ, nhưng mỗi mảng chiếm <code>10,000 × sizeof(int)</code> byte, tức 40.000 byte.<br />
Vì có tổng cộng 20.000 mảng (10.000 cho ma trận đầu vào và 10.000 cho ma trận kết quả) được cấp phát, điều này tương ứng với <strong>800 triệu byte</strong>, hay khoảng <strong>762 MB</strong> dung lượng.<br />
Việc điền 762 MB dữ liệu bằng số ngẫu nhiên rõ ràng sẽ tốn nhiều thời gian.<br />
Với ma trận, mức sử dụng bộ nhớ tăng <strong>theo hàm bậc hai</strong> với kích thước đầu vào, và có thể ảnh hưởng lớn đến hiệu năng.</p>
<p>Công cụ <code>massif</code> của Valgrind có thể giúp bạn <strong>profile</strong> (phân tích) việc sử dụng bộ nhớ.<br />
Giống như các công cụ Valgrind khác đã đề cập trong sách này (<a href="../C3-C_debug/valgrind.html#_debugging_memory_with_valgrind">memcheck</a>, <a href="../C11-MemHierarchy/cachegrind.html#_cache_analysis_and_valgrind">cachegrind</a>, và callgrind), <code>massif</code> chạy như một lớp bao quanh file thực thi của chương trình.<br />
Cụ thể, <code>massif</code> sẽ chụp lại các <strong>snapshot</strong> (ảnh chụp) về việc sử dụng bộ nhớ của chương trình trong suốt quá trình chạy, và phân tích cách mức sử dụng bộ nhớ thay đổi.<br />
Lập trình viên có thể thấy <code>massif</code> hữu ích để theo dõi cách chương trình sử dụng <strong>heap memory</strong> (bộ nhớ heap), và xác định cơ hội cải thiện việc sử dụng bộ nhớ.</p>
<p>Hãy chạy <code>massif</code> trên file thực thi <code>matrixVector3</code>:</p>
<pre><code class="language-bash">$ valgrind --tool=massif ./matrixVector3 10000 10000
==7030== Massif, a heap profiler
==7030== Copyright (C) 2003-2015, and GNU GPL'd, by Nicholas Nethercote
==7030== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==7030== Command: ./matrixVector3 10000 10000
==7030==
Time to allocate matrices: 0.049511
Time to fill matrices: 4.31627
Time to allocate vector: 0.001015
Time to matrix-vector multiply: 0.62672
==7030==
</code></pre>
<p>Khi chạy <code>massif</code>, nó sẽ tạo ra một file <code>massif.out.xxxx</code>, trong đó <code>xxxx</code> là một ID duy nhất.<br />
Nếu bạn đang thực hành theo, hãy gõ <code>ls</code> để xem file massif tương ứng.<br />
Trong ví dụ này, file tương ứng là <code>massif.out.7030</code>.<br />
Dùng lệnh <code>ms_print</code> để xem kết quả của <code>massif</code>:</p>
<pre><code class="language-bash">$ ms_print massif.out.7030
-----------------------------------------------------------------------------
Command:            ./matrixVector3 10000 10000
Massif arguments:   (none)
ms_print arguments: massif.out.7030
-----------------------------------------------------------------------------

    MB
763.3^                                                ::::::::::::::::::::::#
     |:::::::::::::::::::::::::::::::::::::::::::::::::                     #
     |:                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
     |@                                               :                     #
   0 +--------------------------------------------------------------------&gt;Gi
     0                                                                  9.778

Number of snapshots: 80
Detailed snapshots: [3, 12, 17, 22, 49, 59, 69, 79 (peak)]
</code></pre>
<p>Ở đầu phần kết quả là <strong>biểu đồ sử dụng bộ nhớ</strong>.<br />
Trục <em>x</em> biểu diễn số lượng lệnh (<strong>instructions</strong>) đã thực thi.<br />
Trục <em>y</em> biểu diễn mức sử dụng bộ nhớ.</p>
<p>Biểu đồ trên cho thấy tổng cộng <strong>9,778 tỷ</strong> (Gi) lệnh đã được thực thi trong lần chạy <code>matrixVector3</code>.<br />
Trong quá trình thực thi, <code>massif</code> đã chụp tổng cộng <strong>80 snapshot</strong> để đo mức sử dụng <strong>heap</strong>.<br />
Mức sử dụng bộ nhớ đạt đỉnh ở snapshot cuối cùng (79).<br />
Mức sử dụng bộ nhớ cực đại của chương trình là <strong>763,3 MB</strong>, và duy trì tương đối ổn định trong suốt quá trình chạy.</p>
<p>Phần tóm tắt của tất cả các snapshot xuất hiện ngay sau biểu đồ.<br />
Ví dụ, bảng dưới đây tương ứng với các snapshot xung quanh snapshot 79:</p>
<pre><code>....
------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)   stacks(B)
------------------------------------------------------------------------------
 70      1,081,926      727,225,400      727,080,000       145,400          0
 71      1,095,494      737,467,448      737,320,000       147,448          0
 72      1,109,062      747,709,496      747,560,000       149,496          0
 73      1,122,630      757,951,544      757,800,000       151,544          0
 74      1,136,198      768,193,592      768,040,000       153,592          0
 75      1,149,766      778,435,640      778,280,000       155,640          0
 76      1,163,334      788,677,688      788,520,000       157,688          0
 77      1,176,902      798,919,736      798,760,000       159,736          0
 78  7,198,260,935      800,361,056      800,201,024       160,032          0
 79 10,499,078,349      800,361,056      800,201,024       160,032          0
99.98% (800,201,024B) (heap allocations) malloc/new/new[], --alloc-fns, etc.
-&gt;99.96% (800,040,000B) 0x40089D: allocateArray (in matrixVector3)
</code></pre>
<p>Mỗi hàng trong bảng tương ứng với một snapshot cụ thể, bao gồm:</p>
<ul>
<li><strong>Thời điểm</strong> snapshot được chụp (<code>time(i)</code>).</li>
<li><strong>Tổng mức tiêu thụ bộ nhớ heap</strong> tại thời điểm đó (<code>total(B)</code>).</li>
<li><strong>Số byte chương trình yêu cầu</strong> tại thời điểm đó (<code>useful-heap</code>).</li>
<li><strong>Số byte được cấp phát vượt quá</strong> so với yêu cầu của chương trình (<code>extra-heap</code>).</li>
<li><strong>Kích thước stack</strong> (<code>stacks(B)</code>).</li>
</ul>
<p>Theo mặc định, việc <strong>profiling stack</strong> bị tắt (vì nó làm <code>massif</code> chạy chậm đáng kể).<br />
Để bật profiling stack, hãy dùng tùy chọn <code>--stacks=yes</code> khi chạy <code>massif</code>.</p>
<p>Công cụ <code>massif</code> cho thấy <strong>99,96%</strong> mức sử dụng bộ nhớ heap của chương trình xảy ra trong hàm <code>allocateArray</code>, và tổng cộng <strong>800 triệu byte</strong> đã được cấp phát — phù hợp với phép tính ước lượng nhanh mà chúng ta đã thực hiện trước đó.</p>
<p>Người đọc có thể thấy <code>massif</code> là một công cụ hữu ích để xác định các khu vực sử dụng nhiều bộ nhớ heap trong chương trình — điều thường làm chậm chương trình.<br />
Ví dụ, <strong>memory leak</strong> (rò rỉ bộ nhớ) có thể xảy ra khi lập trình viên thường xuyên gọi <code>malloc</code> nhưng không gọi <code>free</code> tại thời điểm thích hợp đầu tiên.<br />
Công cụ <code>massif</code> đặc biệt hữu ích để phát hiện các rò rỉ như vậy.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C12-CodeOpt/loops_functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C12-CodeOpt/summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C12-CodeOpt/loops_functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C12-CodeOpt/summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
