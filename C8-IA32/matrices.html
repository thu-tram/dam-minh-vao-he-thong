<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Matrices in Assembly - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html" class="active"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="88-matrices"><a class="header" href="#88-matrices">8.8. Matrices</a></h2>
<p>A matrix is a two-dimensional (2D) array. A matrix in the C language can
be statically allocated as a 2D array (<code>M[n][m]</code>), dynamically allocated
with a single call to <code>malloc</code>, or dynamically allocated as an array of
arrays. Let's consider the array of arrays implementation. The first
array contains <code>n</code> elements (<code>M[n]</code>), and each element <code>M[i]</code> in our
matrix contains an array of <code>m</code> elements. The following code snippets
each declare matrices of size 4 × 3:</p>
<pre><code>//statically allocated matrix (allocated on stack)
int M1[4][3];

//dynamically allocated matrix (programmer friendly, allocated on heap)
int **M2, i;
M2 = malloc(4 * sizeof(int*));
for (i = 0; i &lt; 4; i++) {
    M2[i] = malloc(3 * sizeof(int));
}
</code></pre>
<p>In the case of the dynamically allocated matrix, the main array contains
a contiguous array of <code>int</code> pointers. Each integer pointer points to a
different array in memory. Figure 1 illustrates how we
would normally visualize each of these matrices.</p>
<p><img src="_images/matrices.png" alt="matrices" /></p>
<p>Figure 1. Illustration of a statically allocated (M1) and a dynamically
allocated (M2) 3x4 matrix</p>
<p>For both of these matrix declarations, element (<em>i</em>,<em>j</em>) can be accessed
using the double-indexing syntax <code>M[i][j]</code>, where <code>M</code> is either <code>M1</code> or
<code>M2</code>. However, these matrices are organized differently in memory. Even
though both store the elements in their primary array contiguously in
memory, our statically allocated matrix also stores all the rows
contiguously in memory, as shown in Figure 2.</p>
<p><img src="_images/matrixArray.png" alt="matrixArray" /></p>
<p>Figure 2. Matrix M1's memory layout in row-major order</p>
<p>This contiguous ordering is not guaranteed for <code>M2</code>. <a href="../C2-C_depth/arrays.html#_two_dimensional_array_memory_layout">Recall
that</a>
to contiguously allocate an <em>n</em> × <em>m</em> matrix on the heap, we should use
a single call to <code>malloc</code> that allocates <em>n</em> × <em>m</em> elements:</p>
<pre><code>//dynamic matrix (allocated on heap, memory efficient way)
#define ROWS 4
#define COLS 3
int *M3;
M3  = malloc(ROWS * COLS * sizeof(int));
</code></pre>
<p>Recall that with the declaration of <code>M3</code>, element (<em>i</em>,<em>j</em>) <em>cannot</em> be
accessed using the <code>M[i][j]</code> notation. Instead, we must index the
element using the format <code>M3[i*cols + j]</code>.</p>
<h3 id="881-contiguous-two-dimensional-arrays"><a class="header" href="#881-contiguous-two-dimensional-arrays">8.8.1. Contiguous Two-Dimensional Arrays</a></h3>
<p>Consider a function <code>sumMat</code> that takes a pointer to a contiguously
allocated (either statically allocated or memory-efficiently dynamically
allocated) matrix as its first parameter, along with the numbers of rows
and columns, and returns the sum of all the elements inside the matrix.</p>
<p>We use scaled indexing in the code snippet that follows because it
applies to both statically and dynamically allocated contiguous
matrices. Recall that the syntax <code>m[i][j]</code> does not work with the
memory-efficient contiguous dynamic allocation previously discussed.</p>
<pre><code>int sumMat(int *m, int rows, int cols) {
    int i, j, total = 0;
    for (i = 0; i &lt; rows; i++){
        for (j = 0; j &lt; cols; j++){
            total += m[i*cols + j];
        }
    }
    return total;
}
</code></pre>
<p>Here is the corresponding assembly. Each line is annotated with its
English translation:</p>
<pre><code>&lt;sumMat&gt;:
0x08048507 &lt;+0&gt;:  push %ebp                  #save ebp
0x08048508 &lt;+1&gt;:  mov  %esp,%ebp             #update ebp (new stack frame)
0x0804850a &lt;+3&gt;:  sub  $0x10,%esp            #add 4 more spaces to stack frame
0x0804850d &lt;+6&gt;:  movl $0x0,-0xc(%ebp)       #copy 0 to ebp-12 (total)
0x08048514 &lt;+13&gt;: movl $0x0,-0x4(%ebp)       #copy 0 to ebp-4 (i)
0x0804851b &lt;+20&gt;: jmp  0x8048555 &lt;sumMat+78&gt; #goto &lt;sumMat+78&gt;
0x0804851d &lt;+22&gt;: movl $0x0,-0x8(%ebp)       #copy 0 to ebp-8 (j)
0x08048524 &lt;+29&gt;: jmp  0x8048549 &lt;sumMat+66&gt; #goto &lt;sumMat+66&gt;
0x08048526 &lt;+31&gt;: mov  -0x4(%ebp),%eax       #copy i to eax
0x08048529 &lt;+34&gt;: imul 0x10(%ebp),%eax       #multiply i * cols, place in eax
0x0804852d &lt;+38&gt;: mov  %eax,%edx             #copy i*cols to edx
0x0804852f &lt;+40&gt;: mov  -0x8(%ebp),%eax       #copy j to %eax
0x08048532 &lt;+43&gt;: add  %edx,%eax             #add i*cols with j, place in eax
0x08048534 &lt;+45&gt;: lea  0x0(,%eax,4),%edx     #mult (i*cols+j) by 4,put in edx
0x0804853b &lt;+52&gt;: mov  0x8(%ebp),%eax        #copy m pointer to eax
0x0804853e &lt;+55&gt;: add  %edx,%eax             #add m to (i*cols+j)*4,put in eax
0x08048540 &lt;+57&gt;: mov  (%eax),%eax           #copy m[i*cols+j] to eax
0x08048542 &lt;+59&gt;: add  %eax,-0xc(%ebp)       #add eax to total
0x08048545 &lt;+62&gt;: addl $0x1,-0x8(%ebp)       #increment j by 1 (j+=1)
0x08048549 &lt;+66&gt;: mov  -0x8(%ebp),%eax       #copy j to eax
0x0804854c &lt;+69&gt;: cmp  0x10(%ebp),%eax       #compare j with cols
0x0804854f &lt;+72&gt;: jl   0x8048526 &lt;sumMat+31&gt; #if (j &lt; cols) goto &lt;sumMat+31&gt;
0x08048551 &lt;+74&gt;: addl $0x1,-0x4(%ebp)       #add 1 to i (i+=1)
0x08048555 &lt;+78&gt;: mov  -0x4(%ebp),%eax       #copy i to eax
0x08048558 &lt;+81&gt;: cmp  0xc(%ebp),%eax        #compare i with rows
0x0804855b &lt;+84&gt;: jl   0x804851d &lt;sumMat+22&gt; #if (i &lt; rows) goto sumMat+22
0x0804855d &lt;+86&gt;: mov  -0xc(%ebp),%eax       #copy total to eax
0x08048560 &lt;+89&gt;: leave                      #prepare to leave the function
0x08048561 &lt;+90&gt;: ret                        #return total
</code></pre>
<p>The local variables <code>i</code>, <code>j</code>, and <code>total</code> are loaded at addresses
<code>%ebp-4</code>, <code>%ebp-8</code>, and <code>%ebp-12</code> on the stack, respectively. The input
parameters <code>m</code>, <code>row</code>, and <code>cols</code> are located at locations <code>%ebp+8</code>,
<code>%ebp+12</code>, and <code>%ebp+16</code>, respectively. Using this knowledge, let's zoom
in on the component that just deals with the access of element (<em>i</em>,<em>j</em>)
in our matrix:</p>
<pre><code>0x08048526 &lt;+31&gt;: mov  -0x4(%ebp),%eax    # copy i to eax
0x08048529 &lt;+34&gt;: imul 0x10(%ebp),%eax    # multiply i with cols, place in eax
0x0804852d &lt;+38&gt;: mov  %eax,%edx          # copy i*cols to edx
</code></pre>
<p>The first set of instructions computes <code>i * cols</code> and places the result
in register <code>%edx</code>. Recall that for a matrix named <code>matrix</code>,
<code>matrix + (i * cols)</code> is equivalent to <code>&amp;matrix[i]</code>.</p>
<hr />
<pre><code>0x0804852f &lt;+40&gt;: mov -0x8(%ebp),%eax   # copy j to eax
0x08048532 &lt;+43&gt;: add %edx,%eax         # add i*cols with j, place in eax
0x08048534 &lt;+45&gt;: lea 0x0(,%eax,4),%edx # multiply (i*cols+j) by 4, put in edx
</code></pre>
<p>The next set of instructions computes <code>(i * cols + j) * 4</code>. The compiler
multiplies the index <code>(i * cols) + j</code> by four because each element in
the matrix is a four-byte integer, and this multiplication enables the
compiler to calculate the correct offset.</p>
<hr />
<p>The last set of instructions adds the calculated offset to the matrix
pointer and dereferences it to yield the value of element (<em>i</em>,<em>j</em>):</p>
<pre><code>0x0804853b &lt;+52&gt;: mov 0x8(%ebp),%eax    # copy m pointer to eax
0x0804853e &lt;+55&gt;: add %edx,%eax         # add m to (i*cols+j)*4, place in eax
0x08048540 &lt;+57&gt;: mov (%eax),%eax       # copy m[i*cols+j] to eax
0x08048542 &lt;+59&gt;: add %eax,-0xc(%ebp)   # add eax to total
</code></pre>
<p>The first instruction loads the address of matrix <code>m</code> into register
<code>%eax</code>. The <code>add</code> instruction adds the offset <code>(i*cols + j)*4</code> to the
address of <code>m</code> to correctly calculate the address of element (<em>i</em>,<em>j</em>),
and then places this address in register <code>%eax</code>. The third instruction
dereferences <code>%eax</code> and places the resulting value in register <code>%eax</code>.
The last instruction adds the value in <code>%eax</code> to the accumulator
<code>total</code>, which is located at stack address <code>%ebp-0xc</code>.</p>
<p>Let's consider how element (1,2) is accessed in <a href="#Matrices732">Figure
2</a>.</p>
<p><img src="_images/matrixArray.png" alt="matrixArray" /></p>
<p>Figure 3. Matrix M1's memory layout in row-major order</p>
<p>Element (1,2) is located at address <code>M1 + (1 * COLS) + 2</code>. Since <code>COLS</code>
= 3, element (1,2) corresponds to <code>M1+5</code>. To access the element at this
location, the compiler must multiply <code>5</code> by the size of the <code>int</code> data
type (four bytes), yielding the offset <code>M1 + 20</code>, which corresponds to
byte x~20~ in the figure. Dereferencing this location yields element 5,
which is indeed element (1,2) in the matrix.</p>
<h3 id="882-noncontiguous-matrix"><a class="header" href="#882-noncontiguous-matrix">8.8.2. Noncontiguous Matrix</a></h3>
<p>The noncontiguous matrix implementation is a bit more complicated.
Figure 4 visualizes how <code>M2</code> may be laid out in
memory.</p>
<p><img src="_images/dynamicMatrixLayout.png" alt="matrixDynamic" /></p>
<p>Figure 4. Matrix M2's noncontiguous layout in memory</p>
<p>Notice that the array of pointers is contiguous, and that each array
pointed to by an element of <code>M2</code> (e.g., <code>M2[i]</code>) is contiguous. However,
the individual arrays are not contiguous with one another.</p>
<p>The <code>sumMatrix</code> function in the following example takes an array of
integer pointers (called <code>matrix</code>) as its first parameter, and a number
of rows and columns as its second and third parameters:</p>
<pre><code>int sumMatrix(int **matrix, int rows, int cols) {

    int i, j, total=0;

    for (i = 0; i &lt; rows; i++) {
        for (j = 0; j &lt; cols; j++) {
            total += matrix[i][j];
        }
    }
    return total;
}
</code></pre>
<p>Even though this function looks nearly identical to the <code>sumMat</code>
function shown earlier, the matrix accepted by this function consists of
a contiguous array of <em>pointers</em>. Each pointer contains the address of a
separate contiguous array, which corresponds to a separate row in the
matrix.</p>
<p>The corresponding assembly for <code>sumMatrix</code> follows. Each line is
annotated with its English translation.</p>
<pre><code>0x080484ad &lt;+0&gt;:  push %ebp                     # save ebp
0x080484ae &lt;+1&gt;:  mov  %esp,%ebp                # update ebp (new stack frame)
0x080484b0 &lt;+3&gt;:  sub  $0x10,%esp               # add 4 spaces to stack frame
0x080484b3 &lt;+6&gt;:  movl $0x0,-0xc(%ebp)          # copy 0 to %ebp-12 (total)
0x080484ba &lt;+13&gt;: movl $0x0,-0x4(%ebp)          # copy 0 to %ebp-4 (i)
0x080484c1 &lt;+20&gt;: jmp  0x80484fa &lt;sumMatrix+77&gt; # goto &lt;sumMatrix+77&gt;
0x080484c3 &lt;+22&gt;: movl $0x0,-0x8(%ebp)          # copy 0 to %ebp-8 (j)
0x080484ca &lt;+29&gt;: jmp  0x80484ee &lt;sumMatrix+65&gt; # goto &lt;sumMatrix+65&gt;
0x080484cc &lt;+31&gt;: mov  -0x4(%ebp),%eax          # copy i to %eax
0x080484cf &lt;+34&gt;: lea  0x0(,%eax,4),%edx        # mult i by 4, place in %edx
0x080484d6 &lt;+41&gt;: mov  0x8(%ebp),%eax           # copy matrix to %eax
0x080484d9 &lt;+44&gt;: add  %edx,%eax                # put (i * 4) + matrix in %eax
0x080484db &lt;+46&gt;: mov  (%eax),%eax              # copy matrix[i] to %eax
0x080484dd &lt;+48&gt;: mov  -0x8(%ebp),%edx          # copy j to %edx
0x080484e0 &lt;+51&gt;: shl  $0x2,%edx                # mult j by 4, place in %edx
0x080484e3 &lt;+54&gt;: add  %edx,%eax                # put (j*4)+matrix[i] in %eax
0x080484e5 &lt;+56&gt;: mov  (%eax),%eax              # copy matrix[i][j] to %eax
0x080484e7 &lt;+58&gt;: add  %eax,-0xc(%ebp)          # add matrix[i][j] to total
0x080484ea &lt;+61&gt;: addl $0x1,-0x8(%ebp)          # add 1 to j (j+=1)
0x080484ee &lt;+65&gt;: mov  -0x8(%ebp),%eax          # copy j to %eax
0x080484f1 &lt;+68&gt;: cmp  0x10(%ebp),%eax          # compare j with cols
0x080484f4 &lt;+71&gt;: jl   0x80484cc &lt;sumMatrix+31&gt; # if j&lt;cols goto&lt;sumMatrix+31&gt;
0x080484f6 &lt;+73&gt;: addl $0x1,-0x4(%ebp)          # add 1 to i (i+=1)
0x080484fa &lt;+77&gt;: mov  -0x4(%ebp),%eax          # copy i to %eax
0x080484fd &lt;+80&gt;: cmp  0xc(%ebp),%eax           # compare i with rows
0x08048500 &lt;+83&gt;: jl   0x80484c3 &lt;sumMatrix+22&gt; # if i&lt;rows goto&lt;sumMatrix+22&gt;
0x08048502 &lt;+85&gt;: mov  -0xc(%ebp),%eax          # copy total to %eax
0x08048505 &lt;+88&gt;: leave                         # prepare to leave function
0x08048506 &lt;+89&gt;: ret                           # return total
</code></pre>
<p>Again, the variables <code>i</code>, <code>j</code>, and <code>total</code> are at stack addresses
<code>%ebp-4</code>, <code>%ebp-8</code>, and <code>%ebp-12</code>, respectively. The input parameters
<code>m</code>, <code>row</code>, and <code>cols</code> are located at stack addresses <code>%ebp+8</code>,
<code>%ebp+12</code>, and <code>%ebp+16</code>, respectively.</p>
<p>Let's zoom in on the section that deals specifically with an access to
element (<em>i</em>,<em>j</em>), or <code>matrix[i][j]</code>:</p>
<pre><code>0x080484cc &lt;+31&gt;: mov -0x4(%ebp),%eax      # copy i to %eax
0x080484cf &lt;+34&gt;: lea 0x0(,%eax,4),%edx    # multiply i by 4, place in %edx
0x080484d6 &lt;+41&gt;: mov 0x8(%ebp),%eax       # copy matrix to %eax
0x080484d9 &lt;+44&gt;: add %edx,%eax            # add i*4 to matrix, place in %eax
0x080484db &lt;+46&gt;: mov (%eax),%eax          # copy matrix[i] to %eax
</code></pre>
<p>The five instructions between <code>&lt;sumMatrix+31&gt;</code> and <code>&lt;sumMatrix+46&gt;</code>
compute <code>matrix[i]</code>, or <code>*(matrix+i)</code>. Note that the compiler needs to
multiply <code>i</code> by four prior to adding it to <code>matrix</code> to calculate the
correct offset (recall that pointers are four bytes in size). The
instruction at <code>&lt;sumMatrix+46&gt;</code> then dereferences the calculated address
to get the element <code>matrix[i]</code>.</p>
<p>Since <code>matrix</code> is an array of <code>int</code> pointers, the element located at
<code>matrix[i]</code> is itself an <code>int</code> pointer. The <em>j</em>^th^ element in
<code>matrix[i]</code> is located at offset <code>j×4</code> in the <code>matrix[i]</code> array.</p>
<hr />
<p>The next set of instructions extract the <em>j</em>^th^ element in array
<code>matrix[i]</code>:</p>
<pre><code>0x080484dd &lt;+48&gt;: mov -0x8(%ebp),%edx    # copy j to %edx
0x080484e0 &lt;+51&gt;: shl $0x2,%edx          # multiply j by 4, place in %edx
0x080484e3 &lt;+54&gt;: add %edx,%eax          # add j*4 to matrix[i], place in %eax
0x080484e5 &lt;+56&gt;: mov (%eax),%eax        # copy matrix[i][j] to %eax
0x080484e7 &lt;+58&gt;: add %eax,-0xc(%ebp)    # add matrix[i][j] to total
</code></pre>
<p>The first instruction in this snippet loads variable <code>j</code> into register
<code>%edx</code>. The compiler uses the left shift (<code>shl</code>) instruction to multiply
<code>j</code> by four and stores the result in register <code>%edx</code>. The compiler then
adds the resulting value to the address located in <code>matrix[i]</code> to get
the address of <code>matrix[i][j]</code>.</p>
<p>Let's revisit Figure 4 and consider an example
access to <code>M2[1][2]</code>. For convenience, we reproduce the figure in
Figure 5.</p>
<p><img src="_images/dynamicMatrixLayout.png" alt="matrixDynamic" /></p>
<p>Figure 5. Matrix M2's noncontiguous layout in memory</p>
<p>Note that <code>M2</code> starts at memory location x~0~. The compiler first
computes the address of <code>M2[1]</code> by multiplying 1 by 4 (<code>sizeof(int *)</code>)
and adding it to the address of <code>M2</code> (x~0~), yielding the new address
x~4~. A dereference of this address yields the address associated with
<code>M2[1]</code>, or x~36~. The compiler then multiplies index 2 by 4
(<code>sizeof(int)</code>), and adds the result (8) to x~36~, yielding a final
address of x~44~. The address x~44~ is dereferenced, yielding the value
5. Sure enough, the element in Figure 5 that
corresponds to <code>M2[1][2]</code> has the value 5.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C8-IA32/arrays.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C8-IA32/structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C8-IA32/arrays.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C8-IA32/structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
