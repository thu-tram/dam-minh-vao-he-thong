<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions in Assembly - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html" class="active"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="85-functions-trong-assembly"><a class="header" href="#85-functions-trong-assembly">8.5. Functions trong Assembly</a></h2>
<p>Ở phần trước, chúng ta đã lần theo quá trình thực thi của các hàm đơn giản trong assembly.<br />
Trong phần này, chúng ta sẽ tìm hiểu cách nhiều hàm tương tác với nhau trong assembly trong bối cảnh của một chương trình lớn hơn.<br />
Chúng ta cũng sẽ giới thiệu một số lệnh mới liên quan đến việc quản lý hàm.</p>
<p>Hãy bắt đầu bằng việc ôn lại cách <strong>call stack</strong> được quản lý.<br />
Hãy nhớ rằng <code>%esp</code> là <strong>stack pointer</strong> (con trỏ stack) và luôn trỏ tới đỉnh của stack.<br />
Thanh ghi <code>%ebp</code> là <strong>base pointer</strong> (hay <strong>frame pointer</strong>) và trỏ tới đáy của <strong>stack frame</strong> hiện tại.</p>
<p><strong>Stack frame</strong> (còn gọi là <strong>activation frame</strong> hoặc <strong>activation record</strong>) là phần của stack được cấp phát cho một lần gọi hàm.<br />
Hàm đang thực thi luôn nằm ở đỉnh stack, và stack frame của nó được gọi là <strong>active frame</strong>.<br />
Active frame được giới hạn bởi stack pointer (ở đỉnh stack) và frame pointer (ở đáy frame).<br />
Activation record thường chứa các biến cục bộ và tham số của hàm.</p>
<p>Hình 1 cho thấy các stack frame của <code>main</code> và một hàm mà nó gọi tên là <code>fname</code>.<br />
Chúng ta sẽ gọi hàm <code>main</code> là <em>caller</em> (hàm gọi) và <code>fname</code> là <em>callee</em> (hàm được gọi).</p>
<p><img src="_images/stackFrame.png" alt="an illustration of stack frames" /><br />
<em>Hình 1. Quản lý stack frame</em></p>
<p>Trong Hình 1, <strong>active frame</strong> (stack frame đang hoạt động) thuộc về hàm callee (<code>fname</code>).<br />
Vùng bộ nhớ giữa stack pointer và frame pointer được dùng để lưu các biến cục bộ.<br />
Stack pointer sẽ thay đổi khi các giá trị cục bộ được push hoặc pop khỏi stack.<br />
Ngược lại, frame pointer hầu như giữ nguyên, trỏ tới điểm bắt đầu (đáy) của stack frame hiện tại.<br />
Vì lý do này, các compiler như GCC thường tham chiếu tới các giá trị trên stack dựa theo frame pointer.</p>
<p>Trong Hình 1, active frame được giới hạn phía dưới bởi base pointer của <code>fname</code>, chứa địa chỉ stack <code>0x418</code>.<br />
Giá trị lưu tại địa chỉ này là giá trị <code>%ebp</code> đã được “lưu” (<code>0x42c</code>), bản thân nó chỉ ra đáy của activation frame của hàm <code>main</code>.<br />
Đỉnh của activation frame của <code>main</code> được giới hạn bởi <strong>return address</strong>, cho biết địa chỉ trong chương trình mà <code>main</code> sẽ tiếp tục thực thi khi hàm callee kết thúc.</p>
<blockquote>
<p><strong>Return address trỏ tới bộ nhớ chương trình, không phải bộ nhớ stack</strong><br />
Hãy nhớ rằng vùng call stack (stack memory) của một chương trình khác với vùng code (code memory).<br />
<code>%ebp</code> và <code>%esp</code> trỏ tới các vị trí trong stack memory, còn <code>%eip</code> trỏ tới một vị trí trong <em>code</em> memory.<br />
Nói cách khác, return address là một địa chỉ trong code memory, không phải stack memory:</p>
<p><img src="_images/memparts.png" alt="The parts of a program's address space." /><br />
<em>Hình 2. Các phần trong không gian địa chỉ của một chương trình</em></p>
</blockquote>
<p><strong>Bảng 1. Các lệnh quản lý hàm thông dụng</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Translation</th></tr></thead><tbody>
<tr><td><code>leave</code></td><td>Chuẩn bị stack để thoát khỏi hàm. Tương đương:</td></tr>
<tr><td><code>mov %ebp, %esp</code></td><td></td></tr>
<tr><td><code>pop %ebp</code></td><td></td></tr>
<tr><td><code>call addr &lt;fname&gt;</code></td><td>Chuyển active frame sang hàm callee. Tương đương:</td></tr>
<tr><td><code>push %eip</code></td><td></td></tr>
<tr><td><code>mov addr, %eip</code></td><td></td></tr>
<tr><td><code>ret</code></td><td>Khôi phục active frame về hàm caller. Tương đương:</td></tr>
<tr><td><code>pop %eip</code></td><td></td></tr>
</tbody></table>
</div>
<p>Ví dụ, lệnh <code>leave</code> là dạng viết tắt mà compiler dùng để khôi phục stack pointer và frame pointer khi chuẩn bị thoát khỏi hàm.<br />
Khi hàm callee kết thúc, <code>leave</code> đảm bảo frame pointer được <strong>khôi phục</strong> về giá trị trước đó.</p>
<p>Hai lệnh <code>call</code> và <code>ret</code> đóng vai trò quan trọng khi một hàm gọi hàm khác.<br />
Cả hai đều thay đổi instruction pointer (<code>%eip</code>).<br />
Khi hàm caller thực thi <code>call</code>, giá trị hiện tại của <code>%eip</code> được lưu trên stack như return address — địa chỉ trong chương trình mà caller sẽ tiếp tục thực thi khi callee kết thúc.<br />
<code>call</code> cũng thay thế giá trị <code>%eip</code> bằng địa chỉ của hàm callee.</p>
<p>Lệnh <code>ret</code> khôi phục <code>%eip</code> từ giá trị lưu trên stack, đảm bảo chương trình tiếp tục tại địa chỉ được chỉ định trong hàm caller.<br />
Bất kỳ giá trị trả về nào từ callee sẽ được lưu trong <code>%eax</code>.<br />
<code>ret</code> thường là lệnh cuối cùng trong mọi hàm.</p>
<h3 id="851-lần-theo-một-ví-dụ"><a class="header" href="#851-lần-theo-một-ví-dụ">8.5.1. Lần theo một ví dụ</a></h3>
<p>Dựa trên kiến thức về quản lý hàm, hãy lần theo ví dụ code đã được giới thiệu ở đầu chương:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int assign(void) {
    int y = 40;
    return y;
}

int adder(void) {
    int a;
    return a + 2;
}

int main(void) {
    int x;
    assign();
    x = adder();
    printf(&quot;x is: %d\n&quot;, x);
    return 0;
}
</code></pre>
<p>Chúng ta biên dịch code với cờ <code>-m32</code> và dùng <code>objdump -d</code> để xem code assembly.<br />
Lệnh này xuất ra một file khá lớn với nhiều thông tin không cần thiết.<br />
Dùng <code>less</code> và chức năng tìm kiếm để trích xuất các hàm <code>adder</code>, <code>assign</code> và <code>main</code>:</p>
<pre><code class="language-assembly"> 804840d &lt;assign&gt;:
 804840d:       55                      push   %ebp
 804840e:       89 e5                   mov    %esp,%ebp
 8048410:       83 ec 10                sub    $0x10,%esp
 8048413:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%ebp)
 804841a:       8b 45 fc                mov    -0x4(%ebp),%eax
 804841d:       c9                      leave
 804841e:       c3                      ret

 0804841f &lt;adder&gt;:
 804841f:       55                      push   %ebp
 8048420:       89 e5                   mov    %esp,%ebp
 8048422:       83 ec 10                sub    $0x10,%esp
 8048425:       8b 45 fc                mov    -0x4(%ebp),%eax
 8048428:       83 c0 02                add    $0x2,%eax
 804842b:       c9                      leave
 804842c:       c3                      ret

 0804842d &lt;main&gt;:
 804842d:       55                      push   %ebp
 804842e:       89 e5                   mov    %esp,%ebp
 8048433:       83 ec 20                sub    $0x14,%esp
 8048436:       e8 d2 ff ff ff          call   804840d &lt;assign&gt;
 804843b:       e8 df ff ff ff          call   804841f &lt;adder&gt;
 8048440:       89 44 24 1c             mov    %eax,0xc(%esp)
 8048444:       8b 44 24 1c             mov    0xc(%esp),%eax
 8048448:       89 44 24 04             mov    %eax,0x4(%esp)
 804844c:       c7 04 24 f4 84 04 08    movl   $0x80484f4,(%esp)
 8048453:       e8 88 fe ff ff          call   80482e0 &lt;printf@plt&gt;
 8048458:       b8 00 00 00 00          mov    $0x0,%eax
 804845d:       c9                      leave
 804845e:       c3                      ret
</code></pre>
<p>Mỗi hàm bắt đầu bằng một <strong>nhãn ký hiệu</strong> (symbolic label) tương ứng với tên hàm trong chương trình.<br />
Ví dụ, <code>&lt;main&gt;:</code> là nhãn ký hiệu cho hàm <code>main</code>.<br />
Địa chỉ của nhãn hàm cũng là địa chỉ của lệnh đầu tiên trong hàm đó.<br />
Để tiết kiệm không gian trong các hình minh họa tiếp theo, chúng ta rút gọn địa chỉ xuống 12 bit thấp.<br />
Ví dụ, địa chỉ chương trình <code>0x804842d</code> sẽ được hiển thị là <code>0x42d</code>.</p>
<h3 id="852-lần-theo-hàm-main"><a class="header" href="#852-lần-theo-hàm-main">8.5.2. Lần theo hàm main</a></h3>
<p><strong>Hình 3</strong> cho thấy execution stack ngay trước khi thực thi <code>main</code>.</p>
<p><img src="_images/procedures/Slide1.png" alt="slide1" /></p>
<p><strong>Hình 3</strong> minh họa trạng thái ban đầu của các thanh ghi CPU và call stack trước khi thực thi hàm <code>main</code>.</p>
<p>Hãy nhớ rằng stack phát triển về phía <strong>địa chỉ thấp hơn</strong>.<br />
Trong ví dụ này, <code>%ebp</code> có giá trị địa chỉ <code>0x140</code> và <code>%esp</code> là <code>0x130</code> (cả hai giá trị này chỉ là giả định).<br />
Các thanh ghi <code>%eax</code> và <code>%edx</code> ban đầu chứa giá trị rác.<br />
Mũi tên đỏ (góc trên bên trái) chỉ ra lệnh đang được thực thi.<br />
Ban đầu, <code>%eip</code> chứa địa chỉ <code>0x42d</code>, là địa chỉ trong bộ nhớ chương trình của dòng đầu tiên trong hàm <code>main</code>.<br />
Hãy cùng lần theo quá trình thực thi của chương trình.</p>
<p><img src="_images/procedures/Slide2.png" alt="slide2" /></p>
<p>Lệnh đầu tiên <strong>push</strong> giá trị của <code>%ebp</code> lên stack, lưu địa chỉ <code>0x140</code>.<br />
Vì stack phát triển về phía địa chỉ thấp hơn, stack pointer <code>%esp</code> được cập nhật thành <code>0x12c</code> (giảm 4 byte so với <code>0x130</code>).<br />
Thanh ghi <code>%eip</code> tăng lên để trỏ tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide3.png" alt="slide3" /></p>
<p>Lệnh tiếp theo (<code>mov %esp, %ebp</code>) cập nhật giá trị của <code>%ebp</code> thành giá trị của <code>%esp</code>.<br />
Frame pointer (<code>%ebp</code>) giờ trỏ tới đầu stack frame của hàm <code>main</code>.<br />
<code>%eip</code> tiếp tục trỏ tới lệnh kế tiếp.</p>
<p><img src="_images/procedures/Slide4.png" alt="slide4" /></p>
<p>Lệnh <code>sub</code> trừ <code>0x14</code> khỏi địa chỉ trong stack pointer, “mở rộng” stack thêm 20 byte.<br />
<code>%eip</code> trỏ tới lệnh tiếp theo, đây là lệnh <code>call</code> đầu tiên.</p>
<p><img src="_images/procedures/Slide5.png" alt="slide5" /></p>
<p>Lệnh <code>call &lt;assign&gt;</code> sẽ <strong>push</strong> giá trị trong <code>%eip</code> (địa chỉ của lệnh <em>tiếp theo</em> sẽ thực thi) lên stack.<br />
Vì lệnh tiếp theo sau <code>call &lt;assign&gt;</code> có địa chỉ <code>0x43b</code>, giá trị này được đẩy lên stack làm <strong>return address</strong>.<br />
Hãy nhớ rằng return address cho biết chương trình sẽ tiếp tục thực thi ở đâu khi hàm kết thúc và quay lại <code>main</code>.</p>
<p>Sau đó, lệnh <code>call</code> sẽ đưa địa chỉ của hàm <code>assign</code> (<code>0x40d</code>) vào <code>%eip</code>, báo hiệu rằng chương trình sẽ tiếp tục thực thi trong hàm được gọi (<code>assign</code>) thay vì lệnh tiếp theo trong <code>main</code>.</p>
<p><img src="_images/procedures/Slide6.png" alt="slide6" /></p>
<p>Hai lệnh đầu tiên trong hàm <code>assign</code> là các thao tác khởi tạo mà mọi hàm đều thực hiện.<br />
Lệnh đầu tiên <strong>push</strong> giá trị trong <code>%ebp</code> (địa chỉ <code>0x12c</code>) lên stack.<br />
Hãy nhớ rằng địa chỉ này trỏ tới đầu stack frame của <code>main</code>.<br />
<code>%eip</code> trỏ tới lệnh thứ hai trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide7.png" alt="slide7" /></p>
<p>Lệnh tiếp theo (<code>mov %esp, %ebp</code>) cập nhật <code>%ebp</code> để trỏ tới đỉnh stack, đánh dấu bắt đầu stack frame của <code>assign</code>.<br />
Instruction pointer (<code>%eip</code>) trỏ tới lệnh kế tiếp trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide8.png" alt="slide8" /></p>
<p>Lệnh <code>sub</code> tại địa chỉ <code>0x410</code> mở rộng stack thêm 16 byte, tạo không gian lưu trữ giá trị cục bộ và cập nhật <code>%esp</code>.<br />
Instruction pointer tiếp tục trỏ tới lệnh kế tiếp trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide9.png" alt="slide9" /></p>
<p>Lệnh <code>mov</code> tại địa chỉ <code>0x413</code> đưa giá trị <code>$0x28</code> (tức 40) vào vị trí <code>-0x4(%ebp)</code> trên stack, tức là 4 byte phía trên frame pointer.<br />
Hãy nhớ rằng frame pointer thường được dùng để tham chiếu tới các vị trí trên stack.<br />
<code>%eip</code> trỏ tới lệnh kế tiếp trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide10.png" alt="slide10" /></p>
<p>Lệnh <code>mov</code> tại địa chỉ <code>0x41a</code> đưa giá trị <code>$0x28</code> vào thanh ghi <code>%eax</code>, là nơi lưu giá trị trả về của hàm.<br />
<code>%eip</code> trỏ tới lệnh <code>leave</code> trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide11.png" alt="slide11" /></p>
<p>Tại thời điểm này, hàm <code>assign</code> gần như đã thực thi xong.<br />
Lệnh tiếp theo được thực thi là lệnh <code>leave</code>, lệnh này chuẩn bị stack để trả về từ lời gọi hàm.<br />
Hãy nhớ rằng <code>leave</code> tương đương với cặp lệnh sau:</p>
<pre><code>mov %ebp, %esp
pop %ebp
</code></pre>
<p>Nói cách khác, CPU ghi đè giá trị của stack pointer bằng giá trị của frame pointer.<br />
Trong ví dụ này, stack pointer ban đầu được cập nhật từ <code>0x100</code> thành <code>0x110</code>.<br />
Tiếp theo, CPU thực thi <code>pop %ebp</code>, lấy giá trị tại địa chỉ <code>0x110</code> (trong ví dụ này là <code>0x12c</code>) và đặt vào <code>%ebp</code>.<br />
Hãy nhớ rằng <code>0x12c</code> là điểm bắt đầu của stack frame dành cho <code>main</code>.<br />
<code>%esp</code> trở thành <code>0x114</code> và <code>%eip</code> trỏ tới lệnh <code>ret</code> trong hàm <code>assign</code>.</p>
<p><img src="_images/procedures/Slide12.png" alt="slide12" /></p>
<p>Lệnh cuối cùng trong <code>assign</code> là <code>ret</code>. Khi <code>ret</code> được thực thi, địa chỉ trả về sẽ được lấy ra khỏi stack và đưa vào thanh ghi <code>%eip</code>.<br />
Trong ví dụ này, <code>%eip</code> được cập nhật để trỏ tới lời gọi hàm <code>adder</code>.</p>
<p>Một số điểm quan trọng cần lưu ý tại thời điểm này:</p>
<ul>
<li>Stack pointer và frame pointer đã được khôi phục về giá trị trước khi gọi <code>assign</code>, phản ánh rằng stack frame của <code>main</code> lại trở thành active frame.</li>
<li>Các giá trị cũ trên stack từ stack frame trước đó <strong>không</strong> bị xóa. Chúng vẫn tồn tại trên call stack.</li>
</ul>
<p><img src="_images/procedures/Slide13.png" alt="slide13" /></p>
<p>Lời gọi hàm <code>adder</code> <strong>ghi đè</strong> địa chỉ trả về cũ trên stack bằng một địa chỉ trả về mới (<code>0x440</code>).<br />
Địa chỉ này trỏ tới lệnh sẽ được thực thi tiếp theo sau khi <code>adder</code> trả về, đó là <code>mov %eax, 0xc(%ebp)</code>.<br />
<code>%eip</code> lúc này trỏ tới lệnh đầu tiên trong <code>adder</code> tại địa chỉ <code>0x41f</code>.</p>
<p><img src="_images/procedures/Slide14.png" alt="slide14" /></p>
<p>Lệnh đầu tiên trong hàm <code>adder</code> lưu frame pointer của hàm gọi (<code>%ebp</code> của <code>main</code>) lên stack.</p>
<p><img src="_images/procedures/Slide15.png" alt="slide15" /></p>
<p>Lệnh tiếp theo cập nhật <code>%ebp</code> bằng giá trị hiện tại của <code>%esp</code> (địa chỉ <code>0x110</code>).<br />
Hai lệnh này cùng nhau thiết lập điểm bắt đầu của stack frame cho <code>adder</code>.</p>
<p><img src="_images/procedures/Slide16.png" alt="slide16" /></p>
<p>Lệnh <code>sub</code> tại địa chỉ <code>0x422</code> “mở rộng” stack thêm 16 byte.<br />
Lưu ý rằng việc mở rộng stack không ảnh hưởng tới các giá trị đã tồn tại trước đó trên stack.<br />
Những giá trị cũ sẽ vẫn nằm trên stack cho tới khi bị ghi đè.</p>
<p><img src="_images/procedures/Slide17.png" alt="slide20" /></p>
<p>Hãy chú ý tới lệnh tiếp theo:<br />
<code>mov $-0x4(%ebp), %eax</code>.<br />
Lệnh này di chuyển <strong>một giá trị cũ</strong> đang nằm trên stack vào thanh ghi <code>%eax</code>!<br />
Điều này xảy ra trực tiếp do lập trình viên quên khởi tạo biến <code>a</code> trong hàm <code>adder</code>.</p>
<p><img src="_images/procedures/Slide18.png" alt="slide18" /></p>
<p>Lệnh <code>add</code> tại địa chỉ <code>0x428</code> cộng 2 vào giá trị trong <code>%eax</code>.<br />
Hãy nhớ rằng IA32 truyền giá trị trả về qua <code>%eax</code>.<br />
Hai lệnh cuối này tương đương với đoạn code trong <code>adder</code>:</p>
<pre><code class="language-c">int a;
return a + 2;
</code></pre>
<p><img src="_images/procedures/Slide19.png" alt="slide19" /></p>
<p>Sau khi <code>leave</code> được thực thi, frame pointer lại trỏ tới đầu stack frame của <code>main</code> (<code>0x12c</code>).<br />
Stack pointer lúc này chứa địa chỉ <code>0x114</code>.</p>
<p><img src="_images/procedures/Slide20.png" alt="slide20" /></p>
<p>Lệnh <code>ret</code> lấy địa chỉ trả về ra khỏi stack, khôi phục <code>%eip</code> về <code>0x440</code> — địa chỉ của lệnh tiếp theo trong <code>main</code>.<br />
<code>%esp</code> lúc này là <code>0x118</code>.</p>
<p><img src="_images/procedures/Slide21.png" alt="slide21" /></p>
<p>Lệnh <code>mov %eax, 0xc(%esp)</code> đặt giá trị trong <code>%eax</code> vào vị trí cách <code>%esp</code> 12 byte (tức ba ô nhớ).</p>
<p><img src="_images/procedures/Slide23.png" alt="slide23" /></p>
<p>Bỏ qua một vài bước, các lệnh <code>mov</code> tại địa chỉ <code>0x444</code> và <code>0x448</code> gán <code>%eax</code> bằng giá trị lưu tại <code>%esp+12</code> (<code>0x2A</code>) và đặt <code>0x2A</code> vào vị trí ngay dưới đỉnh stack (<code>%esp + 4</code>, tức <code>0x11c</code>).</p>
<p><img src="_images/procedures/Slide24.png" alt="slide24" /></p>
<p>Lệnh tiếp theo (<code>mov $0x80484f4, (%esp)</code>) sao chép một hằng số là địa chỉ bộ nhớ lên đỉnh stack.<br />
Địa chỉ này (<code>0x80484f4</code>) chứa chuỗi <code>&quot;x is %d\n&quot;</code>.<br />
<code>%eip</code> trỏ tới lời gọi hàm <code>printf</code> (<code>&lt;printf@plt&gt;</code>).</p>
<p><img src="_images/procedures/Slide25.png" alt="slide25" /></p>
<p>Để ngắn gọn, chúng ta sẽ không lần theo hàm <code>printf</code> (thuộc <code>stdio.h</code>).<br />
Tuy nhiên, theo trang hướng dẫn (<code>man -s3 printf</code>), <code>printf</code> có dạng:</p>
<pre><code class="language-c">int printf(const char * format, ...);
</code></pre>
<p>Nói cách khác, tham số đầu tiên là con trỏ tới chuỗi định dạng, các tham số tiếp theo là các giá trị được chèn vào định dạng đó.<br />
Các lệnh từ <code>0x444</code> đến <code>0x45c</code> tương ứng với dòng code trong <code>main</code>:</p>
<pre><code class="language-c">printf(&quot;x is %d\n&quot;, x);
</code></pre>
<p>Khi <code>printf</code> được gọi:</p>
<ul>
<li>Địa chỉ trả về (lệnh sẽ thực thi sau <code>printf</code>) được đẩy lên stack.</li>
<li>Giá trị <code>%ebp</code> được đẩy lên stack, và <code>%ebp</code> được cập nhật để trỏ tới đỉnh stack, đánh dấu bắt đầu stack frame của <code>printf</code>.</li>
</ul>
<p>Tại một thời điểm nào đó, <code>printf</code> sẽ truy cập các tham số của nó: chuỗi <code>&quot;x is %d\n&quot;</code> và giá trị <code>0x2A</code>.<br />
Hãy nhớ rằng địa chỉ trả về nằm ngay dưới <code>%ebp</code> tại <code>%ebp+4</code>.<br />
Tham số đầu tiên nằm tại <code>%ebp+8</code> (ngay dưới địa chỉ trả về), tham số thứ hai tại <code>%ebp+12</code>.</p>
<p>Với một hàm có <em>n</em> tham số, GCC đặt tham số thứ nhất tại <code>%ebp+8</code>, tham số thứ hai tại <code>%ebp+12</code>, và tham số thứ <em>n</em> tại <code>(%ebp+8) + (4*(n-1))</code>.</p>
<p>Sau khi <code>printf</code> được gọi, giá trị <code>0x2A</code> được in ra màn hình ở dạng số nguyên, tức là in ra <strong>42</strong>.</p>
<p><img src="_images/procedures/Slide26.png" alt="slide26" /></p>
<p>Sau khi gọi <code>printf</code>, một vài lệnh cuối sẽ dọn dẹp stack và chuẩn bị thoát khỏi <code>main</code>.<br />
Đầu tiên, giá trị <code>0x0</code> được đặt vào <code>%eax</code>, báo hiệu rằng <code>main</code> trả về 0.<br />
Hãy nhớ rằng chương trình trả về 0 để biểu thị kết thúc thành công.</p>
<p><img src="_images/procedures/Slide27.png" alt="slide27" /></p>
<p>Sau khi <code>leave</code> và <code>ret</code> được thực thi, stack pointer và frame pointer trở về giá trị ban đầu trước khi <code>main</code> chạy.<br />
Với <code>0x0</code> trong <code>%eax</code>, chương trình trả về 0.</p>
<p>Nếu bạn đã đọc kỹ phần này, bạn sẽ hiểu vì sao chương trình in ra giá trị <strong>42</strong>.<br />
Về bản chất, chương trình đã vô tình sử dụng các giá trị cũ trên stack, khiến nó hoạt động theo cách không mong đợi.<br />
Ví dụ này khá vô hại, nhưng ở các phần sau, chúng ta sẽ thấy cách hacker lợi dụng lời gọi hàm để khiến chương trình hoạt động sai lệch theo hướng thực sự nguy hiểm.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C8-IA32/loops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C8-IA32/recursion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C8-IA32/loops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C8-IA32/recursion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
