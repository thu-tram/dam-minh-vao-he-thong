
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into Assembly](index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [6. Under the C: Dive into Assembly](index.html)
:::

::: content
::: sect1
## [](#_assembly_chapter){.anchor}6. Under the C: Diving into Assembly {#_assembly_chapter}

::: sectionbody
::: paragraph
*Under the C, under the C*
:::

::: paragraph
*Don't you know it's better*
:::

::: paragraph
*Dealing with registers*
:::

::: paragraph
*And assembly?*
:::

::: paragraph
-Sebastian, probably
:::

::: paragraph
Prior to the invention of the compiler in the early days of computing,
many programmers coded in **assembly language**, which directly
specifies the set of instructions that a computer follows during
execution. Assembly language is the closest a programmer gets to coding
at the machine level without writing code directly in 1s and 0s, and is
a readable form of **machine code**. To write efficient assembly code,
programmers must intimately understand the operation of the underlying
machine architecture.
:::

::: paragraph
The invention of the compiler fundamentally changed the way programmers
write code. A **compiler** translates a human-readable programming
language (usually written using English words) into a language that a
computer understands (i.e., machine code). Compilers translate the
human-readable code into machine code using the rules of the programming
language, the specification of the operating system, and the instruction
set of the machine, and provide some error detection and type checking
in the process. Most modern compilers produce assembly code that is as
efficient as the handwritten assembly code of yesteryear.
:::

### The Benefits of Learning Assembly {#_the_benefits_of_learning_assembly .discrete}

::: paragraph
Given all the benefits of compilers, it may not be obvious why learning
assembly is useful. However, there are several compelling reasons to
learn and understand assembly code. Here are a few examples.
:::

#### 1. Higher-Level Abstraction Hides Valuable Program Details {#_1_higher_level_abstraction_hides_valuable_program_details .discrete}

::: paragraph
The abstraction provided by high-level programming languages is a boon
for reducing the complexity of programming. At the same time, this
simplification makes it easy for programmers to make design decisions
without fully understanding the ramifications of their choices at the
machine level. Lacking knowledge of assembly often prevents a programmer
from understanding valuable information on how a program runs, and
limits their ability to understand what their code is actually doing.
:::

::: paragraph
As an example, take a look at the following program:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

int adder() {
    int a;
    return a + 2;
}

int assign() {
    int y = 40;
    return y;
}

int main(void) {
    int x;
    assign();
    x = adder();
    printf("x is: %d\n", x);
    return 0;
}
```
:::
:::

::: paragraph
What is the program's output? At first glance, the `assign` function
appears to have no effect, as its return value is not stored by any
variable in `main`. The `adder` function returns the value of `a + 2`,
although the variable `a` is uninitialized (though on some machines the
compiler will initialize `a` to 0). Printing out `x` should result in an
undefined value. However, compiling and running it on most 64-bit
machines consistently produces an answer of `42`:
:::

::: listingblock
::: content
    $ gcc -o example example.c
    $ ./example
    x is: 42
:::
:::

::: paragraph
The output of this program seems nonsensical at first glance, as the
`adder` and `assign` functions appear to be disconnected. Understanding
stack frames and how functions execute under the hood will help you
understand why the answer is `42`. We will revisit this example in the
upcoming chapters.
:::

#### 2. Some Computing Systems Are Too Resource-Constrained for Compilers {#_2_some_computing_systems_are_too_resource_constrained_for_compilers .discrete}

::: paragraph
The most common types of \"computer\" are those we cannot readily
identify as computers. These devices exist everywhere from cars and
coffee makers to washing machines and smart watches. Sensors,
microcontrollers, and other embedded processors play an increasingly
dominant role in our lives, and all require software to operate.
However, the processors contained in such devices are often so small
that they cannot execute the compiled code written by higher-level
programming languages. In many cases, these devices require standalone
assembly programs that are not dependent on the runtime libraries
required by common programming languages.
:::

#### 3. Vulnerability Analysis {#_3_vulnerability_analysis .discrete}

::: paragraph
A subset of security professionals spend their days trying to identify
vulnerabilities in various types of computer systems. Many avenues for
attacking a program involve the way the program stores its runtime
information. Learning assembly enables security professionals to
understand how vulnerabilities arise and how they can be exploited.
:::

::: paragraph
Other security professionals spend time \"reverse engineering\"
malicious code in malware and other malicious software. A working
knowledge of assembly is essential to enable these software engineers to
quickly develop countermeasures to protect systems against attack.
Lastly, developers who lack an understanding of how the code they write
translates to assembly may end up unwittingly writing vulnerable code.
:::

#### 4. Critical Code Sequences in System-Level Software {#_4_critical_code_sequences_in_system_level_software .discrete}

::: paragraph
Lastly, there are some components of a computer system that just cannot
be optimized sufficiently by compilers and require handwritten assembly.
Some system levels have handwritten assembly code in areas where
detailed machine-specific optimizations are critical for performance.
For example, the boot sequence on all computers is written in assembly
code. Operating systems often contain handwritten assembly for thread or
process context-switching. Humans are often able to produce
better-optimized assembly code than compilers for these short and
performance-critical sequences.
:::

### What You Will Learn in the Coming Chapters {#_what_you_will_learn_in_the_coming_chapters .discrete}

::: paragraph
The next three chapters cover three different flavors of assembly.
[Chapter 7](../C7-x86_64/index.html#_x64_assembly_chapter){.page} and
[Chapter 8](../C8-IA32/index.html#_IA32_assembly_chapter){.page} cover
x86_64 and its earlier form, IA32. [Chapter
9](../C9-ARM64/index.html#_a64_assembly_chapter){.page} covers ARMv8-A
assembly, which is the ISA found on most modern ARM devices, including
single-board computers like the Raspberry Pi. [Chapter
10](../C10-asm_takeaways/index.html#_assembly_summary){.page} contains a
summary and some key takeaways for learning assembly.
:::

::: paragraph
Each of these different flavors of assembly implement different
instruction set architectures (ISAs). Recall that an
[ISA](../C5-Arch/index.html#_what_von_neumann_knew_computer_architecture){.page}
defines the set of instructions and their binary encoding, the set of
CPU registers, and the effects of executing instructions on the state of
the CPU and memory.
:::

::: paragraph
In the following three chapters, you will see general similarities
across all the ISAs, including that CPU registers are used as operands
of many instructions, and that each ISA provides similar types of
instructions:
:::

::: {.olist .arabic}
1.  instructions for computing arithmetic and logic operations, such as
    addition or bitwise AND

2.  instructions for control flow that are used to implement branching
    such as if-else, loops, and function call and return

3.  instructions for data movement that load and store values between
    CPU registers and memory

4.  instructions for pushing and popping values from the stack. These
    instructions are used to implement the execution call stack, where a
    new frame of stack memory (that stores a running function's local
    variables and parameters) is added to the top of the stack on a
    function call, and a frame is removed from the top of the stack on a
    function return.
:::

::: paragraph
A C compiler translates C source code to a specific ISA instruction set.
The compiler translates C statements, including loops, `if`-`else`,
function calls, and variable access, to a specific set of instructions
that are defined by the ISA and implemented by a CPU that is designed to
execute instructions from the specific ISA. For example, a compiler
translates C to x86 instructions for execution on an Intel x86
processor, or translates C to ARM instructions for execution on an ARM
processor.
:::

::: paragraph
As you read the chapters in the assembly part of the book, you may
notice that some key terms are defined again and that some figures are
reproduced. To best aid other CS educators, we designed each chapter to
be used independently at particular colleges and universities. While
most of the material in each chapter is unique, we hope the
commonalities between the chapters help reinforce the similarities
between the different flavors of assembly in the mind of readers.
:::

::: paragraph
Ready to learn assembly? Let's dive right in! Follow the links below to
visit particular chapters of interest:
:::

::: ulist
-   [x86-64
    Assembly](../C7-x86_64/index.html#_x64_assembly_chapter){.page}

-   [IA32 Assembly](../C8-IA32/index.html#_IA32_assembly_chapter){.page}

-   [ARMv8-A
    Assembly](../C9-ARM64/index.html#_a64_assembly_chapter){.page}
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
