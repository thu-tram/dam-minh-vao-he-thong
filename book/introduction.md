
### [Dive Into Systems](index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](index-2.html){.nav-link}
        -   [Copyright](copyright.html){.nav-link}
        -   [Acknowledgements](acknowledgements.html){.nav-link}
        -   [Preface](preface.html){.nav-link}
    -   [0. Introduction](introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful C](C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](C3-C_debug/summary.html){.nav-link}

-   -   [4. Binary and Data
        Representation](C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common Instructions](C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in Assembly](C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](C8-IA32/basics.html){.nav-link}
        -   [8.2. Common Instructions](C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in Assembly](C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common Instructions](C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in Assembly](C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in Assembly](C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3. Locality](C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared Memory](C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](Appendix2/timing.html){.nav-link}
        -   [17.11 Command History](Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](Appendix2/sysinfo.html){.nav-link}
:::

::: {.nav-panel-explore panel="explore"}
::: context
[Dive Into Systems]{.title} [1.2]{.version}
:::

-   [Dive Into Systems]{.title}
    -   [1.2](index-2.html)
:::
:::
:::

::: {.article role="main"}
::: {.toolbar role="navigation"}
[](index-2.html){.home-link}

-   [Dive Into Systems](index-2.html)
-   [0. Introduction](introduction.html)
:::

::: content
::: sect1
## [](#_introduction){.anchor}0. Introduction {#_introduction}

::: sectionbody
::: paragraph
Dive into the fabulous world of computer systems! Understanding what a
computer system is and how it runs your programs can help you to design
code that runs efficiently and that can make the best use of the power
of the underlying system. In this book, we take you on a journey through
computer systems. You will learn how your program written in a
high-level programming language (we use C) executes on a computer. You
will learn how program instructions translate into binary and how
circuits execute their binary encoding. You will learn how an operating
system manages programs running on the system. You will learn how to
write programs that can make use of multicore computers. Throughout, you
will learn how to evaluate the systems costs associated with program
code and how to design programs to run efficiently.
:::

## What Is a Computer System? {#_what_is_a_computer_system .discrete}

::: paragraph
A **computer system** combines the computer hardware and special system
software that together make the computer usable by users and programs.
Specifically, a computer system has the following components (see
[Figure 1](#FigLayeredComponents)):
:::

::: ulist
-   **Input/output (IO) ports** enable the computer to take information
    from its environment and display it back to the user in some
    meaningful way.

-   A **central processing unit (CPU)** runs instructions and computes
    data and memory addresses.

-   **Random access memory (RAM)** stores the data and instructions of
    running programs. The data and instructions in RAM are typically
    lost when the computer system loses power.

-   **Secondary storage devices** like hard disks store programs and
    data even when power is not actively being provided to the computer.

-   An **operating system (OS)** software layer lies between the
    hardware of the computer and the software that a user runs on the
    computer. The OS implements programming abstractions and interfaces
    that enable users to easily run and interact with programs on the
    system. It also manages the underlying hardware resources and
    controls how and when programs execute. The OS implements
    abstractions, policies, and mechanisms to ensure that multiple
    programs can simultaneously run on the system in an efficient,
    protected, and seamless manner.
:::

::: paragraph
The first four of these define the **computer hardware** component of a
computer system. The last item (the operating system) represents the
main software part of the computer system. There may be additional
software layers on top of an OS that provide other interfaces to users
of the system (e.g., libraries). However, the OS is the core system
software that we focus on in this book.
:::

::: {#FigLayeredComponents .imageblock .text-center}
::: content
![A computer system with multiple layers. The bottom shows the hardware
(CPU, RAM, and Disk). Above it sits the operating system (e.g., Mac OS,
Linux, or Windows). User programs execute on
top.](_images/computersystem.png){width="600"}
:::

::: title
Figure 1. The layered components of a computer system
:::
:::

::: paragraph
We focus specifically on computer systems that have the following
qualities:
:::

::: ulist
-   They are **general purpose**, meaning that their function is not
    tailored to any specific application.

-   They are **reprogrammable**, meaning that they support running a
    different program without modifying the computer hardware or system
    software.
:::

::: paragraph
To this end, many devices that may \"compute\" in some form do not fall
into the category of a computer system. Calculators, for example,
typically have a processor, limited amounts of memory, and I/O
capability. However, calculators typically do not have an operating
system (advanced graphing calculators like the TI-89 are a notable
exception to this rule), do not have secondary storage, and are not
general purpose.
:::

::: paragraph
Another example that bears mentioning is the microcontroller, a type of
integrated circuit that has many of the same capabilities as a computer.
Microcontrollers are often embedded in other devices (such as toys,
medical devices, cars, and appliances), where they control a specific
automatic function. Although microcontrollers are general purpose,
reprogrammable, contain a processor, internal memory, secondary storage,
and are I/O capable, they lack an operating system. A microcontroller is
designed to boot and run a single specific program until it loses power.
For this reason, a microcontroller does not fit our definition of a
computer system.
:::

## What Do Modern Computer Systems Look Like? {#_what_do_modern_computer_systems_look_like .discrete}

::: paragraph
Now that we have established what a computer system is (and isn't),
let's discuss what computer systems typically look like. [Figure
2](#FigDesktopLaptop) depicts two types of computer hardware systems
(excluding peripherals): a desktop computer (left) and a laptop computer
(right). A U.S. quarter on each device gives the reader an idea of the
size of each unit.
:::

::: {#FigDesktopLaptop .imageblock}
::: content
![Photos of the components (e.g., CPU, power supply, disks, etc.) of a
desktop and laptop.](_images/desktop_laptop_labeled.png)
:::

::: title
Figure 2. Common computer systems: a desktop (left) and a laptop (right)
computer
:::
:::

::: paragraph
Notice that both contain the same hardware components, though some of
the components may have a smaller form factor or be more compact. The
DVD/CD bay of the desktop was moved to the side to show the hard drive
underneath --- the two units are stacked on top of each other. A
dedicated power supply helps provide the desktop power.
:::

::: paragraph
In contrast, the laptop is flatter and more compact (note that the
quarter in this picture appears a bit bigger). The laptop has a battery
and its components tend to be smaller. In both the desktop and the
laptop, the CPU is obscured by a heavyweight CPU fan, which helps keep
the CPU at a reasonable operating temperature. If the components
overheat, they can become permanently damaged. Both units have dual
inline memory modules (DIMM) for their RAM units. Notice that laptop
memory modules are significantly smaller than desktop modules.
:::

::: paragraph
In terms of weight and power consumption, desktop computers typically
consume 100 - 400 W of power and typically weigh anywhere from 5 to 20
pounds. A laptop typically consumes 50 - 100 W of power and uses an
external charger to supplement the battery as needed.
:::

::: paragraph
The trend in computer hardware design is toward smaller and more compact
devices. [Figure 3](#FigRaspPi) depicts a Raspberry Pi single-board
computer. A single-board computer (SBC) is a device in which the
entirety of the computer is printed on a single circuit board.
:::

::: {#FigRaspPi .imageblock}
::: content
![Photo of a raspberry pi single-board
computer.](_images/pi_labeled.png)
:::

::: title
Figure 3. A Raspberry Pi single-board computer
:::
:::

::: paragraph
The Raspberry Pi SBC contains a **system-on-a-chip** (SoC) processor
with integrated RAM and CPU, which encompasses much of the laptop and
desktop hardware shown in [Figure 2](#FigDesktopLaptop). Unlike laptop
and desktop systems, the Raspberry Pi is roughly the size of a credit
card, weighs 1.5 ounces (about a slice of bread), and consumes about 5 W
of power. The SoC technology found on the Raspberry Pi is also commonly
found in smartphones. In fact, the smartphone is another example of a
computer system!
:::

::: paragraph
Lastly, all of the aforementioned computer systems (Raspberry Pi and
smartphones included) have **multicore** processors. In other words,
their CPUs are capable of executing multiple programs simultaneously. We
refer to this simultaneous execution as **parallel execution**. Basic
multicore programming is covered in Chapter 14 of this book.
:::

::: paragraph
All of these different types of computer hardware systems can run one or
more general purpose operating systems, such as macOS, Windows, or Unix.
A general-purpose operating system manages the underlying computer
hardware and provides an interface for users to run any program on the
computer. Together these different types of computer hardware running
different general-purpose operating systems make up a computer system.
:::

## What You Will Learn In This Book {#_what_you_will_learn_in_this_book .discrete}

::: paragraph
By the end of this book, you will know the following:
:::

::: paragraph
**How a computer runs a program**: You will be able to describe, in
detail, how a program expressed in a high-level programming language
gets executed by the low-level circuitry of the computer hardware.
Specifically, you will know:
:::

::: ulist
-   how program data gets encoded into binary and how the hardware
    performs arithmetic on it

-   how a compiler translates C programs into assembly and binary
    machine code (assembly is the human-readable form of binary machine
    code)

-   how a CPU executes binary instructions on binary program data, from
    basic logic gates to complex circuits that store values, perform
    arithmetic, and control program execution

-   how the OS implements the interface for users to run programs on the
    system and how it controls program execution on the system while
    managing the system's resources.
:::

::: paragraph
**How to evaluate systems costs associated with a program's
performance**: A program runs slowly for a number of reasons. It could
be a bad algorithm choice or simply bad choices on how your program uses
system resources. You will understand the [Memory
Hierarchy](C11-MemHierarchy/mem_hierarchy.html#_the_memory_hierarchy){.page}
and its effects on program performance, and the operating systems costs
associated with program performance. You will also learn some valuable
tips for code optimization. Ultimately, you will be able to design
programs that use system resources efficiently, and you will know how to
evaluate the systems costs associated with program execution.
:::

::: paragraph
**How to leverage the power of parallel computers with parallel
programming**: Taking advantage of parallel computing is important in
today's multicore world. You will learn to exploit the multiple cores on
your CPU to make your program run faster. You will know the basics of
multicore hardware, the OS's thread abstraction, and issues related to
multithreaded parallel program execution. You will have experience with
parallel program design and writing multithreaded parallel programs
using the POSIX thread library (Pthreads). You will also have an
introduction to other types of parallel systems and parallel programming
models.
:::

::: paragraph
Along the way, you will also learn many other important details about
computer systems, including how they are designed and how they work. You
will learn important themes in systems design and techniques for
evaluating the performance of systems and programs. You'll also master
important skills, including C and assembly programming and debugging.
:::

## Getting Started with This Book {#_getting_started_with_this_book .discrete}

::: paragraph
A few notes about languages, book notation, and recommendations for
getting started reading this book:
:::

### Linux, C, and the GNU Compiler {#_linux_c_and_the_gnu_compiler .discrete}

::: paragraph
We use the C programming language in examples throughout the book. C is
a high-level programming language like Java and Python, but it is less
abstracted from the underlying computer system than many other
high-level languages. As a result, C is the language of choice for
programmers who want more control over how their program executes on the
computer system.
:::

::: paragraph
The code and examples in this book are compiled using the GNU C Compiler
(GCC) and run on the Linux operating system. Although not the most
common mainstream OS, Linux is the dominant OS on supercomputing systems
and is arguably the most commonly used OS by computer scientists.
:::

::: paragraph
Linux is also free and open source, which contributes to its popular use
in these settings. A working knowledge of Linux is an asset to all
students in computing. Similarly, GCC is arguably the most common C
compiler in use today. As a result, we use Linux and GCC in our
examples. However, other Unix systems and compilers have similar
interfaces and functionality.
:::

::: paragraph
In this book, we encourage you to type along with the listed examples.
Linux commands appear in blocks like the following:
:::

::: listingblock
::: content
    $
:::
:::

::: paragraph
The `$` represents the command prompt. If you see a box that looks like
:::

::: listingblock
::: content
    $ uname -a
:::
:::

::: paragraph
this is an indication to type `uname -a` on the command line. Make sure
that you don't type the `$` sign!
:::

::: paragraph
The output of a command is usually shown directly after the command in a
command line listing. As an example, try typing in `uname -a`. The
output of this command varies from system to system. Sample output for a
64-bit system is shown here.
:::

::: listingblock
::: content
    $ uname -a
    Linux Fawkes 4.4.0-171-generic #200-Ubuntu SMP Tue Dec 3 11:04:55 UTC 2019
    x86_64 x86_64 x86_64 GNU/Linux
:::
:::

::: paragraph
The `uname` command prints out information about a particular system.
The `-a` flag prints out all relevant information associated with the
system in the following order:
:::

::: ulist
-   The kernel name of the system (in this case Linux)

-   The hostname of the machine (e.g., Fawkes)

-   The kernel release (e.g., 4.4.0-171-generic)

-   The kernel version (e.g., #200-Ubuntu SMP Tue Dec 3 11:04:55 UTC
    2019)

-   The machine hardware (e.g., x86_64)

-   The type of processor (e.g., x86_64)

-   The hardware platform (e.g., x86_64)

-   The operating system name (e.g., GNU/Linux)
:::

::: paragraph
You can learn more about the `uname` command or any other Linux command
by prefacing the command with `man`, as shown here:
:::

::: listingblock
::: content
    $ man uname
:::
:::

::: paragraph
This command brings up the manual page associated with the `uname`
command. To quit out of this interface, press the `q` key.
:::

::: paragraph
While a detailed coverage of Linux is beyond the scope of this book,
readers can get a good introduction in the online [Appendix 2 - Using
UNIX](Appendix2/index.html). There are also several online resources
that can give readers a good overview. One recommendation is \"The Linux
Command Line\"^1^.
:::

### Other Types of Notation and Callouts {#_other_types_of_notation_and_callouts .discrete}

::: paragraph
Aside from the command line and code snippets, we use several other
types of \"callouts\" to represent content in this book.
:::

::: paragraph
The first is the **aside**. Asides are meant to provide additional
context to the text, usually historical. Here's a sample aside:
:::

::: sidebarblock
::: content
::: title
The origins of Linux, GNU, and the Free Open Source Software (FOSS)
movement
:::

::: paragraph
In 1969, AT&T Bell Labs developed the UNIX operating system for internal
use. Although it was initially written in assembly, it was rewritten in
C in 1973. Due to an antitrust case that barred AT&T Bell Labs from
entering the computing industry, AT&T Bell Labs freely licensed the UNIX
operating system to universities, leading to its widespread adoption. By
1984, however, AT&T separated itself from Bell Labs, and (now free from
its earlier restrictions) began selling UNIX as a commercial product,
much to the anger and dismay of several individuals in academia.
:::

::: paragraph
In direct response, Richard Stallman (then a student at MIT) developed
the GNU (\"GNU is not UNIX\") Project in 1984, with the goal of creating
a UNIX-like system composed entirely of free software. The GNU project
has spawned several successful free software products, including the GNU
C Compiler (GCC), GNU Emacs (a popular development environment), and the
GNU Public License (GPL, the origin of the \"copyleft\" principle).
:::

::: paragraph
In 1992, Linus Torvalds, then a student at the University of Helsinki,
released a UNIX-like operating system that he wrote under the GPL. The
Linux operating system (pronounced \"Lin-nux\" or \"Lee-nux\" as Linus
Torvald's first name is pronounced \"Lee-nus\") was developed using GNU
tools. Today, GNU tools are typically packaged with Linux distributions.
The mascot for the Linux operating system is Tux, a penguin. Torvalds
was apparently bitten by a penguin while visiting the zoo, and chose the
penguin for the mascot of his operating system after developing a
fondness for the creatures, which he dubbed as contracting
\"penguinitis\".
:::
:::
:::

::: paragraph
The second type of callout we use in this text is the **note**. Notes
are used to highlight important information, such as the use of certain
types of notation or suggestions on how to digest certain information. A
sample note is shown below:
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | How to do the readings in this    |
|                                   | book                              |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | As a student, it is important to  |
|                                   | do the readings in the textbook.  |
|                                   | Notice that we say \"do\" the     |
|                                   | readings, not simply \"read\" the |
|                                   | readings. To \"read\" a text      |
|                                   | typically implies passively       |
|                                   | imbibing words off a page. We     |
|                                   | encourage students to take a more |
|                                   | active approach. If you see a     |
|                                   | code example, try typing it in!   |
|                                   | It's OK if you type in something  |
|                                   | wrong, or get errors; that's the  |
|                                   | best way to learn! In computing,  |
|                                   | errors are not failures --- they  |
|                                   | are simply experience.            |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
The last type of callout that students should pay specific attention to
is the **warning**. The authors use warnings to highlight things that
are common \"gotchas\" or a common cause of consternation among our own
students. Although all warnings may not be equally valuable to all
students, we recommend that you review warnings to avoid common pitfalls
whenever possible. A sample warning is shown here:
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | This book contains puns           |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The authors (especially the first |
|                                   | author) are fond of puns and      |
|                                   | musical parodies related to       |
|                                   | computing (and not necessarily    |
|                                   | good ones). Adverse reactions to  |
|                                   | the authors\' sense of humor may  |
|                                   | include (but are not limited to)  |
|                                   | eye-rolling, exasperated sighs,   |
|                                   | and forehead slapping.            |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
If you are ready to get started, please continue on to the first chapter
as we dive into the wonderful world of C. If you already know some C
programming, you may want to start with Chapter 4 on binary
representation, or continue with more advanced C programming in Chapter
2.
:::

::: paragraph
We hope you enjoy your journey with us!
:::

## References {#_references .discrete}

::: {.olist .arabic}
1.  William Shotts. \"The Linux Command Line\", LinuxCommand.org,
    [https://linuxcommand.org/](https://linuxcommand.org/){.bare}
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
