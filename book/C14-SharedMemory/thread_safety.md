
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](multicore.html){.nav-link}
        -   [14.2. POSIX Threads](posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](synchronization.html){.nav-link}
            -   [14.3.1. Mutual Exclusion](mutex.html){.nav-link}
            -   [14.3.2. Semaphores](semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](performance_advanced.html){.nav-link}
        -   [14.5. Cache Coherence](cache_coherence.html){.nav-link}
        -   [14.6. Thread Safety](thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](openmp.html){.nav-link}
        -   [14.8. Summary](summary.html){.nav-link}
        -   [14.9. Exercises](exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [14. Leveraging Shared Memory in the Multicore Era](index.html)
-   [14.6. Thread Safety](thread_safety.html)
:::

::: content
::: sect1
## [](#_thread_safety){.anchor}14.6. Thread Safety {#_thread_safety}

::: sectionbody
::: paragraph
So far, we have covered synchronization constructs that programmers can
use to ensure that their multithreaded programs are consistent and
correct regardless of the number of threads employed. However, it is not
always safe to make the assumption that standard C library functions can
be used \"as is\" in the context of any multithreaded application. Not
all functions in the C library are **thread safe**, or capable of being
run by multiple threads while guaranteeing a correct result without
unintended side effects. To ensure that the programs *we* write are
thread safe, it is important to use [synchronization
primitives](synchronization.html#_synchronizing_threads){.page} like
mutexes and barriers to enforce that multithreaded programs are
consistent and correct regardless of how the number of threads varies.
:::

::: paragraph
Another closely related concept related to thread safety is re-entrancy.
All thread safe code is re-entrant; however, not all re-entrant code is
thread safe. A function is **re-entrant** if it can be
re-executed/partially executed by a function without causing issue. By
definition, re-entrant code ensures that accesses to the global state of
a program always result in that global state remaining consistent. While
re-entrancy is often (incorrectly) used as a synonym for thread safety,
there are special cases for which re-entrant code is not thread safe.
:::

::: paragraph
When writing multithreaded code, verify that the C library functions
used are indeed thread safe. Fortunately, the list of thread unsafe C
library functions is fairly small. The Open Group kindly maintains [a
list of thread-unsafe
functions](http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_09.html).
:::

::: sect2
### [](#_fixing_issues_of_thread_safety){.anchor}14.6.1. Fixing Issues of Thread Safety {#_fixing_issues_of_thread_safety}

::: paragraph
[Synchronization
primitives](synchronization.html#_synchronizing_threads){.page} are the
most common way to fix issues related to thread safety. However,
unknowingly using thread-unsafe C library functions can cause subtle
issues. Let's look at a slightly modified version of our `countsElem`
function called `countElemsStr`, which attempts to count the frequency
of digits in a given string, where each digit is separated by spaces.
The following program has been edited for brevity; the full source of
this program is available at:
[countElemsStr.c](_attachments/countElemsStr.c).
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
/* computes the frequency of all the elements in the input string and stores
 * the associated counts of each element in the array called counts. */
void countElemsStr(int *counts, char *input_str) {
    int val, i;
    char *token;
    token = strtok(input_str, " ");
    while (token != NULL) {
        val = atoi(token);
        counts[val] = counts[val] + 1;
        token = strtok(NULL, " ");
    }
}

/* main function:
 * calls countElemsStr on a static string and counts up all the digits in
 * that string. */
int main( int argc, char **argv ) {
    //lines omitted for brevity, but gets user defined length of string

    //fill string with n digits
    char *inputString = calloc(length * 2, sizeof(char));
    fillString(inputString, length * 2);

    countElemsStr(counts, inputString);

    return 0;
}
```
:::
:::

::: paragraph
The `countElemsStr` function uses the `strtok` function (as examined in
our [discussion on
strings](../C2-C_depth/strings.html#_strtok_strtok_r){.page}) to parse
each digit (stored in `token`) in the string, before converting it to an
integer and making the associated updates in the `counts` array.
:::

::: paragraph
Compiling and running this program on 100,000 elements yields the
following output:
:::

::: listingblock
::: content
    $ gcc -o countElemsStr countElemsStr.c

    $ ./countElemsStr 100000 1
    contents of counts array:
    9963 9975 9953 10121 10058 10017 10053 9905 9915 10040
:::
:::

::: paragraph
Now, let's take a look at a multithreaded version of `countElemsStr`
(full source of the program viewable
[here](_attachments/countElemsStr_p.c)):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
/* parallel version of countElemsStr (First cut):
 * computes the frequency of all the elements in the input string and stores
 * the associated counts of each element in the array called counts
*/
void *countElemsStr(void *args) {
    //parse args
    struct t_arg *myargs = (struct t_arg *)args;
    //omitted for brevity

    //local variables
    int val, i;
    char *token;
    int local_counts[MAX] = {0};

    //compute local start and end values and chunk size:
    //omitted for brevity

    //tokenize values
    token = strtok(input_str + start, " ");
    while (token != NULL) {
        val = atoi(token); //convert to an int
        local_counts[val] = local_counts[val] + 1; //update associated counts
        token = strtok(NULL, " ");
    }

    pthread_mutex_lock(&mutex);
    for (i = 0; i < MAX; i++) {
        counts[i] += local_counts[i];
    }
    pthread_mutex_unlock(&mutex);

    return NULL;
}
```
:::
:::

::: paragraph
In this version of the program, each thread processes a separate section
of the string referenced by `input_str`. The `local_counts` array
ensures that the bulk of the write operations occur to local storage. A
mutex is employed to ensure that no two threads write to the shared
variable `counts`.
:::

::: paragraph
However, compiling and running this program yields the following
results:
:::

::: listingblock
::: content
    $ gcc -o countElemsStr_p countElemsStr_p.c -pthread

    $ ./countElemsStr_p 100000 1 1
    contents of counts array:
    9963 9975 9953 10121 10058 10017 10053 9905 9915 10040

    $ ./countElemsStr_p 100000 1 2
    contents of counts array:
    498 459 456 450 456 471 446 462 450 463

    $ ./countElemsStr_p 100000 1 4
    contents of counts array:
    5038 4988 4985 5042 5056 5013 5025 5035 4968 5065
:::
:::

::: paragraph
Even though mutex locks are used around accesses to the `counts` array,
the results from separate runs are radically different. This issue
arises because the `countsElemsStr` function is not thread safe, because
the string library function `strtok` is *not thread safe*! Visiting the
[OpenGroup](http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_09.html)
website confirms that `strtok` is on the list of thread-unsafe
functions.
:::

::: paragraph
To fix this issue, it suffices to replace `strtok` with its thread-safe
alternative, `strtok_r`. In the latter function, a pointer is used as
the last parameter to help the thread keep track of where in the string
it is parsing. Here is the fixed function with `strtok_r` (full source
code here ([countsElemsStr_p\_v2.c](_attachments/countElemsStr_p_v2.c)):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
/* parallel version of countElemsStr (First cut):
 * computes the frequency of all the elements in the input string and stores
 * the associated counts of each element in the array called counts */
void* countElemsStr(void* args) {
    //parse arguments
    //omitted for brevity

    //local variables
    int val, i;
    char * token;
    int local_counts[MAX] = {0};
    char * saveptr; //for saving state of strtok_r

    //compute local start and end values and chunk size:
    //omitted for brevity

    //tokenize values
    token = strtok_r(input_str+start, " ", &saveptr);
    while (token != NULL) {
        val = atoi(token); //convert to an int
        local_counts[val] = local_counts[val]+1; //update associated counts
        token = strtok_r(NULL, " ", &saveptr);
    }

    pthread_mutex_lock(&mutex);
    for (i = 0; i < MAX; i++) {
        counts[i]+=local_counts[i];
    }
    pthread_mutex_unlock(&mutex);

    return NULL;
}
```
:::
:::

::: paragraph
The only change in this version of the code is the declaration of the
character pointer `saveptr` and replacing all instances of `strtok` with
`strtok_r`. Rerunning the code with these changes yields the following
output:
:::

::: listingblock
::: content
    $ gcc -o countElemsStr_p_v2 countElemsStr_p_v2.c -pthread

    $ ./countElemsStr_p_v2 100000 1 1
    contents of counts array:
    9963 9975 9953 10121 10058 10017 10053 9905 9915 10040

    $ ./countElemsStr_p_v2 100000 1 2
    contents of counts array:
    9963 9975 9953 10121 10058 10017 10053 9905 9915 10040

    $ ./countElemsStr_p_v2 100000 1 4
    contents of counts array:
    9963 9975 9953 10121 10058 10017 10053 9905 9915 10040
:::
:::

::: paragraph
Now the program produces the same result for every run. The use of
`saveptr` in conjunction with `strtok_r` ensures that each thread can
independently track their location when parsing the string.
:::

::: paragraph
The takeaway from this section is that one should always check [the list
of thread-unsafe functions in
C](http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_09.html)
when writing multithreaded applications. Doing so can save the
programmer a lot of heartache and frustration when writing and debugging
threaded applications.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
