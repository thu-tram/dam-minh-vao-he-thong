
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](input_output.html){.nav-link}
        -   [16.3. Conditionals and Loops](conditionals.html){.nav-link}
        -   [16.4. Functions](functions.html){.nav-link}
        -   [16.5. Arrays and Strings](arrays_strings.html){.nav-link}
        -   [16.6. Structs](structs.html){.nav-link}
        -   [16.7. Summary](summary.html){.nav-link}
        -   [16.8. Exercises](exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [16. Appendix 1: Chapter 1 for Java Programmers](index.html)
-   [16.2. Input/Output (printf and scanf)](input_output.html)
:::

::: content
::: sect1
## [](#_inputoutput_printf_and_scanf){.anchor}16.2. Input/Output (printf and scanf) {#_inputoutput_printf_and_scanf}

::: sectionbody
::: paragraph
C's `printf` function prints values to the terminal, and the `scanf`
function reads in values entered by a user. The `printf` and `scanf`
functions belong to C's standard I/O library, which needs to be
explicitly included at the top of any `.c` file that uses these
functions by using `#include <stdio.h>`. In this section, we introduce
the basics of using `printf` and `scanf` in C programs. The [\"I/O\"
section in Chapter 2](../C2-C_depth/IO.html#_io_in_c){.page} discusses
C's input and output functions in more detail.
:::

::: sect2
### [](#_printf){.anchor}16.2.1. printf {#_printf}

::: paragraph
C's `printf` function is very similar to the `System.out.printf` method
in Java, where the caller specifies a format string to print. The format
string often contains formatting specifiers, such as special characters
that will print tabs (`\t`) or newlines (`\n`), or placeholders for
values in the output. Placeholders consist of `%` followed by a type
specifier letter (for example, `%d` represents a placeholder for an
integer value). For each placeholder in the format string, `printf`
expects an additional argument. [Table 1](#TabCSyntaxPrinting) contains
an example program in Java and C with formatted output:
:::

+--------------------------------------+-------------------------------+
| Java version                         | C version                     |
+======================================+===============================+
| ::: content                          | ::: content                   |
| ::: listingblock                     | ::: listingblock              |
| ::: content                          | ::: content                   |
| ``` {.highlightjs .highlight}        | ``` {.highlightjs .highlight} |
| /* Java formatted print example */   | /* C printf example */        |
|                                      |                               |
| class PrintfExample {                | #in                           |
|                                      | clude <stdio.h> // for printf |
|  pub                                 |                               |
| lic static void main(String[] args){ | int main(void) {              |
|                                      |                               |
|   Sy                                 |   printf("Name: %s, Info:\n", |
| stem.out.printf("Name: %s, Info:\n", |          "Vijay");            |
|                     "Vijay");        |   p                           |
|   Syste                              | rintf("\tAge: %d\t Ht: %g\n", |
| m.out.printf("\tAge: %d\t Ht: %g\n", |          20, 5.9);            |
|                     20, 5.9);        |   pr                          |
|   System                             | intf("\tYr: %d\t Dorm: %s\n", |
| .out.printf("\tYr: %d\t Dorm: %s\n", |          3, "Alice Paul");    |
|                                      |                               |
|                    3, "Alice Paul"); |   return 0;                   |
|  }                                   | }                             |
|                                      | ```                           |
| }                                    | :::                           |
| ```                                  | :::                           |
| :::                                  | :::                           |
| :::                                  |                               |
| :::                                  |                               |
+--------------------------------------+-------------------------------+

: Table 1. Syntax Comparison of Printing in Java and C

::: paragraph
When run, both versions of this program produce identically formatted
output:
:::

::: listingblock
::: content
    Name: Vijay,  Info:
        Age: 20      Ht: 5.9
        Year: 3      Dorm: Alice Paul
:::
:::

::: paragraph
C uses the same formatting placeholders as Java for specifying different
types of values. The preceding example demonstrates the following
formatting placeholders:
:::

::: listingblock
::: content
    %g:  placeholder for a float (or double) value
    %d:  placeholder for a decimal value (int, short, char)
    %s:  placeholder for a string value
    %c:  placeholder for a char value
:::
:::

::: paragraph
The `%c` placeholder is useful when a programmer wants to print the
ASCII character associated with a particular numeric encoding. Here's a
C code snippet that prints a `char` as its numeric value (`%d`) and as
its character encoding (`%c`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// Example printing a char value as its decimal representation (%d)
// and as the ASCII character that its value encodes (%c)

char ch;

ch = 'A';
printf("ch value is %d which is the ASCII value of  %c\n", ch, ch);

ch = 99;
printf("ch value is %d which is the ASCII value of  %c\n", ch, ch);
```
:::
:::

::: paragraph
When run, the program's output looks like this:
:::

::: listingblock
::: content
    ch value is 65 which is the ASCII value of  A
    ch value is 99 which is the ASCII value of  c
:::
:::
:::

::: sect2
### [](#_scanf){.anchor}16.2.2. scanf {#_scanf}

::: paragraph
C's `scanf` function represents one method for reading in values entered
by the user (via the keyboard) and storing them in program variables.
The `scanf` function can be a bit picky about the exact format in which
the user enters data, which means that it's not very robust to badly
formed user input. In the [\"I/O\" section in Chapter
2](../C2-C_depth/IO.html#_io_in_c){.page}, we discuss more robust ways
of reading input values from the user. For now, remember that if your
program gets into an infinite loop due to badly formed user input, you
can always press **CTRL-C** to terminate it.
:::

::: paragraph
Reading input is handled differently in Java and C: Java creates a new
`Scanner` object and uses its methods to read in and return values of
different types, whereas C uses `scanf` to read in values of different
types, specified by a format string argument, and store them at the
memory locations of program variables (for example, `&num1`). [Table
2](#TabInputJavaComparison) displays example programs for reading user
input values in Java and C:
:::

+--------------------------------------+-------------------------------+
| Java version                         | C version                     |
+======================================+===============================+
| ::: content                          | ::: content                   |
| ::: listingblock                     | ::: listingblock              |
| ::: content                          | ::: content                   |
| ``` {.highlightjs .highlight}        | ``` {.highlightjs .highlight} |
| /* Java input example */             | /* C input (scanf) example */ |
|                                      |                               |
| import java.util.Scanner;            | #include <stdio.h>            |
|                                      |                               |
| class InputExample {                 |                               |
|                                      |                               |
|   publ                               | int main(void) {              |
| ic static void main(String[] args) { |                               |
|                                      |   int num1, num2;             |
|     int num1, num2;                  |                               |
|                                      |                               |
| Scanner in = new Scanner(System.in); |   printf("Enter a number: "); |
|                                      |   scanf("%d", &num1);         |
|     S                                |   printf("Enter another: ");  |
| ystem.out.print("Enter a number: "); |   scanf("%d", &num2);         |
|     num1 = in.nextInt();             |                               |
|                                      |   printf("%d + %d = %d\n",    |
| System.out.print("Enter another: "); |                               |
|     num2 = in.nextInt();             |    num1, num2, (num1+num2) ); |
|                                      |                               |
|                                      |   return 0;                   |
| System.out.printf( "%d + %d = %d\n", | }                             |
|           num1, num2, (num1+num2) ); | ```                           |
|   }                                  | :::                           |
|                                      | :::                           |
| }                                    | :::                           |
| ```                                  |                               |
| :::                                  |                               |
| :::                                  |                               |
| :::                                  |                               |
+--------------------------------------+-------------------------------+

: Table 2. Comparison of Methods for Reading Input Values in Java and C

::: paragraph
When run, both programs read in two values (here, 30 and 67):
:::

::: listingblock
::: content
    Enter a number: 30
    Enter another: 67
    30 + 67 = 97
:::
:::

::: paragraph
Like `printf`, `scanf` takes a format string that specifies the number
and types of values to read in (for example, `"%d"` specifies one `int`
value). The `scanf` function skips over leading and trailing whitespace
as it reads in a numeric value, so its format string only needs to
contain a sequence of formatting placeholders, usually with no
whitespace or other formatting characters between the placeholders in
its format string. The arguments for the placeholders in the format
string specify the *locations* of program variables into which the
values read in will be stored. Prefixing the name of a variable with the
`&` operator produces the location of that variable in the program's
memory --- the memory address of the variable. The [\"Pointers\" section
in Chapter 2](../C2-C_depth/pointers.html#_cs_pointer_variables){.page}
discusses the `&` operator in more detail. For now, we use it only in
the context of the `scanf` function.
:::

::: paragraph
Here's another `scanf` example, in which the format string has
placeholders for two values, the first an `int` and the second a
`float`:
:::

::: listingblock
::: title
scanf_ex.c
:::

::: content
``` {.highlightjs .highlight}
int x;
float pi;

// read in an int value followed by a float value ("%d%g")
// store the int value at the memory location of x (&x)
// store the float value at the memory location of pi (&pi)
scanf("%d%g", &x, &pi);
```
:::
:::

::: paragraph
When inputting data to a program via `scanf`, individual numeric input
values must be separated by at least one whitespace character. However,
because `scanf` skips over additional leading and trailing whitespace
characters (for example, spaces, tabs, and newlines), a user could enter
input values with any amount of space before or after each input value.
For instance, if a user enters the following for the call to `scanf` in
the preceding example, `scanf` will read in 8 and store it in the `x`
variable, and then read in 3.14 and store it in the `pi` variable:
:::

::: listingblock
::: content
              8                   3.14
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
