
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](input_output.html){.nav-link}
        -   [16.3. Conditionals and Loops](conditionals.html){.nav-link}
        -   [16.4. Functions](functions.html){.nav-link}
        -   [16.5. Arrays and Strings](arrays_strings.html){.nav-link}
        -   [16.6. Structs](structs.html){.nav-link}
        -   [16.7. Summary](summary.html){.nav-link}
        -   [16.8. Exercises](exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [16. Appendix 1: Chapter 1 for Java Programmers](index.html)
-   [16.1. Getting Started Programming in C](getting_started.html)
:::

::: content
::: sect1
## [](#_getting_started_programming_in_c){.anchor}16.1. Getting Started Programming in C {#_getting_started_programming_in_c}

::: sectionbody
::: paragraph
Let's start by looking at a \"hello world\" program that includes an
example of calling a function from the math library. In [Table
1](#TabJavaC) we compare the C version of this program to the Java
version. The C version might be put in a file named `hello.c` (`.c` is
the suffix convention for C source code files), whereas the Java version
might be in a file named `HelloWorld.java`.
:::

+-----------------------------------+-----------------------------------+
| Java version                      | C version                         |
| ([HelloWorld.jav                  | ([h                               |
| a](_attachments/HelloWorld.java)) | ello.c](_attachments/hello.html)) |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| /*                                | /*                                |
|                                   |     The Hello World Program in C  |
|   The Hello World Program in Java |  */                               |
|  */                               |                                   |
|                                   | /* C math and I/O libraries */    |
| /* Java Math library */           | #include <math.h>                 |
| import java.lang.Math;            | #include <stdio.h>                |
|                                   |                                   |
| /* define a HelloWorld class */   |                                   |
| class HelloWorld {                |                                   |
|                                   | /* main function definition: */   |
|   /* main method definition: */   | int main(void) {                  |
|   public                          |                                   |
|  static void main(String[] args){ |     printf("Hello World\n");      |
|                                   |     pr                            |
|    S                              | intf("sqrt(4) is %f\n", sqrt(4)); |
| ystem.out.println("Hello World"); |                                   |
|                                   |     r                             |
|  System.out.println("sqrt(4) is " | eturn 0;  // main returns value 0 |
|          + Math.sqrt(4));         | }                                 |
|   }                               | ```                               |
| }                                 | :::                               |
| ```                               | :::                               |
| :::                               | :::                               |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 1. Syntax Comparison of a Small Program in Java and C. Both the
[C version](_attachments/hello.html) and [Java
version](_attachments/HelloWorld.java) are available for download.

::: paragraph
Notice that both versions of this program have similar structure and
language constructs, albeit with different language syntax.
:::

::: paragraph
A few syntactic similarities include:
:::

::: paragraph
**Comments:**
:::

::: ulist
-   Multi-line comments in Java and C begin with `/*` and end with `*/`,
    and single-line comments begin with `//`.
:::

::: paragraph
**Statements:**
:::

::: ulist
-   Statements in C and Java end in `;`.
:::

::: paragraph
**Blocks:**
:::

::: ulist
-   Both Java and C use `{` and `}` around blocks of related code (for
    example, function bodies and loop bodies). Good programming style
    includes indenting statements inside a block.
:::

::: paragraph
A few key differences include:
:::

::: paragraph
**Importing library code:**
:::

::: ulist
-   In Java, libraries are included (imported) using `import`.

-   In C, libraries are included (imported) using `#include`. All
    `#include` statements appear at the top of the program, outside of
    function bodies.
:::

::: paragraph
**The main function:**
:::

::: ulist
-   Both Java and C define `main` functions that are the first functions
    executed when a program is run. In C, there is only one `main`
    function defined, and it is automatically called when the C program
    executes. In Java, the `public static void main` method of the class
    run on the JVM is executed.

-   Java is a purely object oriented language, thus all code must be
    part of a class (`HelloWorld` in this example). The `main` function
    is defined as a `public static` method in the class `HelloWorld`
    (`public static void main(String[] args)`). By convention `main` is
    a `void` function in Java and is passed an array of command line
    argument strings.

-   C is a purely imperative and procedural language, and thus there are
    no classes in C. As a result, all functions are defined outside of
    class definitions (there are no class definitions in C). In C,
    `int main(void){ }` defines the main function. The `void` means it
    doesn't expect to receive a parameter. Future sections show how
    `main` can take parameters to receive command line arguments.

-   A C program must have a function named `main`, and its return type
    must be `int`. The `main` function in C can optionally take a
    parameter that is a list of strings, one per command line argument
    (similar to Java), but in its simplest form, `main` has no
    parameters. In Chapter 2 we show `main` defined to take command line
    arguments.

-   The C `main` function has an explicit `return` statement to return
    an `int` value (by convention, `main` returns `0` if the main
    function is successfully executed without errors).
:::

::: paragraph
**Output:**
:::

::: ulist
-   In Java, the `print` and `println` methods of `System.out` can be
    used to print a string. The `+` operator can be used to concatenate
    values together to create a more complex string (for example,
    `"sqrt(4) is " + Math.sqrt(4)`). `System.out` also has a `printf`
    method to print out a format string with arguments. Values for the
    placeholders in the format string follow as a comma-separated list
    of argument values. For example, the second call to
    `System.out.println` in [Table 1](#TabJavaC) could be replaced with
    the equivalent call
    `System.out.printf("sqrt(4) is %f%n", Math.sqrt(4)`), where the
    value of `Math.sqrt(4)` will be printed in place of the `%f`
    placeholder in the format string and `%n` (or `\n`) is used to
    specify a newline character. Java additionally has classes that can
    be used to format different types of values.

-   In C, the `printf` function prints a formatted string like Java's
    `System.out.printf` method (for example, the value of `sqrt(4)` will
    be printed in place of the `%f` placeholder in the format string
    argument, and `\n` specifies a newline character).

    ::: paragraph
    The `printf` function is used to print both format strings and
    simple string values (C does not have an separate function similar
    to Java's `System.out.println`). C's `printf` function also doesn't
    automatically print a newline character at the end. As a result, C
    programmers need to explicitly specify a newline character (`\n`) in
    the format string when a newline is desired in the output.
    :::
:::

::: sect2
### [](#_compiling_and_running_c_programs){.anchor}16.1.1. Compiling and Running C Programs {#_compiling_and_running_c_programs}

::: paragraph
Java programs run on the Java virtual machine (JVM). The JVM is a
program that runs directly on the underlying computer system. To run a
Java program, it is first compiled (translated) by the Java compiler
(`javac`) from its source code (`HelloWorld.java`) form into Java
bytecode form. For example (`$` is the Linux shell prompt):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ javac HelloWorld.java
```
:::
:::

::: paragraph
If successful, `javac` creates a new file, `HelloWorld.class`, that
contains the Java bytecode translation of the program that the JVM can
run. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ java HelloWorld
```
:::
:::

::: paragraph
The JVM is a program that is in a form that can be run directly on the
underlying system (this form is called **binary executable**) and takes
as input the Java class that it runs ([Figure 1](#FigJavaExecution)).
Java bytecode is very portable in the sense that it can run on any
computer system with a JVM. However, because Java bytecode does not run
directly on the underlying computer system, a Java program may not run
as efficiently as programs that run directly on the underlying system.
:::

::: {#FigJavaExecution .imageblock .text-center}
::: content
![Execution of a Java program by the
JVM.](_images/javac.png){width="600"}
:::

::: title
Figure 1. A Java program is compiled to Java bytecode that is executed
by the JVM, which is a binary executable program that is run on the
underlying system (OS and hardware)
:::
:::

::: paragraph
To run a C program, it must first be translated into a form that a
computer system can directly execute. The C **compiler**, similar to the
Java compiler, is a program that translates C source code into a
**binary executable** form that the computer system can directly
execute. A binary executable consists of a series of 0's and 1's in a
well-defined format that a computer can run; unlike Java bytecode that
requires the JVM to run, the binary executable runs directly on the
underlying system.
:::

::: paragraph
For example, to run the C program `hello.c` on a Unix system, the C code
must first be compiled by a C compiler (for example, the [GNU C
compiler](https://gcc.gnu.org/), GCC) that produces a binary executable
(by default named `a.out`). The binary executable version of the program
can then be run directly on the system ([Figure 2](#FigCCompile)):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc hello.c
$ ./a.out
```
:::
:::

::: paragraph
(Note that some C compilers might need to be explicitly told to link in
the math library: `-lm`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc hello.c -lm
```
:::
:::

::: {#FigCCompile .imageblock .text-center}
::: content
![C program text goes to the C compiler, which converts it into an
executable sequence of zeroes and ones. The format of the executable
sequence can be run by the underlying
system.](_images/compile.png){width="550"}
:::

::: title
Figure 2. The C compiler (gcc) builds C source code into a binary
executable file (a.out). The underlying system (OS and hardware)
directly executes the a.out file to run the program.
:::
:::

::: sect3
#### [](#_detailed_steps){.anchor}Detailed Steps {#_detailed_steps}

::: paragraph
In general, the following sequence describes the necessary steps for
editing, compiling, and running a C program on a Unix system:
:::

::: {.olist .arabic}
1.  Using a [text
    editor](https://www.cs.swarthmore.edu/help/editors.html) (for
    example, `vim`), write and save your C source code program in a file
    (e.g., `hello.c`):

    ::: listingblock
    ::: content
        $ vim hello.c
    :::
    :::

2.  Compile the source to an executable form, and then run it. The most
    basic syntax for compiling with `gcc` is:

    ::: listingblock
    ::: content
        $ gcc <input_source_file>
    :::
    :::
:::

::: paragraph
If compilation yields no errors, the compiler creates a binary
executable file named `a.out`. The compiler also allows you to specify
the name of the binary executable file to generate using the `-o` flag:
:::

::: listingblock
::: content
    $ gcc -o <output_executable_file> <input_source_file>
:::
:::

::: paragraph
For example, this command instructs `gcc` to compile `hello.c` into an
executable file named `hello`:
:::

::: listingblock
::: content
    $ gcc -o hello hello.c
:::
:::

::: paragraph
We can invoke the executable program using `./hello`:
:::

::: listingblock
::: content
    $ ./hello
:::
:::

::: paragraph
Any changes made to the C source code (the `hello.c` file) must be
recompiled with `gcc` to produce a new version of `hello`. If the
compiler detects any errors during compilation, the `./hello` file won't
be created/re-created (but beware, an older version of the file from a
previous successful compilation might still exist).
:::

::: paragraph
Often when compiling with `gcc`, you want to include several command
line options. For example, these options enable more compiler warnings
and build a binary executable with extra debugging information:
:::

::: listingblock
::: content
    $ gcc -Wall -g -o hello hello.c
:::
:::

::: paragraph
Because the `gcc` command line can be long, frequently the `make`
utility is used to simplify compiling C programs and for cleaning up
files created by `gcc`. [Using make and writing
Makefiles](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)
are important skills that you will develop as you build up experience
with C programming.
:::

::: paragraph
We cover compiling and linking with C library code in more detail at the
end of [Chapter
2](../C2-C_depth/advanced_libraries.html#_compilation_steps_){.page}.
:::
:::
:::

::: sect2
### [](#_variables_and_c_numeric_types){.anchor}16.1.2. Variables and C Numeric Types {#_variables_and_c_numeric_types}

::: paragraph
Like Java, C uses variables as named storage locations for holding data.
Thinking about the **scope** and **type** of program variables is
important to understand the semantics of what your program will do when
you run it. A variable's **scope** defines when the variable has meaning
(that is, where and when in your program it can be used) and its
lifetime (that is, it could persist for the entire run of a program or
only during a function activation). A variable's **type** defines the
range of values that it can represent and how those values will be
interpreted when performing operations on its data.
:::

::: paragraph
In both Java and C, all variables must be declared before they can be
used. To declare a variable in C, use the following syntax:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
type_name variable_name;
```
:::
:::

::: paragraph
A variable can have only a single **type**. The basic C types include
`char`, `int`, `float`, and `double`. By convention, C variables should
be declared at the beginning of their scope (at the top of a `{ }`
block), before any C statements in that scope.
:::

::: paragraph
Below is an example C code snippet that shows declarations and uses of
variables of some different types. We discuss types and operators in
more detail after the example.
:::

::: {#varsinc .listingblock}
::: title
varsin.c
:::

::: content
``` {.highlightjs .highlight}
{
    /* 1. Define variables in this block's scope at the top of the block. */

    int x; // declares x to be an int type variable and allocates space for it

    int i, j, k;  // can define multiple variables of the same type like this

    char letter;  // a char stores a single-byte integer value
                  // it is often used to store a single ASCII character
                  // value (the ASCII numeric encoding of a character)
                  // a char in C is a different type than a string in C

    float winpct; // winpct is declared to be a float type
    double pi;    // the double type is more precise than float

    /* 2. After defining all variables, you can use them in C statements. */

    x = 7;        // x stores 7 (initialize variables before using their value)
    k = x + 2;    // use x's value in an expression

    letter = 'A';        // a single quote is used for single character value
    letter = letter + 1; // letter stores 'B' (ASCII value one more than 'A')

    pi = 3.1415926;

    winpct = 11 / 2.0; // winpct gets 5.5, winpct is a float type
    j = 11 / 2;        // j gets 5: int division truncates after the decimal
    x = k % 2;         // % is C's mod operator, so x gets 9 mod 2 (1)
}
```
:::
:::
:::

::: sect2
### [](#_c_types){.anchor}16.1.3. C Types {#_c_types}

::: paragraph
Unlike Java, C does not have an extensive set of class libraries
defining complex data types. Instead, C supports a small set of built-in
data types, and it provides a few ways in which programmers can
construct basic collections of types (arrays and structs). From these
basic building blocks, a C programmer can build complex data structures.
:::

::: paragraph
C defines a set of basic types for storing numeric values. Here are some
examples of numeric literal values of different C types:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
8     // the int value 8
3.4   // the double value 3.4
'h'   // the char value 'h' (its value is 104, the ASCII value of h)
```
:::
:::

::: paragraph
The C `char` type stores a numeric value. However, it's often used by
programmers to store the value of an ASCII character. A character
literal value is specified in C as a single character between single
quotes.
:::

::: paragraph
C doesn't support a string type, but programmers can create strings from
the `char` type and C's support for constructing arrays of values, which
we discuss in later sections. C does, however, support a way of
expressing string literal values in programs: a string literal is any
sequence of characters between double quotes. C programmers often pass
string literals as the format string argument to `printf`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("this is a C string\n");
```
:::
:::

::: paragraph
Java and C both support string and char type values. Typically, Java
char values are 16-bit unicode values and C's are 8-bit ascii values.
:::

::: paragraph
In both Java and C a string and a `char` are two very different types,
and they evaluate differently. This difference is illustrated by
contrasting a C string literal that contains one character with a C
`char` literal. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
'h'  // this is a char literal value   (its value is 104, the ASCII value of h)
"h"  // this is a string literal value (its value is NOT 104, it is not a char)
```
:::
:::

::: paragraph
We discuss C strings and `char` variables in more detail in the
[Strings](../C2-C_depth/strings.html#_strings_and_the_string_library){.page}
section later in this chapter. Here, we'll mainly focus on C's numeric
types.
:::

::: sect3
#### [](#_c_numeric_types){.anchor}C Numeric Types {#_c_numeric_types}

::: paragraph
C supports several different types for storing numeric values. The types
differ in the format of the numeric values they represent. For example,
the `float` and `double` types can represent real values, `int`
represents signed integer values, and `unsigned int` represents unsigned
integer values. Real values are positive or negative values with a
decimal point, such as `-1.23` or `0.0056`. Signed integers store
positive, negative, or zero integer values, such as `-333`, `0`, or
`3456`. Unsigned integers store strictly nonnegative integer values,
such as `0` or `1234`.
:::

::: paragraph
C's numeric types also differ in the range and precision of the values
they can represent. The range or precision of a value depends on the
number of bytes associated with its type. Types with more bytes can
represent a larger range of values (for integer types), or
higher-precision values (for real types), than types with fewer bytes.
:::

::: paragraph
[Table 2](#TabNumericCTypes) shows the number of storage bytes, the kind
of numeric values stored, and how to declare a variable for a variety of
common C numeric types (note that these are typical sizes --- the exact
number of bytes depends on the hardware architecture).
:::

+-----------------+-----------------+-----------------+-----------------+
| Type name       | Usual size      | Values stored   | How to declare  |
+=================+=================+=================+=================+
| `char`          | 1 byte          | integers        | `char x;`       |
+-----------------+-----------------+-----------------+-----------------+
| `short`         | 2 bytes         | signed integers | `short x;`      |
+-----------------+-----------------+-----------------+-----------------+
| `int`           | 4 bytes         | signed integers | `int x;`        |
+-----------------+-----------------+-----------------+-----------------+
| `long`          | 4 or 8 bytes    | signed integers | `long x;`       |
+-----------------+-----------------+-----------------+-----------------+
| `long long`     | 8 bytes         | signed integers | `long long x;`  |
+-----------------+-----------------+-----------------+-----------------+
| `float`         | 4 bytes         | signed real     | `float x;`      |
|                 |                 | numbers         |                 |
+-----------------+-----------------+-----------------+-----------------+
| `double`        | 8 bytes         | signed real     | `double x;`     |
|                 |                 | numbers         |                 |
+-----------------+-----------------+-----------------+-----------------+

: Table 2. C Numeric Types

::: paragraph
C also provides *unsigned* versions of the integer numeric types
(`char`, `short`, `int`, `long`, and `long long`). To declare a variable
as unsigned, add the keyword `unsigned` before the type name. For
example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x;           // x is a signed int variable
unsigned int y;  // y is an unsigned int variable
```
:::
:::

::: paragraph
The C standard doesn't specify whether the `char` type is signed or
unsigned. As a result, some implementations might implement `char` as
signed integer values and others as unsigned. It's good programming
practice to explicitly declare `unsigned char` if you want to use the
unsigned version of a `char` variable.
:::

::: paragraph
The exact number of bytes for each of the C types might vary from one
architecture to the next. The sizes in [Table 2](#TabNumericCTypes) are
minimum (and common) sizes for each type. You can print the exact size
on a given machine using C's `sizeof` operator, which takes the name of
a type as an argument and evaluates to the number of bytes used to store
that type. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("number of bytes in an int: %lu\n", sizeof(int));
printf("number of bytes in a short: %lu\n", sizeof(short));
```
:::
:::

::: paragraph
The `sizeof` operator evaluates to an unsigned long value, so in the
call to `printf`, use the placeholder `%lu` to print its value. On most
architectures the output of these statements will be:
:::

::: listingblock
::: content
    number of bytes in an int: 4
    number of bytes in a short: 2
:::
:::
:::

::: sect3
#### [](#_arithmetic_operators){.anchor}Arithmetic Operators {#_arithmetic_operators}

::: paragraph
Arithmetic operators combine values of numeric types. The resulting type
of the operation is based on the types of the operands. For example, if
two `int` values are combined with an arithmetic operator, the resulting
type is also an integer.
:::

::: paragraph
C performs automatic type conversion when an operator combines operands
of two different types. For example, if an `int` operand is combined
with a `float` operand, the integer operand is first converted to its
floating-point equivalent before the operator is applied, and the type
of the operation's result is `float`.
:::

::: paragraph
The following arithmetic operators can be used on most numeric type
operands:
:::

::: ulist
-   add (`+`) and subtract (`-`)

-   multiply (`*`), divide (`/`), and mod (`%`):

    ::: paragraph
    The mod operator (`%`) can only take integer-type operands (`int`,
    `unsigned int`, `short`, and so on).
    :::

    ::: paragraph
    If both operands are `int` types, the divide operator (`/`) performs
    integer division (the resulting value is an `int`, truncating
    anything beyond the decimal point from the division operation). For
    example `8/3` evaluates to `2`.
    :::

    ::: paragraph
    If one or both of the operands are `float` (or `double`), `/`
    performs real division and evaluates to a `float` (or `double`)
    result. For example, `8 / 3.0` evaluates to approximately
    `2.666667`.
    :::

-   assignment (`=`):

    ::: listingblock
    ::: content
        variable = value of expression;  // e.g., x = 3 + 4;
    :::
    :::

-   assignment with update (`+=`, `-=`, `*=`, `/=`, and `%=`):

    ::: listingblock
    ::: content
        variable op= expression;  // e.g., x += 3; is shorthand for x = x + 3;
    :::
    :::
:::

::: ulist
-   increment (`++`) and decrement (`--`):

    ::: listingblock
    ::: content
        variable++;  // e.g., x++; assigns to x the value of x + 1
    :::
    :::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Pre- vs. Post-increment           |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The operators `++variable` and    |
|                                   | `variable++` are both valid, but  |
|                                   | they're evaluated slightly        |
|                                   | differently:                      |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: ulist                         |
|                                   | -   `++x`: increment `x` first,   |
|                                   |     then use its value.           |
|                                   |                                   |
|                                   | -   `x++`: use \`x's value first, |
|                                   |     then increment it.            |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In many cases, it doesn't matter  |
|                                   | which you use because the value   |
|                                   | of the incremented or decremented |
|                                   | variable isn't being used in the  |
|                                   | statement. For example, these two |
|                                   | statements are equivalent         |
|                                   | (although the first is the most   |
|                                   | commonly used syntax for this     |
|                                   | statement):                       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | x++;                              |
|                                   | ++x;                              |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In some cases, the context        |
|                                   | affects the outcome (when the     |
|                                   | value of the incremented or       |
|                                   | decremented variable *is* being   |
|                                   | used in the statement). For       |
|                                   | example:                          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | x = 6;                            |
|                                   | y = ++x +                         |
|                                   | 2;  // y is assigned 9: increment |
|                                   |  x first, then evaluate x + 2 (9) |
|                                   |                                   |
|                                   | x = 6;                            |
|                                   | y = x++ +                         |
|                                   | 2;  // y is assigned 8: evaluate  |
|                                   | x + 2 first (8), then increment x |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Code like the preceding example   |
|                                   | that uses an arithmetic           |
|                                   | expression with an increment      |
|                                   | operator is often hard to read,   |
|                                   | and it's easy to get wrong. As a  |
|                                   | result, it's generally best to    |
|                                   | avoid writing code like this;     |
|                                   | instead, write separate           |
|                                   | statements for exactly the order  |
|                                   | you want. For example, if you     |
|                                   | want to first increment `x` and   |
|                                   | then assign `x + 1` to `y`, just  |
|                                   | write it as two separate          |
|                                   | statements.                       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Instead of writing this:          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | y = ++x + 1;                      |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | write it as two separate          |
|                                   | statements:                       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | x++;                              |
|                                   | y = x + 1;                        |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
