
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](index.html){.nav-link}
        -   [9.1. Assembly Basics](basics.html){.nav-link}
        -   [9.2. Common Instructions](common.html){.nav-link}
        -   [9.3. Arithmetic Instructions](arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [9.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [9.4.2. If Statements](if_statements.html){.nav-link}
            -   [9.4.3. Loops](loops.html){.nav-link}
        -   [9.5. Functions in Assembly](functions.html){.nav-link}
        -   [9.6. Recursion](recursion.html){.nav-link}
        -   [9.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [9.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [9.9. Structs in Assembly](structs.html){.nav-link}
        -   [9.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [9. ARMv8 Assembly](index.html)
-   [9.4. Conditional Control and Loops](conditional_control_loops.html)
-   [9.4.3. Loops](loops.html)
:::

::: content
::: sect2
### [](#_loops_in_assembly){.anchor}9.4.3. Loops in Assembly {#_loops_in_assembly}

::: paragraph
Like `if` statements, loops in assembly are also implemented using
branch instructions. However, loops enable instructions to be
*revisited* based on the result of an evaluated condition.
:::

::: paragraph
The `sumUp` function in the following example sums up all the positive
integers from 1 to a user-defined integer *n*. This code is
intentionally written suboptimally to illustrate a `while` loop in C.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int sumUp(int n) {
    //initialize total and i
    int total = 0;
    int i = 1;

    while (i <= n) {  //while i is less than or equal to n
        total += i;   //add i to total
        i++;          //increment i by 1
    }
    return total;
}
```
:::
:::

::: paragraph
Compiling this code and disassembling it using GDB yields the following
assembly code:
:::

::: listingblock
::: content
    Dump of assembler code for function sumUp:
    0x0724 <+0>:   sub   sp, sp, #0x20
    0x0728 <+4>:   str   w0, [sp, #12]
    0x072c <+8>:   str   wzr, [sp, #24]
    0x0730 <+12>:  mov   w0, #0x1
    0x0734 <+16>:  str   w0, [sp, #28]
    0x0738 <+20>:  b     0x758 <sumUp+52>
    0x073c <+24>:  ldr   w1, [sp, #24]
    0x0740 <+28>:  ldr   w0, [sp, #28]
    0x0744 <+32>:  add   w0, w1, w0
    0x0748 <+36>:  str   w0, [sp, #24]
    0x074c <+40>:  ldr   w0, [sp, #28]
    0x0750 <+44>:  add   w0, w0, #0x1
    0x0754 <+48>:  str   w0, [sp, #28]
    0x0758 <+52>:  ldr   w1, [sp, #28]
    0x075c <+56>:  ldr   w0, [sp, #12]
    0x0760 <+60>:  cmp   w1, w0
    0x0764 <+64>:  b.le  0x73c <sumUp+24>
    0x0768 <+68>:  ldr   w0, [sp, #24]
    0x076c <+72>:  add   sp, sp, #0x20
    0x0770 <+76>:  ret
:::
:::

::: paragraph
Again, we will not draw out the stack explicitly in this example.
However, we encourage readers to draw the stack out themselves.
:::

::: sect3
#### [](#_the_first_five_instructions){.anchor}The First Five Instructions {#_the_first_five_instructions}

::: paragraph
The first five instructions of this function set the stack up for
function execution and store some temporary values:
:::

::: listingblock
::: content
    0x0724 <+0>:  sub  sp, sp, #0x20   //grow stack by 32 bytes (new stack frame)
    0x0728 <+4>:  str  w0, [sp, #12]   //store n at sp+12 (n)
    0x072c <+8>:  str  wzr, [sp, #24]  //store 0 at sp+24 (total)
    0x0730 <+12>: mov  w0, #0x1        //w0 = 1
    0x0734 <+16>: str  w0, [sp, #28]   //store 1 at sp+28 (i)
:::
:::

::: paragraph
Specifically, they:
:::

::: ulist
-   Grow the call stack by 32 bytes, marking the new frame.

-   Store the first parameter (`n`) at stack location `sp + 12`.

-   Store the value 0 at stack location `sp + 24`, indicating `total`.

-   Copy the value 1 into register `w0`.

-   Store the value 1 at stack location `sp + 28`, indicating `i`.
:::

::: paragraph
Recall that stack locations store *temporary variables* in a function.
For simplicity we will refer to the location marked by `sp + 24` as
`total` and `sp + 28` as `i`. The input parameter to `sumUp` (`n`) is
located at stack address `sp + 12`. Despite the placement of temporary
variables on the stack, keep in mind that the stack pointer has not
changed after the execution of the first instruction
(`sub sp, sp, #0x20`).
:::
:::

::: sect3
#### [](#_the_heart_of_the_loop){.anchor}The Heart of the Loop {#_the_heart_of_the_loop}

::: paragraph
The next 12 instructions in the `sumUp` function represent the heart of
the loop:
:::

::: listingblock
::: content
    0x0738 <+20>: b     0x758 <sumUp+52>  // goto <sumUp+52>
    0x073c <+24>: ldr   w1, [sp, #24]     // w1 = total
    0x0740 <+28>: ldr   w0, [sp, #28]     // w0 = i
    0x0744 <+32>: add   w0, w1, w0        // w0 =  i + total
    0x0748 <+36>: str   w0, [sp, #24]     // store (total + i) in total
    0x074c <+40>: ldr   w0, [sp, #28]     // w0 = i
    0x0750 <+44>: add   w0, w0, #0x1      // w0 = i + 1
    0x0754 <+48>: str   w0, [sp, #28]     // store (i+1) in i (i.e. i++)
    0x0758 <+52>: ldr   w1, [sp, #28]     // w1 = i
    0x075c <+56>: ldr   w0, [sp, #12]     // w0 = n
    0x0760 <+60>: cmp   w1, w0            // compare i and n
    0x0764 <+64>: b.le  0x73c <sumUp+24>  // if (i <= n) goto <sumUp+24>
:::
:::

::: ulist
-   The first instruction is a direct jump to `<sumUp+52>`, which sets
    the program counter register (`pc`) to address 0x758.

-   The next two instructions that execute (at `<sumUp+52>` and
    `<sumUp+56>`) load `i` and `n` into registers `w1` and `w0`,
    respectively.

-   The `cmp` instruction at `<sumUp+60>` compares `i` and `n`, setting
    the appropriate condition flags. The program counter `pc` advances
    to the next instruction, or address 0x764.

-   The `b.le` instruction at `<sumUp+64>` replaces the `pc` register
    with address 0x73c if `i` is less than or equal to `n`.
:::

::: paragraph
If the branch is taken (that is, if `i <= n`), program execution jumps
to `<sumUp+24>` and the following instructions execute:
:::

::: ulist
-   The `ldr` instructions at `<sumUp+24>` and `<sumUp+28>` load `total`
    and `i` into registers `w1` and `w0`, respectively.

-   The `add` instruction at `<sumUp+32>` then adds `total` to `i`
    (i.e., `i + total`) and stores the result in `w0`.

-   The `str` instruction at `<sumUp+36>` then updates `total` with the
    value in register `w0` (i.e., `total = total + i`)

-   The `ldr` instruction at `<sumUp+40>` loads `i` into register `w0`.

-   The `add` instruction at `<sumUp+44>` adds 1 to `i` and stores the
    result in register `w0`.

-   The `str` instruction at `<sumUp+48>` updates `i` with the value
    stored in register `w0` (i.e., `i = i + 1`)

-   The `ldr` instructions at `<sumUp+52>` and `<sumUp+56>` load `i` and
    `n` into registers `w1` and `w0`, respectively.

-   The `cmp` instruction at `<sumUp+60>` compares `i` to `n` and sets
    the appropriate condition code flags.

-   The `b.le` instruction then executes. If `i` is less than or equal
    to `n`, program execution jumps back to `<sumUp+24>`, `pc` is set to
    0x73c, and the instructions between `<sumUp+24>` and `<sumUp+64>`
    repeat execution. Otherwise, register `pc` is set to the address of
    the next instruction in sequence, or 0x768 (`<sumUp+68>`).
:::

::: paragraph
If the branch is *not* taken (i.e., `i` is greater than `n`), the
following instructions execute:
:::

::: listingblock
::: content
    0x0768 <+68>:  ldr   w0, [sp, #24]   // w0 = total
    0x076c <+72>:  add   sp, sp, #0x20   // restore stack
    0x0770 <+76>:  ret                   // return w0 (total)
:::
:::

::: paragraph
These instructions copy `total` to the return register `w0`, restore the
call stack by shrinking `sp`, and exit the function. Thus, the function
returns `total` upon exit.
:::

::: paragraph
[Table 1](#ReverseSumUpa64) shows the assembly and C `goto` forms of the
`sumUp` function side by side:
:::

+-----------------------------------+-----------------------------------+
| Assembly                          | Translated Goto Form              |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| <sumUp>:                          | int sumUp(int n) {                |
|   <+0>:   sub   sp, sp, #0x20     |     int total = 0;                |
|   <+4>:   str   w0, [sp, #12]     |     int i = 1;                    |
|   <+8>:   str   wzr, [sp, #24]    |     goto start;                   |
|   <+12>:  mov   w0, #0x1          | body:                             |
|   <+16>:  str   w0, [sp, #28]     |     total += i;                   |
|   <+20>:  b     0x758 <sumUp+52>  |     i += 1;                       |
|   <+24>:  ldr   w1, [sp, #24]     | start:                            |
|   <+28>:  ldr   w0, [sp, #28]     |     if (i <= n) {                 |
|   <+32>:  add   w0, w1, w0        |         goto body;                |
|   <+36>:  str   w0, [sp, #24]     |     }                             |
|   <+40>:  ldr   w0, [sp, #28]     |     return total;                 |
|   <+44>:  add   w0, w0, #0x1      | }                                 |
|   <+48>:  str   w0, [sp, #28]     | ```                               |
|   <+52>:  ldr   w1, [sp, #28]     | :::                               |
|   <+56>:  ldr   w0, [sp, #12]     | :::                               |
|   <+60>:  cmp   w1, w0            | :::                               |
|   <+64>:  b.le  0x73c <sumUp+24>  |                                   |
|   <+68>:  ldr   w0, [sp, #24]     |                                   |
|   <+72>:  add   sp, sp, #0x20     |                                   |
|   <+76>:  ret                     |                                   |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 1. Translating `sumUp()` into goto C form.

::: paragraph
The preceding code is also equivalent to the following C code without
`goto` statements:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int sumUp(int n) {
    int total = 0;
    int i = 1;
    while (i <= n) {
        total += i;
        i += 1;
    }
    return total;
}
```
:::
:::
:::

::: sect3
#### [](#_for_loops_in_assembly){.anchor}for Loops in Assembly {#_for_loops_in_assembly}

::: paragraph
The primary loop in the `sumUp` function can also be written as a `for`
loop:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int sumUp2(int n) {
    int total = 0;             //initialize total to 0
    int i;
    for (i = 1; i <= n; i++) { //initialize i to 1, increment by 1 while i<=n
        total += i;            //updates total by i
    }
    return total;
}
```
:::
:::

::: paragraph
This yields identical assembly code to our `while` loop example. We
repeat the assembly code below and annotate each line with its English
translation:
:::

::: listingblock
::: content
    Dump of assembler code for function sumUp2:
    0x0774 <+0>:  sub   sp, sp, #0x20     // grow stack by 32 bytes (new frame)
    0x0778 <+4>:  str   w0, [sp, #12]     // store n at sp+12 (n)
    0x077c <+8>:  str   wzr, [sp, #24]    // store 0 at sp+24 (total)
    0x0780 <+12>: mov   w0, #0x1          // w0 = 1
    0x0784 <+16>: str   w0, [sp, #28]     // store 1 at sp+28 (i)
    0x0788 <+20>: b     0x7a8 <sumUp2+52> // goto <sumUp2+52>
    0x078c <+24>: ldr   w1, [sp, #24]     // w1 = total
    0x0790 <+28>: ldr   w0, [sp, #28]     // w0 = i
    0x0794 <+32>: add   w0, w1, w0        // w0 = total + i
    0x0798 <+36>: str   w0, [sp, #24]     // store (total+i) in total
    0x079c <+40>: ldr   w0, [sp, #28]     // w0 = i
    0x07a0 <+44>: add   w0, w0, #0x1      // w0 = i + 1
    0x07a4 <+48>: str   w0, [sp, #28]     // store (i+1) in i (i.e. i += 1)
    0x07a8 <+52>: ldr   w1, [sp, #28]     // w1 = i
    0x07ac <+56>: ldr   w0, [sp, #12]     // w0 = n
    0x07b0 <+60>: cmp   w1, w0            // compare i and n
    0x07b4 <+64>: b.le  0x78c <sumUp2+24> // if (i <= n) goto <sumUp2+24>
    0x07b8 <+68>: ldr   w0, [sp, #24]     // w0 = total
    0x07bc <+72>: add   sp, sp, #0x20     // restore stack
    0x07c0 <+76>: ret                     // return w0 (total)
:::
:::

::: paragraph
To understand why the `for` loop version of this code results in
identical assembly to the `while` loop version of the code, recall that
the `for` loop has the following representation:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
for ( <initialization>; <boolean expression>; <step> ){
    <body>
}
```
:::
:::

::: paragraph
This is equivalent to the following `while` loop representation:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
<initialization>
while (<boolean expression>) {
    <body>
    <step>
}
```
:::
:::

::: paragraph
Since [every `for` loop can be represented by a `while`
loop](../C1-C_intro/conditionals.html#_for_loops){.page}, the following
two C programs are equivalent representations for the previous assembly:
:::

+-----------------------------------+-----------------------------------+
| For loop                          | While loop                        |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int sumUp2(int n) {               | int sumUp(int n){                 |
|     int total = 0;                |     int total = 0;                |
|     int i = 1;                    |     int i = 1;                    |
|     for (i; i <= n; i++) {        |     while (i <= n) {              |
|         total += i;               |         total += i;               |
|     }                             |         i += 1;                   |
|     return total;                 |     }                             |
| }                                 |     return total;                 |
| ```                               | }                                 |
| :::                               | ```                               |
| :::                               | :::                               |
| :::                               | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 2. Equivalent ways to write the sumUp function.
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
