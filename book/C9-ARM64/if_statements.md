
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](index.html){.nav-link}
        -   [9.1. Assembly Basics](basics.html){.nav-link}
        -   [9.2. Common Instructions](common.html){.nav-link}
        -   [9.3. Arithmetic Instructions](arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [9.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [9.4.2. If Statements](if_statements.html){.nav-link}
            -   [9.4.3. Loops](loops.html){.nav-link}
        -   [9.5. Functions in Assembly](functions.html){.nav-link}
        -   [9.6. Recursion](recursion.html){.nav-link}
        -   [9.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [9.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [9.9. Structs in Assembly](structs.html){.nav-link}
        -   [9.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [9. ARMv8 Assembly](index.html)
-   [9.4. Conditional Control and Loops](conditional_control_loops.html)
-   [9.4.2. If Statements](if_statements.html)
:::

::: content
::: sect2
### [](#_if_statements_in_assembly){.anchor}9.4.2. if Statements in Assembly {#_if_statements_in_assembly}

::: paragraph
Let's take a look at the `getSmallest` function in assembly. For
convenience, the function is reproduced here.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest(int x, int y) {
    int smallest;
    if ( x > y ) {
        smallest = y;
    }
    else {
        smallest = x;
    }
    return smallest;
}
```
:::
:::

::: paragraph
The corresponding assembly code extracted from GDB looks similar to the
following:
:::

::: listingblock
::: content
    (gdb) disas getSmallest
    Dump of assembler code for function getSmallest:
    0x07f4 <+0>:    sub  sp, sp, #0x20
    0x07f8 <+4>:    str  w0, [sp, #12]
    0x07fc <+8>:    str  w1, [sp, #8]
    0x0800 <+12>:   ldr  w1, [sp, #12]
    0x0804 <+16>:   ldr  w0, [sp, #8]
    0x0808 <+20>:   cmp  w1, w0
    0x080c <+24>:   b.le 0x81c <getSmallest+40>
    0x0810 <+28>:   ldr  w0, [sp, #8]
    0x0814 <+32>:   str  w0, [sp, #28]
    0x0818 <+36>:   b    0x824 <getSmallest+48>
    0x081c <+40>:   ldr  w0, [sp, #12]
    0x0820 <+44>:   str  w0, [sp, #28]
    0x0824 <+48>:   ldr  w0, [sp, #28]
    0x0828 <+52>:   add  sp, sp, #0x20
    0x082c <+56>:   ret
:::
:::

::: paragraph
This is a different view of the assembly code than we have seen before.
Here, we can see the *address* associated with each instruction, but not
the *bytes*. Note that this assembly segment has been lightly edited for
the sake of simplicity. By convention, GCC places the first and second
parameters of a function in registers `x0` and `x1` respectively. Since
the parameters to `getSmallest` are of type `int`, the compiler places
the parameters in the respective component registers `w0` and `w1`
instead. For the sake of clarity, we refer to these parameters as `x`
and `y` respectively.
:::

::: paragraph
Let's trace through the first few lines of the previous assembly code
snippet. Note that we will not draw out the stack explicitly in this
example. We leave this as an exercise for the reader, and encourage you
to practice your stack tracing skills by drawing it out yourself.
:::

::: ulist
-   The `sub` instruction grows the call stack by 32 bytes (0x20).

-   The `str` instructions at `<getSmallest+4>` and `<getSmallest+8>`
    store `x` and `y` at stack locations `sp + 12` and `sp + 8`,
    respectively.

-   The `ldr` instructions at `<getSmallest+12>` and `<getSmallest+16`
    load `x` and `y` into registers `w1` and `w0`, respectively. Note
    that the original contents of `w0` and `w1` have swapped!

-   The `cmp` instruction compares `w1` to `w0` (i.e., `x` to `y`) and
    sets appropriate condition code flag registers.

-   The `b.le` instruction at `<getSmallest+24>` indicates that if `x`
    is less than or equal to `y`, the next instruction that should
    execute should be at location `<getSmallest+40>` (or `pc` = 0x81c).
    Otherwise, `pc` is set to the next instruction in sequence, or
    0x810.
:::

::: paragraph
The next instructions to execute depend on whether the program follows
the branch (i.e., executes the jump) at (`<getSmallest+24>`). Let's
first suppose that the branch was *not* followed. In this case, `pc` is
set to 0x810 (i.e., `<getSmallest+28>`) and the following sequence of
instructions executes:
:::

::: ulist
-   The `ldr` instruction at `<getSmallest+28>` loads `y` to register
    `w0`.

-   The `str` instruction at `<getSmallest+32>` stores `y` at stack
    location `sp + 28`.

-   The `b` instruction at `<getSmallest+36>` sets register `pc` to
    address 0x824.

-   The `ldr` instruction at `<getSmallest+48>` loads `y` into register
    `w0`.

-   The last two instructions revert the call stack to its original size
    and return from the function call. In this case, `y` is in the
    return register, `w0`, and `getSmallest` returns `y`.
:::

::: paragraph
Now, suppose that the branch *was* taken at `<getSmallest+24>`. In other
words, the `b.le` instruction sets register `pc` to 0x81c (i.e.,
`<getSmallest+40>`). Then, the next instructions to execute are:
:::

::: ulist
-   The `ldr` instruction at `<getSmallest+40>` loads `x` into register
    `w0`.

-   The `str` instruction at `<getSmallest+44>` stores `x` at stack
    location `sp + 28`.

-   The `ldr` instruction at `<getSmallest+48>` loads `x` into register
    `w0`.

-   The last two instructions revert the call stack to its original size
    and return from the function call. In this case, `x` is in the
    return register, `w0`, and `getSmallest` returns `x`.
:::

::: paragraph
We can then annotate the preceding assembly as follows:
:::

::: listingblock
::: content
    0x07f4 <+0>:   sub  sp, sp, #0x20          // grow stack by 32 bytes
    0x07f8 <+4>:   str  w0, [sp, #12]          // store x at sp+12
    0x07fc <+8>:   str  w1, [sp, #8]           // store y at sp+8
    0x0800 <+12>:  ldr  w1, [sp, #12]          // w1 = x
    0x0804 <+16>:  ldr  w0, [sp, #8]           // w0 = y
    0x0808 <+20>:  cmp  w1, w0                 // compare x and y
    0x080c <+24>:  b.le 0x81c <getSmallest+40> // if(x <= y) goto <getSmallest+40>
    0x0810 <+28>:  ldr  w0, [sp, #8]           // w0 = y
    0x0814 <+32>:  str  w0, [sp, #28]          // store y at sp+28 (smallest)
    0x0818 <+36>:  b    0x824 <getSmallest+48> // goto <getSmallest+48>
    0x081c <+40>:  ldr  w0, [sp, #12]          // w0 = x
    0x0820 <+44>:  str  w0, [sp, #28]          // store x at sp+28 (smallest)
    0x0824 <+48>:  ldr  w0, [sp, #28]          // w0 = smallest
    0x0828 <+52>:  add  sp, sp, #0x20          // clean up stack
    0x082c <+56>:  ret                         // return smallest
:::
:::

::: paragraph
Translating this back to C code yields:
:::

+-----------------------------------+-----------------------------------+
| Goto Form                         | Translated C code                 |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int getSmallest(int x, int y) {   | int getSmallest(int x, int y) {   |
|     int smallest=y;               |     int smallest=y;               |
|     if (x <= y) {                 |     if (x <= y) {                 |
|         goto assign_x;            |         smallest = x;             |
|     }                             |     }                             |
|     smallest = y;                 |     else {                        |
|     goto done;                    |         smallest = y;             |
|                                   |     }                             |
| assign_x:                         |     return smallest;              |
|     smallest = x;                 | }                                 |
|                                   | ```                               |
| done:                             | :::                               |
|     return smallest;              | :::                               |
| }                                 | :::                               |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 1. Translating `getSmallest()` into goto C form and C code.

::: paragraph
In [Table 1](#TranslateSmallesta64), the variable `smallest` corresponds
to register `w0`. If `x` is less than or equal to `y`, the code executes
the statement `smallest = x`, which is associated with the `goto` label
`assign_x` in our `goto` form of this function. Otherwise, the statement
`smallest = y` is executed. The `goto` label `done` is used to indicate
that the value in `smallest` should be returned.
:::

::: paragraph
Notice that the preceding C translation of the assembly code is a bit
different from the original `getSmallest` function. These differences
don't matter; a close inspection of both functions reveals that the two
programs are logically equivalent. However, the compiler first converts
each if statement into an equivalent `goto` form, which results in the
slightly different, but equivalent, version. [Table
2](#StandardGotoIfa64) shows the standard `if` statement format and its
equivalent `goto` form.
:::

+-----------------------------------+-----------------------------------+
| C if statement                    | Compiler's equivalent goto form   |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| if (condition) {                  |     if (!condition) {             |
|     then_statement;               |         goto else;                |
| }                                 |     }                             |
| else {                            |     then_statement;               |
|     else_statement;               |     goto done;                    |
| }                                 | else:                             |
| ```                               |     else_statement;               |
| :::                               | done:                             |
| :::                               | ```                               |
| :::                               | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 2. Standard if statement format and its equivalent goto form.

::: paragraph
Compilers translating code into assembly designate a branch when a
condition is true. Contrast this behavior with the structure of an `if`
statement, where a \"jump\" (to the `else`) occurs when conditions are
*not* true. The `goto` form captures this difference in logic.
:::

::: paragraph
Considering the original `goto` translation of the `getSmallest`
function, we can see that:
:::

::: ulist
-   `x <= y` corresponds to `!(condition)`.

-   `smallest = x` is the `else_statement`.

-   The line `smallest = y` is the `then_statement`.

-   The last line in the function is `return smallest`.
:::

::: paragraph
Rewriting the original version of the function with the preceding
annotations yields:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest(int x, int y) {
    int smallest;
    if (x > y) {     //!(x <= y)
        smallest = y; //then_statement
    }
    else {
        smallest = x; //else_statement
    }
    return smallest;
}
```
:::
:::

::: paragraph
This version is identical to the original `getSmallest` function. Keep
in mind that a function written in different ways at the C code level
can translate to the same set of assembly instructions.
:::

::: sect3
#### [](#_the_conditional_select_instruction){.anchor}The Conditional Select Instruction {#_the_conditional_select_instruction}

::: paragraph
The final conditional instruction we cover is the **conditional select**
(`csel`) instruction. The `cmp`, `tst`, and `b` instructions implement a
**conditional transfer of control** in a program. In other words, the
execution of the program branches in many directions. This can be very
problematic for optimizing code, because branch instructions are
typically very expensive to execute, due to the disruption they can
cause to the instruction pipeline (details covered in the [Architecture
section](../C5-Arch/pipelining_advanced.html#_pipelining_hazards_control_hazards){.page}).
In contrast, the `csel` instruction implements a **conditional transfer
of data**. In other words, the CPU executes *both* the `then_statement`
and `else_statement`, and places the data in the appropriate register
based on the result of the condition.
:::

::: paragraph
The use of C's **ternary expression** often results in the compiler
generating a `csel` instruction in place of branches. For the standard
if-then-else statement, the ternary expression has the form:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
result = (condition) ? then_expression : else_expression;
```
:::
:::

::: paragraph
Let's use this format to rewrite the `getSmallest` function as a ternary
expression. Keep in mind that this new version of the function behaves
exactly as the original `getSmallest` function:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest_csel(int x, int y) {
    return x > y ? y : x;
}
```
:::
:::

::: paragraph
While this may not seem like a big change, let's look at the resulting
assembly. Recall that the first and second parameters (`x` and `y`) are
stored in registers `w0` and `w1`, respectively:
:::

::: listingblock
::: content
    (gdb) disas getSmallest_csel
    Dump of assembler code for function getSmallest_csel:
    0x0860 <+0>:  sub  sp, sp, #0x10      // grow stack by 16 bytes
    0x0864 <+4>:  str  w0, [sp, #12]      // store x at sp+12
    0x0868 <+8>:  str  w1, [sp, #8]       // store y at sp+8
    0x086c <+12>: ldr  w0, [sp, #8]       // w0 = y
    0x0870 <+16>: ldr  w2, [sp, #12]      // w2 = x
    0x0874 <+20>: ldr  w1, [sp, #12]      // w1 = x
    0x0878 <+24>: cmp  w2, w0             // compare x and y
    0x087c <+28>: csel w0, w1, w0, le     // if (x <= y) w0 = x, else w0=y
    0x0880 <+32>: add  sp, sp, #0x10      // restore sp
    0x0884 <+36>: ret                     // return (w0)
:::
:::

::: paragraph
This assembly code has no jumps. After the comparison of `x` and `y`,
`x` moves into the return register `w0` only if `x` is less than or
equal to `y`.
:::

::: paragraph
The structure of the `csel` instruction is:
:::

::: listingblock
::: content
    csel D, R1, R2, C // if (C) D = R1 else D = R2
:::
:::

::: paragraph
where `D` denotes the destination register, `R1` and `R2` are the two
registers containing the values to be compared, and `C` is the condition
to be evaluated.
:::

::: paragraph
As for the branch instructions, the `C` component of the `csel`
instructions indicates the condition on which the conditional select
occurs. They are identical to those shown in the [conditional branch
suffix
table](conditional_control_loops.html#_conditional_branch_instruction_suffixes){.page}.
:::

::: paragraph
In the case of the original `getSmallest` function, the compiler's
internal optimizer (see Chapter 12) will replace the `b` instructions
with a `csel` instruction if level 1 optimizations are turned on (i.e.,
`-O1`):
:::

::: listingblock
::: content
    // compiled with: gcc -O1 -o getSmallest getSmallest.c
    Dump of assembler code for function getSmallest:
    0x0734 <+0>:  cmp  w0, w1            // compare x and y
    0x0738 <+4>:  csel w0, w0, w1, le    // if (x<=y)  w0=x, else w0=y
    0x073c <+8>:  ret                    // return (w0)
:::
:::

::: paragraph
In general, the compiler is very cautious about optimizing branch
instructions into `csel` instructions, especially in cases where side
effects and pointer values are involved. [Table 3](#incrementXa64) shows
two equivalent ways of writing a function called `incrementX`:
:::

+-----------------------------------+-----------------------------------+
| C code                            | C ternary form                    |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int incrementX(int * x) {         | int incrementX2(int * x){         |
|     if                            |     return x ? (*x)++ : 1;        |
|  (x != NULL) { //if x is not NULL | }                                 |
|                                   | ```                               |
|      return (*x)++; //increment x | :::                               |
|     }                             | :::                               |
|     else { //if x is NULL         | :::                               |
|         return 1; //return 1      |                                   |
|     }                             |                                   |
| }                                 |                                   |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 3. Two functions that attempt to increment the value of integer
`x`.

::: paragraph
Each function takes a pointer to an integer as input and checks whether
it is `NULL`. If `x` is not `NULL`, the function increments and returns
the dereferenced value of `x`. Otherwise, the function returns the value
1.
:::

::: paragraph
It is tempting to think that `incrementX2` uses a `csel` instruction
because it uses a ternary expression. However, both functions yield the
exact same assembly code:
:::

::: listingblock
::: content
    // parameter x is in register x0
    Dump of assembler code for function incrementX2:
    0x0774 <+0>:  mov  w1, #0x1                   // w1 = 0x1
    0x0778 <+4>:  cbz  x0, 0x788 <incrementX2+20> // if(x==0) goto<incrementX2+20>
    0x077c <+8>:  ldr  w1, [x0]                   // w1 = *x
    0x0780 <+12>: add  w2, w1, #0x1               // w2 = w1 + 1
    0x0784 <+16>: str  w2, [x0]                   // *x = w2
    0x0788 <+20>: mov  w0, w1                     // w0 = *x
    0x078c <+24>: ret                             // return (w0)
:::
:::

::: paragraph
Recall that the `csel` instruction *executes both branches of the
conditional*. In other words, `x` gets dereferenced no matter what.
Consider the case where `x` is a null pointer. Recall that dereferencing
a null pointer leads to a null pointer exception in the code, causing a
segmentation fault. To prevent any chance of this happening, the
compiler takes the safe road and uses a branch.
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
