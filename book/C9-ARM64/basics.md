
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](index.html){.nav-link}
        -   [9.1. Assembly Basics](basics.html){.nav-link}
        -   [9.2. Common Instructions](common.html){.nav-link}
        -   [9.3. Arithmetic Instructions](arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [9.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [9.4.2. If Statements](if_statements.html){.nav-link}
            -   [9.4.3. Loops](loops.html){.nav-link}
        -   [9.5. Functions in Assembly](functions.html){.nav-link}
        -   [9.6. Recursion](recursion.html){.nav-link}
        -   [9.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [9.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [9.9. Structs in Assembly](structs.html){.nav-link}
        -   [9.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [9. ARMv8 Assembly](index.html)
-   [9.1. Assembly Basics](basics.html)
:::

::: content
::: sect1
## [](#_diving_into_assembly_basics){.anchor}9.1. Diving into Assembly: Basics {#_diving_into_assembly_basics}

::: sectionbody
::: paragraph
For a first look at assembly, we modify the `adder` function from the
[assembly introduction
chapter](../C6-asm_intro/index.html#_assembly_chapter){.page} to
simplify its behavior. The modified function (`adder2`) is shown here:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

//adds two to an integer and returns the result
int adder2(int a) {
    return a + 2;
}

int main(void) {
    int x = 40;
    x = adder2(x);
    printf("x is: %d\n", x);
    return 0;
}
```
:::
:::

::: paragraph
To compile this code, use the following command:
:::

::: listingblock
::: content
    $ gcc -o adder adder.c
:::
:::

::: paragraph
Next, let's view the corresponding assembly of this code by using the
`objdump` command:
:::

::: listingblock
::: content
    $ objdump -d adder > output
    $ less output
:::
:::

::: paragraph
Search for the code snippet associated with `adder2` by typing `/adder`
while examining the file `output` using `less`. The section associated
with `adder` should look similar to the following:
:::

::: {#Assemblya64 .listingblock}
::: title
Assembly output for the `adder2` function
:::

::: content
    0000000000000724 <adder2>:
     724:   d10043ff        sub     sp, sp, #0x10
     728:   b9000fe0        str     w0, [sp, #12]
     72c:   b9400fe0        ldr     w0, [sp, #12]
     730:   11000800        add     w0, w0, #0x2
     734:   910043ff        add     sp, sp, #0x10
     738:   d65f03c0        ret
:::
:::

::: paragraph
Don't worry if you don't understand what's going on just yet. We will
cover assembly in greater detail in future sections. For now, let's
study the structure of these individual instructions.
:::

::: paragraph
Each line in the preceding example contains the instruction's 64-bit
address in program memory (shortened to the lowest three digits to save
space), the bytes corresponding to the instruction, and the plain-text
representation of the instruction itself. For example, `d10043ff` is the
machine code representation of the instruction `sub sp, sp, #0x10`, and
the instruction occurs at address `0x724` in code memory. Note that
`0x724` is an abbreviation of the full 64-bit address associated with
the `sub sp, sp #0x10` instruction; `objdump` omits the leading zeros to
help with readability.
:::

::: paragraph
It is important to note that a single line of C code often translates to
multiple instructions in assembly. The operation `a + 2` is represented
by the three instructions at code memory addresses `0x728` through
`0x730`: `str w0, [sp, #12]`, `ldr w0, [sp, #12]`, and
`add w0, w0, #0x2`.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Your assembly may look different! |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | If you are compiling your code    |
|                                   | along with us, you may notice     |
|                                   | that some of your assembly        |
|                                   | examples look different. The      |
|                                   | precise assembly instructions     |
|                                   | that are output by a compiler     |
|                                   | depend on the generating          |
|                                   | compiler's version, the precise   |
|                                   | architecture, and the underlying  |
|                                   | operating system. Most of the     |
|                                   | assembly examples in this chapter |
|                                   | were generated on a Raspberry Pi  |
|                                   | 3B+ running the 64-bit Ubuntu     |
|                                   | Mate operating system and using   |
|                                   | GCC. If you use a different       |
|                                   | operating system, a different     |
|                                   | compiler, or a different          |
|                                   | Raspberry Pi or single-board      |
|                                   | computer, your assembly output    |
|                                   | may vary.                         |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In the examples that follow, we   |
|                                   | do not use any optimization       |
|                                   | flags. For example, we compile    |
|                                   | any example file (e.g.            |
|                                   | `example.c`) using the command    |
|                                   | `gcc -o example example.c`.       |
|                                   | Consequently, there are many      |
|                                   | seemingly redundant instructions  |
|                                   | in the examples that follow.      |
|                                   | Remember that the compiler is not |
|                                   | \"smart\" --- it simply follows a |
|                                   | series of rules to translate      |
|                                   | human-readable code into machine  |
|                                   | language. During this translation |
|                                   | process, it is not uncommon for   |
|                                   | some redundancy to occur.         |
|                                   | Optimizing compilers remove many  |
|                                   | of these redundancies during      |
|                                   | optimization, which is covered in |
|                                   | a [later                          |
|                                   | chapter](../C12-CodeOpt/index     |
|                                   | .html#_code_optimization){.page}. |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: sect2
### [](#_registers){.anchor}9.1.1. Registers {#_registers}

::: paragraph
Recall that a **register** is a word-sized storage unit located directly
on the CPU. The ARMv8 CPU has a total of 31 registers for storing
general-purpose 64-bit data: `x0` to `x30`. Whereas a program may
interpret a register's contents as integers or as addresses, the
register itself makes no distinction. Programs can read from or write to
all 31 registers.
:::

::: paragraph
The ARMv8-A ISA also specifies special-purpose registers. The first two
worth noting are the **stack pointer** register (`sp`) and the **program
counter** register (`pc`). The compiler reserves the `sp` register for
maintaining the layout of the program stack. The `pc` register points to
the next instruction to be executed by the CPU; unlike the other
registers, programs cannot write directly to the `pc` register. Next,
the **zero register** `zr` permanently stores the value 0, and is only
useful as a source register.
:::
:::

::: sect2
### [](#_advanced_register_notation){.anchor}9.1.2. Advanced Register Notation {#_advanced_register_notation}

::: paragraph
Since ARMv8-A is an extension of the 32-bit ARMv7-A architecture, the
A64 ISA provides mechanisms to access the lower 32 bits of each of the
general-purpose registers, or `w0` through `w30`. [Figure
1](#Registera64) shows a sample layout of register `x0`. If 32-bit data
is stored in component register `w0`, then the upper 32 bits of the
register become inaccessible, and are zeroed out.
:::

::: {#Registera64 .imageblock .text-center}
::: content
![32-bit component register w0 and its relation to the 64-bit x0
register](_images/register.png){width="500"}
:::

::: title
Figure 1. Component register layout of register %x0.
:::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | The compiler may choose component |
|                                   | registers depending on type       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | When reading assembly code, keep  |
|                                   | in mind that the compiler         |
|                                   | typically uses the 64-bit         |
|                                   | registers when dealing with       |
|                                   | 64-bit values (e.g., pointers or  |
|                                   | `long` types) and the 32-bit      |
|                                   | component registers when dealing  |
|                                   | with 32-bit types (e.g., `int`).  |
|                                   | In A64, it is very common to see  |
|                                   | 32-bit component registers        |
|                                   | intermixed with the full 64-bit   |
|                                   | registers. For example, in the    |
|                                   | `adder2` function shown earlier,  |
|                                   | the compiler references component |
|                                   | register `w0` instead of `x0`     |
|                                   | given that `int` types typically  |
|                                   | take up 32 bits (four bytes) of   |
|                                   | space on 64-bit systems. If the   |
|                                   | `adder2` function had a `long`    |
|                                   | parameter instead of an `int`     |
|                                   | parameter, the compiler would     |
|                                   | store `a` in register `x0`        |
|                                   | instead of component register     |
|                                   | `w0`.                             |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
For readers previously familiar with the A32 ISA, it is important to
note that the 32-bit general-purpose registers `r0` to `r12` from the
A32 ISA map to the A64 component registers `w0` to `w12`. The A64 ISA
more than doubles the number of available registers.
:::
:::

::: sect2
### [](#_instruction_structure){.anchor}9.1.3. Instruction Structure {#_instruction_structure}

::: paragraph
Each instruction consists of an operation code (or **opcode**) that
specifies what it does, and one or more **operands** that tells the
instruction how to do it. For most A64 instructions, the following
format is typically used:
:::

::: listingblock
::: content
    opcode D, O1, O2
:::
:::

::: paragraph
Where `opcode` is the operation code, `D` is the destination register,
`O1` is the first operand, and `O2` the second operand. For example, the
instruction `add w0, w0, #0x2` has the opcode `add`, a destination
register of `w0`, and the two operands `w0` and `#0x2`. There are
multiple types of operands:
:::

::: ulist
-   **Constant (literal)** values are preceded by the `#` sign. For
    example, in the instruction `add w0, w0, #0x2`, the operand `#0x2`
    is a literal value that corresponds to the hexadecimal value 0x2.

-   **Register** forms refer to individual registers. The instruction
    `add sp, sp, #0x10` uses the stack pointer register `sp` to
    designate the destination register and the first of the two operands
    needed for the `add` instruction.

-   **Memory** forms correspond to some value inside main memory (RAM)
    and are commonly used for address lookups. Memory address forms can
    contain a combination of registers and constant values. For example,
    in the instruction `str w0, [sp, #12]`, the operand `[sp, #12]` is
    an example of a memory form. It loosely translates to \"add 12 to
    the value in register `sp`, and then perform a memory lookup on the
    corresponding address.\" If this sounds like a pointer dereference,
    that's because it is!
:::
:::

::: sect2
### [](#_an_example_with_operands){.anchor}9.1.4. An Example with Operands {#_an_example_with_operands}

::: paragraph
The best way to explain operands in detail is to present a quick
example. Suppose that memory contains the following values:
:::

+-----------------------------------+-----------------------------------+
| Address                           | Value                             |
+===================================+===================================+
| 0x804                             | 0xCA                              |
+-----------------------------------+-----------------------------------+
| 0x808                             | 0xFD                              |
+-----------------------------------+-----------------------------------+
| 0x80c                             | 0x12                              |
+-----------------------------------+-----------------------------------+
| 0x810                             | 0x1E                              |
+-----------------------------------+-----------------------------------+

::: paragraph
Let's also assume that the following registers contain the values:
:::

+-----------------------------------+-----------------------------------+
| Register                          | Value                             |
+===================================+===================================+
| `x0`                              | 0x804                             |
+-----------------------------------+-----------------------------------+
| `x1`                              | 0xC                               |
+-----------------------------------+-----------------------------------+
| `x2`                              | 0x2                               |
+-----------------------------------+-----------------------------------+
| `w3`                              | 0x4                               |
+-----------------------------------+-----------------------------------+

::: paragraph
Then the operands in [Table 1](#Operandsa64) evaluate to the values
shown there. Each row of the table matches an operand with its form
(e.g., constant, register, memory), how it is translated, and its value.
:::

+-----------------+-----------------+-----------------+-----------------+
| Operand         | Form            | Translation     | Value           |
+=================+=================+=================+=================+
| `x0`            | Register        | `x0`            | 0x804           |
+-----------------+-----------------+-----------------+-----------------+
| `[x0]`          | Memory          | \*(0x804)       | 0xCA            |
+-----------------+-----------------+-----------------+-----------------+
| `#0x804`        | Constant        | 0x804           | 0x804           |
+-----------------+-----------------+-----------------+-----------------+
| `[x0, #8]`      | Memory          | \*(`x0` + 8) or | 0x12            |
|                 |                 | \*(0x80c)       |                 |
+-----------------+-----------------+-----------------+-----------------+
| `[x0, x1]`      | Memory          | \*(`x0` + `x1`) | 0x1E            |
|                 |                 | or \*(0x810)    |                 |
+-----------------+-----------------+-----------------+-----------------+
| `               | (Sign-Extend)   | \*(`x0` +       | 0xFD            |
| [x0, w3, SXTW]` | Memory          | Si              |                 |
|                 |                 | gnExtend(`w3`)) |                 |
|                 |                 | or \*(0x808)    |                 |
+-----------------+-----------------+-----------------+-----------------+
| `[x0            | Scaled Memory   | \*(`x0` +       | 0x12            |
| , x2, LSL, #2]` |                 | (`x2 << 2`)) or |                 |
|                 |                 | \*(0x80c)       |                 |
+-----------------+-----------------+-----------------+-----------------+
| `[x0,           | (Sign-Extend)   | \*(`x0` +       | 0x12            |
|  w3, SXTW, #1]` | Scaled Memory   | SignExt         |                 |
|                 |                 | end(`w3 << 1`)) |                 |
|                 |                 | or \*(0x80c)    |                 |
+-----------------+-----------------+-----------------+-----------------+

: Table 1. Example Operands

::: paragraph
In [Table 1](#Operandsa64), the notation `x0` indicates the value stored
in 64-bit register `x0`, whereas `w3` indicates a 32-bit value stored in
component register `w3`. The operand `[x0]` indicates that the value
inside `x0` should be treated as an address, and to dereference (look
up) the value at that address. Therefore, the operand `[x0]` corresponds
to \*(0x804) or the value 0xCA. An operation on a 32-bit register can be
combined with a 64-bit register using the sign-extend word (`SXTW`)
instruction. So, `[x0, w3, SXTW]` sign extends `w3` into a 64-bit value
before adding it to `x0` and performing a memory lookup. Lastly, scaled
memory types enable the calculation of offsets through the use of a left
shift.
:::

::: paragraph
A few important notes before continuing. Although [Table
1](#Operandsa64) shows many valid operand forms, not all forms can be
used interchangeably in all circumstances.
:::

::: paragraph
Specifically:
:::

::: ulist
-   Data cannot be read or written to memory directly; instead, ARM
    follows a load/store model, which requires data to be operated on in
    registers. Thus, data must be transferred to registers before being
    operated on, and transferred back to memory after the operations are
    complete.

-   The destination component of an instruction must always be a
    register.
:::

::: paragraph
[Table 1](#Operandsa64) is provided as a reference; however,
understanding key operand forms will help improve the reader's speed in
parsing assembly language.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
