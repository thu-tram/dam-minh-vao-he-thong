
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](index.html){.nav-link}
        -   [9.1. Assembly Basics](basics.html){.nav-link}
        -   [9.2. Common Instructions](common.html){.nav-link}
        -   [9.3. Arithmetic Instructions](arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [9.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [9.4.2. If Statements](if_statements.html){.nav-link}
            -   [9.4.3. Loops](loops.html){.nav-link}
        -   [9.5. Functions in Assembly](functions.html){.nav-link}
        -   [9.6. Recursion](recursion.html){.nav-link}
        -   [9.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [9.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [9.9. Structs in Assembly](structs.html){.nav-link}
        -   [9.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [9. ARMv8 Assembly](index.html)
-   [9.7. Arrays in Assembly](arrays.html)
:::

::: content
::: sect1
## [](#_arrays){.anchor}9.7. Arrays {#_arrays}

::: sectionbody
::: paragraph
Recall that
[arrays](../C1-C_intro/arrays_strings.html#_introduction_to_arrays){.page}
are ordered collections of data elements of the same type that are
contiguously stored in memory. Statically allocated [single-dimension
arrays](../C2-C_depth/arrays.html#_single_dimensional_arrays){.page}
have the form `Type arr[N]`, where `Type` is the data type, `arr` is the
identifier associated with the array, and `N` is the number of data
elements. Declaring an array statically as `Type arr[N]` or dynamically
as `arr = malloc(N*sizeof(Type))` allocates *N* × `sizeof`(*Type*) total
bytes of memory.
:::

::: paragraph
To access the element at index `i` in array `arr`, use the syntax
`arr[i]`. Compilers commonly convert array references into [pointer
arithmetic](../C2-C_depth/pointers.html#_pointer_variables){.page} prior
to translating to assembly. So ,`arr+i` is equivalent to `&arr[i]`, and
`*(arr+i)` is equivalent to `arr[i]`. Since each data element in `arr`
is of type `Type`, `arr+i` implies that element `i` is stored at address
`arr + sizeof(Type) * i`.
:::

::: paragraph
[Table 1](#ArrayOpsa64) outlines some common array operations and their
corresponding assembly instructions. In the examples that follow,
suppose we declare an `int` array of length 10 (e.g., `int arr[10]`).
Assume that register `x1` stores the address of `arr`, register `x2`
stores the `int` value `i`, and register `x0` represents some variable
`x` (also of type `int`). Recall that `int` variables take up four bytes
of space, whereas `int *` variables take up eight bytes.
:::

+----------------------+----------------------+-----------------------+
| Operation            | Type                 | Assembly              |
|                      |                      | Representation        |
+======================+======================+=======================+
| `x = arr`            | `int *`              | `mov x0, x1`          |
+----------------------+----------------------+-----------------------+
| `x = arr[0]`         | `int`                | `ldr w0, [x1]`        |
+----------------------+----------------------+-----------------------+
| `x = arr[i]`         | `int`                | `ldr w                |
|                      |                      | 0, [x1, x2, LSL, #2]` |
+----------------------+----------------------+-----------------------+
| `x = &arr[3]`        | `int *`              | `add x0, x1, #12`     |
+----------------------+----------------------+-----------------------+
| `x = arr+3`          | `int *`              | `add x0, x1, #12`     |
+----------------------+----------------------+-----------------------+
| `x = *(arr+5)`       | `int`                | `ldr w0, [x1, #20]`   |
+----------------------+----------------------+-----------------------+

: Table 1. Common Array Operations and Their Corresponding Assembly
Representations

::: paragraph
Notice that to access element `arr[5]` (or `*(arr+5)` using pointer
arithmetic), the compiler performs a memory lookup on address `arr+5*4`
instead of `arr+5`. To understand why this is necessary, recall that any
element at index `i` in an array is stored at address
`arr + sizeof(Type) * i`. The compiler must therefore multiply the index
by the size of the data type (in this case 4, since `sizeof(int) = 4`)
to compute the correct offset. Recall also that memory is
byte-addressable; offsetting by the correct number of bytes is the same
as computing an address.
:::

::: paragraph
As an example, consider a sample array (`array`) with 10 integer
elements ([\[FigArray6\]](#FigArray6)).
:::

::: {#FigArray6a64 .imageblock .text-center}
::: content
![Each integer in the array requires four
bytes.](_images/arrayFig.png){width="600"}
:::

::: title
Figure 1. The layout of a ten-integer array in memory. Each a~i~-labeled
box represents an offset of four bytes, as each integer requires four
bytes to store.
:::
:::

::: paragraph
Notice that since `array` is an array of integers, each element takes up
exactly four bytes. Thus, an integer array with 10 elements consumes 40
bytes of contiguous memory.
:::

::: paragraph
To compute the address of element 3, the compiler multiplies the index 3
by the data size of the integer type (4) to yield an offset of 12 (or
0xc). Sure enough, element 3 in [Figure 1](#FigArray6a64) is located at
byte offset a~12~.
:::

::: paragraph
Let's take a look at a simple C function called `sumArray` that sums up
all the elements in an array:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int sumArray(int *array, int length) {
    int i, total = 0;
    for (i = 0; i < length; i++) {
        total += array[i];
    }
    return total;
}
```
:::
:::

::: paragraph
The `sumArray` function takes the address of an array and the array's
associated length and sums up all the elements in the array. Now take a
look at the corresponding assembly of the `sumArray` function:
:::

::: listingblock
::: content
    Dump of assembler code for function sumArray:
    0x874 <+0>:   sub    sp, sp, #0x20       // grow stack by 32 bytes (new frame)
    0x878 <+4>:   str    x0, [sp, #8]        // store x0 at sp + 8 (array address)
    0x87c <+8>:   str    w1, [sp, #4]        // store w1 at sp + 4 (length)
    0x880 <+12>:  str    wzr, [sp, #28]      // store 0 at sp + 28  (total)
    0x884 <+16>:  str    wzr, [sp, #24]      // store 0 at sp + 24 (i)
    0x888 <+20>:  b      0x8b8 <sumArray+68> // goto <sumArray+68>
    0x88c <+24>:  ldrsw  x0, [sp, #24]       // x0 = i
    0x890 <+28>:  lsl    x0, x0, #2          // left shift i by 2 (i << 2, or i*4)
    0x894 <+32>:  ldr    x1, [sp, #8]        // x1 = array
    0x898 <+36>:  add    x0, x1, x0          // x0 = array + i*4
    0x89c <+40>:  ldr    w0, [x0]            // w0 = array[i]
    0x8a0 <+44>:  ldr    w1, [sp, #28]       // w1 = total
    0x8a4 <+48>:  add    w0, w1, w0          // w0 = total + array[i]
    0x8a8 <+52>:  str    w0, [sp, #28]       // store (total + array[i]) in total
    0x8ac <+56>:  ldr    w0, [sp, #24]       // w0 = i
    0x8b0 <+60>:  add    w0, w0, #0x1        // w0 = w0 + 1 (i+1)
    0x8b4 <+64>:  str    w0, [sp, #24]       // store (i + 1) in i (i.e. i+=1)
    0x8b8 <+68>:  ldr    w1, [sp, #24]       // w1 = i
    0x8bc <+72>:  ldr    w0, [sp, #4]        // w0 = length
    0x8c0 <+76>:  cmp    w1, w0              // compare i and length
    0x8c4 <+80>:  b.lt   0x88c <sumArray+24> // if (i < length) goto <sumArray+24>
    0x8c8 <+84>:  ldr    w0, [sp, #28]       // w0 = total
    0x8cc <+88>:  add    sp, sp, #0x20       // revert stack to original state
    0x8d0 <+92>:  ret                        // return (total)
:::
:::

::: paragraph
When tracing this assembly code, consider whether the data being
accessed represents a pointer or a value. For example, the instruction
at `<sumArray+12>` results in stack location `sp + 28` containing a
variable of type `int`, which is initially set to `0`. In contrast, the
argument stored at location `sp + 8` is the first argument to the
function (`array`), which is of type `int *` and corresponds to the base
address of the array. A different variable (which we call `i`) is stored
at location `sp + 24` and is initially set to 0.
:::

::: paragraph
The astute reader will notice a previously unseen instruction at line
`<sumArray+30>` called `ldrsw`. The `ldrsw` instruction stands for
\"load register signed word\" and converts the 32-bit `int` value stored
at `sp + 24` to a 64-bit integer value and stores it in `x0`. This
operation is necessary because the instructions that follow perform
pointer arithmetic. Recall that on 64-bit systems, pointers take up
eight bytes of space. The compiler's use of `ldrsw` simplifies the
process by ensuring that all data are stored in full 64-bit registers
instead of their 32-bit components.
:::

::: paragraph
Let's take a closer look at the seven instructions between locations
`<sumArray+28>` and `<sumArray+52>`:
:::

::: listingblock
::: content
    0x890 <+28>:  lsl    x0, x0, #2             // left shift i by 2 (i << 2, or i*4)
    0x894 <+32>:  ldr    x1, [sp, #8]           // x1 = array
    0x898 <+36>:  add    x0, x1, x0             // x0 = array + i*4
    0x89c <+40>:  ldr    w0, [x0]               // w0 = array[i]
    0x8a0 <+44>:  ldr    w1, [sp, #28]          // w1 = total
    0x8a4 <+48>:  add    w0, w1, w0             // w0 = total + array[i]
    0x8a8 <+52>:  str    w0, [sp, #28]          // store (total + array[i]) in total
:::
:::

::: paragraph
The compiler uses `lsl` to perform a left shift on the value `i` stored
in `x0`. When this instruction completes execution, register `x0`
contains `i << 2`, or `i * 4`. At this point, `x0` contains the number
of bytes to calculate the correct offset of `array[i]` (or
`sizeof(int) = 4`).
:::

::: paragraph
The next instruction (`ldr x1, [sp, #8]`) loads the first argument to
the function (i.e., the base address of `array`) into register `x1`.
Adding `x1` to `x0` in the next instruction causes `x0` to contain
`array + i * 4`. Recall that the element at index `i` in `array` is
stored at address `array + sizeof(T) * i` Therefore, `x0` now contains
the assembly-level computation of address `&array[i]`.
:::

::: paragraph
The instruction at `<sumArray+40>` *dereferences* the value located at
`x0`, placing the value `array[i]` into `w1`. Notice the use of the
component register `w1`, because `array[i]` contains a 32-bit `int`
value! In contrast, the variable `i` was changed to a 64-bit integer on
line `<sumArray+24>` since `i` was about to be used for *address
computation*. Again, addresses (pointers) are stored as 64-bit words.
:::

::: paragraph
The last three instructions between `<sumArray+44>` and `<sumArray+52>`
load the current value of `total` into component register `w1`, add
`array[i]` to it, and store the result in component register `w0`,
before updating `total` at location `sp + 28` with the new sum.
Therefore, the seven instructions between `<sumArray+28>` and
`<sumArray+52>` are equivalent to the line `total += array[i]` in the
`sumArray` function.
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
