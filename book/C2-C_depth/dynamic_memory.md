
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](scope_memory.html){.nav-link}
        -   [2.2. C Pointer Variables](pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](strings.html){.nav-link}
        -   [2.7. Structs](structs.html){.nav-link}
        -   [2.8. Input / Output in C](IO.html){.nav-link}
        -   [2.9. Advanced C Features](advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](advanced_assembly.html){.nav-link}
        -   [2.10. Summary](summary.html){.nav-link}
        -   [2.11. Exercises](exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [2. A Deeper Dive Into C](index.html)
-   [2.4. Dynamic Memory Allocation](dynamic_memory.html)
:::

::: content
::: sect1
## [](#_dynamic_memory_allocation){.anchor}2.4. Dynamic Memory Allocation {#_dynamic_memory_allocation}

::: sectionbody
::: paragraph
In addition to pass-by-pointer parameters, programs commonly use pointer
variables to dynamically allocate memory. Such **dynamic memory
allocation** allows a C program to request more memory as it's running,
and a pointer variable stores the address of the dynamically allocated
space. Programs often allocate memory dynamically to tailor the size of
an array for a particular run.
:::

::: paragraph
Dynamic memory allocation grants flexibility to programs that:
:::

::: ulist
-   do not know the size of arrays or other data structures until
    runtime (e.g. the size depends on user input)

-   need to allow for a variety of input sizes (not just up to some
    fixed capacity)

-   want to allocate exactly the size of data structures needed for a
    particular execution (don't waste capacity)

-   grow or shrink the sizes of memory allocated as the program runs,
    reallocating more space when needed and freeing up space when it's
    no longer required.
:::

::: sect2
### [](#_heap_memory){.anchor}2.4.1. Heap Memory {#_heap_memory}

::: paragraph
Every byte of memory in a program's memory space has an associated
address. Everything the program needs to run is in its memory space, and
different types of entities reside in different parts of a program's
memory space. For example, the *code* region contains the program's
instructions, global variables reside in the *data* region, local
variables and parameters occupy the *stack*, and dynamically allocated
memory comes from the *heap*. Because the stack and the heap grow at
runtime (as functions are called and return and as dynamic memory is
allocated and freed), they are typically far apart in a program's
address space to leave a large amount of space for each to grow into as
the program runs.
:::

::: paragraph
Dynamically allocated memory occupies the [**heap**
memory](scope_memory.html#_memoryparts){.page} region of a program's
address space. When a program dynamically requests memory at runtime,
the heap provides a chunk of memory whose address must be assigned to a
pointer variable.
:::

::: paragraph
[Figure 1](#FigProgramMemory) illustrates the parts of a running
program's memory with an example of a pointer variable (`ptr`) on the
stack that stores the address of dynamically allocated heap memory (it
points to heap memory).
:::

::: {#FigProgramMemory .imageblock .text-center}
::: content
![The parts of program memory showing a stack variable pointing to
dynamically allocated heap
memory.](_images/program_memory.png){width="450"}
:::

::: title
Figure 1. A pointer on the stack points to a block of memory that was
allocated from the heap.
:::
:::

::: paragraph
It's important to remember that heap memory is anonymous memory, where
\"anonymous\" means that addresses in the heap are not bound to variable
names. Declaring a named program variable allocates it on the stack or
in the data part of program memory. A local or global pointer variable
can store the address of an anonymous heap memory location (e.g. a local
pointer variable on the stack can point to heap memory), and
dereferencing such a pointer enables a program to store data in the
heap.
:::
:::

::: sect2
### [](#_malloc_and_free){.anchor}2.4.2. malloc and free {#_malloc_and_free}

::: paragraph
**malloc** and **free** are functions in the standard C library
(`stdlib`) that a program can call to allocate and deallocate memory in
the **heap**. Heap memory must be explicitly allocated (malloc'ed) and
deallocated (freed) by a C program.
:::

::: paragraph
To allocate heap memory, call `malloc`, passing in the total number of
bytes of contiguous heap memory to allocate. Use the **`sizeof`
operator** to compute the number of bytes to request. For example, to
allocate space on the heap to store a single integer, a program could
call:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// Determine the size of an integer and allocate that much heap space.
malloc(sizeof(int));
```
:::
:::

::: paragraph
The `malloc` function returns the base address of the allocated heap
memory to the caller (or `NULL` if an error occurs). Here's a full
example program with a call to `malloc` to allocate heap space to store
a single `int` value:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int *p;

    p = malloc(sizeof(int));  // allocate heap memory for storing an int

    if (p != NULL) {
        *p = 6;   // the heap memory p points to gets the value 6
    }
}
```
:::
:::

::: paragraph
The `malloc` function returns a `void *` type, which represents a
generic pointer to a non-specified type (or to any type). When a program
calls `malloc` and assigns the result to a pointer variable, the program
associates the allocated memory with the type of the pointer variable.
:::

::: paragraph
Sometimes you may see calls to `malloc` that explicitly recast its
return type from `void *` to match the type of the pointer variable. For
example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
p = (int *) malloc(sizeof(int));
```
:::
:::

::: paragraph
The `(int *)` before `malloc` tells the compiler that the `void *` type
returned by `malloc` will be used as an `int *` in this call (it recasts
the return type of `malloc` to an `int *`). We discuss [type recasting
and the `void *`
type](advanced_voidstar.html#_c_voidstar_recasting_){.page} in more
detail later in this chapter.
:::

::: paragraph
A call to `malloc` fails if there is not enough free heap memory to
satisfy the requested number of bytes to allocate. Usually, `malloc`
failing indicates an error in the program such as passing `malloc` a
very large request, passing a negative number of bytes, or calling
`malloc` in an infinite loop and running out of heap memory. Because any
call to `malloc` can fail, you should *always test its return value for
NULL* (indicating `malloc` failed) before dereferencing the pointer
value. Dereferencing a NULL pointer will cause your program to crash!
For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int *p;

p = malloc(sizeof(int));
if (p == NULL) {
    printf("Bad malloc error\n");
    exit(1);   // exit the program and indicate error
}
*p = 6;
```
:::
:::

::: paragraph
When a program no longer needs the heap memory it dynamically allocated
with `malloc`, it should explicitly deallocate the memory by calling the
`free` function. It's also a good idea to set the pointer's value to
`NULL` after calling `free`, so that if an error in the program causes
it to be accidentally dereferenced after the call to `free`, the program
will crash rather than modify parts of heap memory that have been
reallocated by subsequent calls to `malloc`. Such unintended memory
references can result in undefined program behavior that is often very
difficult to debug, whereas a null pointer dereference will fail
immediately, making it a relatively easy bug to find and to fix.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
free(p);
p = NULL;
```
:::
:::
:::

::: sect2
### [](#_dynamically_allocated_arrays_and_strings){.anchor}2.4.3. Dynamically Allocated Arrays and Strings {#_dynamically_allocated_arrays_and_strings}

::: paragraph
C programmers often dynamically allocate memory to store arrays. A
successful call to `malloc` allocates one contiguous chunk of heap
memory of the requested size. It returns the address of the start of
this chunk of memory to the caller, making the returned address value
suitable for the base address of a dynamically allocated array in heap
memory.
:::

::: paragraph
To dynamically allocate space for an array of elements, pass `malloc`
the total number of bytes in the desired array. That is, the program
should request from `malloc` the total number of bytes in each array
element times the number of elements in the array. Pass `malloc` an
expression for the total number of bytes in the form of
`sizeof(<type>) * <number of elements>`. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int *arr;
char *c_arr;

// allocate an array of 20 ints on the heap:
arr = malloc(sizeof(int) * 20);

// allocate an array of 10 chars on the heap:
c_arr = malloc(sizeof(char) * 10);
```
:::
:::

::: paragraph
After the calls to `malloc` in this example, the `int` pointer variable
`arr` stores the base address of an array of 20 contiguous integer
storage locations in heap memory, and the `c_arr` char pointer variable
stores the base address of an array of 10 contiguous char storage
locations in heap memory. [Figure 2](#FigHeapArray) depicts what this
might look like.
:::

::: {#FigHeapArray .imageblock .text-center}
::: content
![Main's stack holds two pointer variables. The first, arr, contains the
address of a block of memory on the heap with enough space for 20
integers. The second, c_arr, contains the address of a different block
of memory on the heap with enough space for 10
characters.](_images/heaparray.png){width="700"}
:::

::: title
Figure 2. A 20-element integer array and 10-element character array
allocated on the heap.
:::
:::

::: paragraph
Note that while `malloc` returns a pointer to dynamically allocated
space in heap memory, C programs store the pointer to heap locations on
the stack. The pointer variables contain *only the base address* (the
starting address) of the array storage space in the heap. Just like
statically declared arrays, the memory locations for dynamically
allocated arrays are in contiguous memory locations. While a single call
to `malloc` results in a chunk of memory of the requested number of
bytes being allocated, multiple calls to `malloc` *will not* result in
heap addresses that are contiguous (on most systems). In the example
above, the `char` array elements and the `int` array elements may be at
addresses that are far apart in the heap.
:::

::: paragraph
After dynamically allocating heap space for an array, a program can
access the array through the pointer variable. Because the pointer
variable's value represents the base address of the array in the heap,
we can use the same syntax to access elements in dynamically allocated
arrays as we use to access elements in [statically declared
arrays](../C1-C_intro/arrays_strings.html#_arrays_and_strings){.page}.
Here's an example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int i;
int s_array[20];
int *d_array;

d_array = malloc(sizeof(int) * 20);
if (d_array == NULL) {
    printf("Error: malloc failed\n");
    exit(1);
}

for (i=0; i < 20; i++) {
    s_array[i] = i;
    d_array[i] = i;
}

printf("%d %d \n", s_array[3], d_array[3]);  // prints 3 3
```
:::
:::

::: paragraph
It may not be obvious why the same syntax can be used for accessing
elements in dynamically allocated arrays as is used in accessing
elements in statically declared arrays. However, even though their types
are different, the values of `s_array` and `d_array` both evaluate to
the base address of the array in memory.
:::

+----------------------+----------------------+-----------------------+
| Expression           | Value                | Type                  |
+======================+======================+=======================+
| s_array              | base address of      | (static) array of int |
|                      | array in memory      |                       |
+----------------------+----------------------+-----------------------+
| d_array              | base address of      | int pointer (int \*)  |
|                      | array in memory      |                       |
+----------------------+----------------------+-----------------------+

: Table 1. Comparison of Statically Allocated s_array and Dynamically
Allocated d_array

::: paragraph
Because the names of both variables evaluate to the base address of the
array in memory (the address of the first element memory), the semantics
of the `[i]` syntax following the name of the variable remain the same
for both: `[i]` *dereferences the int storage location at offset i from
the base address of the array in memory* --- it's accessing the \_i_th
element.
:::

::: paragraph
For most purposes, we recommend using the `[i]` syntax to access the
elements of a dynamically allocated array. However, programs can also
use the pointer dereferencing syntax (the `*` operator) to access array
elements. For example, placing a `*` in front of a pointer that refers
to a dynamically allocated array will dereference the pointer to access
element 0 of the array:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
/* these two statements are identical: both put 8 in index 0 */
d_array[0] = 8; // put 8 in index 0 of the d_array
*d_array = 8;   // in the location pointed to by d_array store 8
```
:::
:::

::: paragraph
The [Arrays section](arrays.html#_arrays_in_c){.page} describes arrays
in more detail, and the [Pointer Arithmetic
section](advanced_pointer_arithmetic.html#_c_ptr_arith_){.page}
discusses accessing array elements through pointer variables.
:::

::: paragraph
When a program is finished using a dynamically allocated array, it
should call `free` to deallocate the heap space. As mentioned earlier,
we recommend setting the pointer to `NULL` after freeing it:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
free(arr);
arr = NULL;

free(c_arr);
c_arr = NULL;

free(d_array);
d_array = NULL;
```
:::
:::

::: sidebarblock
::: content
::: title
Heap Memory Management, malloc and free
:::

::: paragraph
The C standard library implements `malloc` and `free`, which are the
programming interface to its heap memory manager. When called, `malloc`
needs to find a contiguous chunk of unallocated heap memory space that
can satisfy the size of the request. The heap memory manager maintains a
**free list** of unallocated **extents** of heap memory, where each
extent specifies the start address and size of a contiguous unallocated
chunk of heap space.
:::

::: paragraph
Initially, all of heap memory is empty, meaning that the free list has a
single extent consisting of the entire heap region. After a program has
made some calls to `malloc` and `free`, heap memory can become
**fragmented**, meaning that there are chunks of free heap space
interspersed with chunks of allocated heap space. The heap memory
manager typically keeps lists of different ranges of sizes of heap space
to enable fast searching for a free extent of a particular size. In
addition, it implements one or more policies for choosing among multiple
free extents that could be used to satisfy a request.
:::

::: paragraph
The `free` function may seem odd in that it only expects to receive the
address of the heap space to free without needing the size of the heap
space to free at that address. That's because `malloc` not only
allocates the requested memory bytes, but it also allocates a few
additional bytes right before the allocated chunk to store a header
structure. The header stores metadata about the allocated chunk of heap
space, such as the size. As a result, a call to `free` only needs to
pass the address of heap memory to free. The implementation of `free`
can get the size of the memory to free from the header information that
is in memory right before the address passed to `free`.
:::

::: paragraph
For more information about heap memory management, see an OS textbook
(for example, Chapter 17 \`\`Free Space Management\'\', in [OS in Three
Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters)
covers these details).
:::
:::
:::
:::

::: sect2
### [](#_pointers_to_heap_memory_and_functions){.anchor}2.4.4. Pointers to Heap Memory and Functions {#_pointers_to_heap_memory_and_functions}

::: paragraph
When passing a dynamically allocated array to a function, the pointer
variable argument's *value* is passed to the function (i.e., the base
address of the array in the heap is passed to the function). Thus, when
passing either statically declared or dynamically allocated arrays to
functions, the parameter gets exactly the same value --- the base
address of the array in memory. As a result, the same function can be
used for statically and dynamically allocated arrays of the same type,
and identical syntax can be used inside the function for accessing array
elements. The parameter declarations `int *arr` and `int arr[]` are
equivalent. However, by convention, the pointer syntax tends to be used
for functions that may be called with dynamically allocated arrays:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int main(void) {
    int *arr1;

    arr1 = malloc(sizeof(int) * 10);
    if (arr1 == NULL) {
        printf("malloc error\n");
        exit(1);
    }

    /* pass the value of arr1 (base address of array in heap) */
    init_array(arr1, 10);
    ...
}

void init_array(int *arr, int size) {
    int i;
    for (i = 0; i < size; i++) {
        arr[i] = i;
    }
}
```
:::
:::

::: paragraph
At the point just before returning from the `init_array` function, the
contents of memory will look like [Figure 3](#FigHeapArrayParam). Note
that when `main` passes `arr1` to `init_array`, it's passing only the
base address of the array. The array's large block of contiguous memory
remains on the heap, and the function can access it by dereferencing the
`arr` pointer parameter. It also passes the size of the array so that
`init_array` knows how many elements to access.
:::

::: {#FigHeapArrayParam .imageblock .text-center}
::: content
![Main's arr1 and init_array's arr variable both store the same base
address of a block of heap
memory.](_images/heaparrayparam.png){width="700"}
:::

::: title
Figure 3. The contents of memory prior to returning from init_array.
Both main's arr1 and init_array's arr variable point to the same block
of heap memory.
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
