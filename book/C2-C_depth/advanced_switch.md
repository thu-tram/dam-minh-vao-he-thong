
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](scope_memory.html){.nav-link}
        -   [2.2. C Pointer Variables](pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](strings.html){.nav-link}
        -   [2.7. Structs](structs.html){.nav-link}
        -   [2.8. Input / Output in C](IO.html){.nav-link}
        -   [2.9. Advanced C Features](advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](advanced_assembly.html){.nav-link}
        -   [2.10. Summary](summary.html){.nav-link}
        -   [2.11. Exercises](exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [2. A Deeper Dive Into C](index.html)
-   [2.9. Advanced C Features](advanced.html)
-   [2.9.1. Constants, switch, enum, and typedef](advanced_switch.html)
:::

::: content
::: sect2
### [](#_c_switch_stmt_){.anchor}2.9.1. Constants, switch, enum, and typedef {#_c_switch_stmt_}

::: paragraph
Constants, switch statements, enumerated types, and typedef are features
of the C language that are useful for creating more readable code and
maintainable code. Constants, enumerated types, and typedefs are used to
define aliases for literal values and types in programs. Switch
statements can be used in place of some chaining `if-else if`
statements.
:::

::: sect3
#### [](#_c_constants_){.anchor}C Constants {#_c_constants_}

::: paragraph
A **constant** is an alias for a C literal value. Constants are used in
place of the literal value to make code more readable and easier to
modify. In C, constants are defined outside of a function body using the
following syntax:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#define const_name (literal_value)
```
:::
:::

::: paragraph
Here is an example of a partial program that defines and uses three
constants (`N`, `PI`, and `NAME`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <stdlib.h>

#define N    (20)        // N:  alias for the literal value 20
#define PI   (3.14)      // PI: alias for the literal value 3.14
#define NAME ("Sarita")  // NAME: alias for the string literal "Sarita"

int main(void) {
  int array[N];   // an array of 20 ints
  int *d_arr, i;
  double area, circ, radius;

  radius = 12.3;
  area = PI*radius*radius;
  circ = 2*PI*radius;

  d_arr = malloc(sizeof(int)*N);
  if(d_arr == NULL) {
    printf("Sorry, %s, malloc failed!\n", NAME);
    exit(1);
  }
  for(i=0; i < N; i++) {
    array[i] = i;
    d_arr[i] = i*2;
  }
  ...
```
:::
:::

::: paragraph
Using constants makes the code more readable (in an expression, `PI` has
more meaning than `3.14`). Using constants also makes code easier to
modify. For example, to change the bounds of the arrays and the
precision of the value of pi in the above program, the programmer only
needs to change their constant definitions and recompile; all the code
that uses the constant will use their new values. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#define N    (50)        // redefine N from 20 to 50
#define PI   (3.14159)   // redefine PI to higher precision

int main(void) {
  int array[N];  // now allocates an array of size 50
  ...
  area = PI*radius*radius;        // now uses 3.14159 for PI
  d_arr = malloc(sizeof(int)*N);  // now mallocs array of 50 ints
  ...
  for(i=0; i < N; i++) {    // now iterates over 50 elements
  ...
```
:::
:::

::: paragraph
It is important to remember that constants are not lvalues---​they are
aliases for literal values of C types. As a result, their values cannot
be changed at runtime like those of variables. The following code, for
example, causes a compilation error:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#define N  20

int main(void) {
  ...
  N = 50;  // compilation error: `20 = 50` is not valid C
```
:::
:::
:::

::: sect3
#### [](#_c_switch_){.anchor}Switch statements {#_c_switch_}

::: paragraph
The C `switch` statement can be used in place of some, but not all,
chaining `if`-`else if` code sequences. While `switch` doesn't provide
any additional expressive power to the C programming language, it often
yields more concise code branching sequences. It may also allow the
compiler to produce branching code that executes more efficiently than
equivalent chaining `if`-`else if` code.
:::

::: paragraph
The C syntax for a `switch` statement looks like:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
switch (<expression>) {

   case <literal value 1>:
        <statements>;
        break;         // breaks out of switch statement body
   case <literal value 2>:
        <statements>;
        break;         // breaks out of switch statement body
   ...
   default:            // default label is optional
        <statements>;
}
```
:::
:::

::: paragraph
A switch statement is executed as follows:
:::

::: {.olist .arabic}
1.  The `expression` evaluates first.

2.  Next, the `switch` searches for a `case` literal value that matches
    the value of the expression.

3.  Upon finding a matching `case` literal, it begins executing the
    statements that immediately follow it.

4.  If no matching `case` is found, it will begin executing the
    statements in the `default` label if one is present.

5.  Otherwise, no statements in the body of the `switch` statement get
    executed.
:::

::: paragraph
A few rules about `switch` statements:
:::

::: ulist
-   The value associated with each `case` must be a literal value --- it
    *cannot* be an expression. The original expression gets matched for
    *equality* only with the literal values associated with each `case`.

-   Reaching a `break` statement stops the execution of all remaining
    statements inside the body of the `switch` statement. That is,
    `break` breaks out of the body of the `switch` statement and
    continues execution with the next statement after the entire
    `switch` block.

-   The `case` statement with a matching value marks the starting point
    into the sequence of C statements that will be
    executed --- execution jumps to a location inside the `switch` body
    to start executing code. Thus, if there is no `break` statement at
    the end of a particular `case`, then the statements under the
    subsequent `case` statements execute in order until either a `break`
    statement is executed or the end of the body of the `switch`
    statement is reached.

-   The `default` label is optional. If present, it must be at the end.
:::

::: paragraph
Here's an example program with a `switch` statement:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

int main(void) {
    int num, new_num = 0;

    printf("enter a number between 6 and 9: ");
    scanf("%d", &num);

    switch(num) {
        case 6:
            new_num = num + 1;
            break;
        case 7:
            new_num = num;
            break;
        case 8:
            new_num = num - 1;
            break;
        case 9:
            new_num = num + 2;
            break;
        default:
            printf("Hey, %d is not between 6 and 9\n", num);
    }
    printf("num %d  new_num %d\n", num, new_num);
    return 0;
}
```
:::
:::

::: paragraph
Here are some example runs of this code:
:::

::: listingblock
::: content
    ./a.out
    enter a number between 6 and 9: 9
    num 9  new_num 11

    ./a.out
    enter a number between 6 and 9: 6
    num 6  new_num 7

    ./a.out
    enter a number between 6 and 9: 12
    Hey, 12 is not between 6 and 9
    num 12  new_num 0
:::
:::
:::

::: sect3
#### [](#_enumerated_types){.anchor}Enumerated Types {#_enumerated_types}

::: paragraph
An **enumerated type** (`enum`) is a way to define a group of related
integer constants. Often switch statements and enumerated types are used
together.
:::

::: paragraph
The enumerated type should be defined outside of a function body, using
the following syntax (`enum` is a keyword in C):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
enum type_name {
   CONST_1_NAME,
   CONST_2_NAME,
   ...
   CONST_N_NAME
};
```
:::
:::

::: paragraph
Note that the constant fields are specified by a comma separated list of
names and are not explicitly given values. By default, the first
constant in the list is assigned the value 0, the second the value 1,
and so on.
:::

::: paragraph
Below is an example of defining an enumerated type for the days of the
week:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
enum days_of_week {
   MON,
   TUES,
   WED,
   THURS,
   FRI
};
```
:::
:::

::: paragraph
A variable of an enumerated type value is declared using the type name
`enum type_name`, and the constant values it defines can be used in
expressions. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
enum days_of_week day;

day = THURS;

if (day > WED) {
  printf("The weekend is arriving soon!\n");
}
```
:::
:::

::: paragraph
An enumerated types is similar to defining a set of constants using
`#define` like the following:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#define MON    0
#define TUES   1
#define WED    2
#define THURS  3
#define FRI    4
```
:::
:::

::: paragraph
The constant values in the enumerated type can be used in a similar way
as constants are used to make a program easier to read and code easier
to update. However, an enumerated type has an advantage of grouping
together a set of related integer constants together. It also is a type
definition so variables and parameters can be declared to be an
enumerated type, whereas constants are aliases for literal values. In
addition, in enumerated types the specific values of each constant is
implicitly assigned in sequence starting at `0`, so the programmer
doesn't have to specify each constant's value.
:::

::: paragraph
Another nice feature of enumerated types is that it is easy to add or
remove constants from the set without having to change all their values.
For example, if the user wanted to add Saturday and Sunday to the set of
days and maintain the relative ordering of the days, they can add them
to the enumerated type definition without having to explicitly redefine
the values of the others as they would need to do with `#define`
constant definitions:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
enum days_of_week {
   SUN,        // SUN will now be 0
   MON,        // MON will now be 1, and so on
   TUES,
   WED,
   THURS,
   FRI,
   SAT
};
```
:::
:::

::: paragraph
Although values are implicitly assigned to the constants an enumerated
type, the programmer can also assign specific values to them using
`= val` syntax. For example, if the programmer wanted the values of the
days of the week to start at 1 instead of 0, they could do the
following:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
enum days_of_week {
   SUN = 1,  // start the sequence at 1
   MON,      // this is 2 (next value after 1)
   TUES,     // this is 3, and so on
   WED,
   THURS,
   FRI,
   SAT
};
```
:::
:::

::: paragraph
Because an enumerated type defines aliases for a set of `int` literal
values, the value of an enumerated type prints out as its `int` value
and not as the name of the alias. For example, given the above
definition of the `enum days_of_week`, the following prints `3` not the
string `"TUES"`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
enum days_of_week day;

day = TUES;
printf("Today is %d\n", day);
```
:::
:::

::: paragraph
Enumerated types are often used in combination with switch statements as
shown in the example code below. The example also shows a switch
statement with several cases associated with the same set of statements,
and a case statement that does not have a `break` before the next case
statement (when `val` is `FRI` two `printf` statements are executed
before a `break` is encountered, and when `val` is `MON` or `WED` only
one of the `printf` statements is executed before the `break`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// an int because we are using scanf to assign its value
int val;

printf("enter a value between %d and %d: ", SUN, SAT);
scanf("%d", &val);

switch (val) {
  case FRI:
     printf("Orchestra practice today\n");
  case MON:
  case WED:
     printf("PSYCH 101 and CS 231 today\n");
     break;
  case TUES:
  case THURS:
     printf("Math 311 and HIST 140 today\n");
     break;
  case SAT:
     printf("Day off!\n");
     break;
  case SUN:
     printf("Do weekly pre-readings\n");
     break;
  default:
     printf("Error: %d is not a valid day\n", val);
};
```
:::
:::
:::

::: sect3
#### [](#_typedef){.anchor}typedef {#_typedef}

::: paragraph
C provides a way to define a new type that is an alias for an existing
type using the keyword `typedef`. Once defined, variables can be
declared using this new alias for the type. This feature is commonly
used to make the program more readable and to use shorter type names,
often for structs and enumerated types. The following is the format for
defining a new type with `typedef`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
typedef existing_type_name new_type_alias_name;
```
:::
:::

::: paragraph
Here is an example partial program that uses typedefs:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#define MAXNAME  (30)
#define MAXCLASS (40)

enum class_year {
  FIRST = 1,
  SECOND,
  JUNIOR,
  SENIOR,
  POSTGRAD
};

// classYr is an alias for enum class_year
typedef enum class_year classYr;

struct studentT {
  char name[MAXNAME];
  classYr year;     // use classYr type alias for field type
  float gpa;
};

// studentT is an alias for struct studentT
typedef struct studentT  studentT;

// ull is an alias for unsigned long long
typedef unsigned long long ull;

int main(void) {

  // declare variables using typedef type names
  studentT class[MAXCLASS];
  classYr yr;
  ull num;

  num = 123456789;
  yr = JUNIOR;
  strcpy(class[0].name, "Sarita");
  class[0].year = SENIOR;
  class[0].gpa = 3.75;

  ...
```
:::
:::

::: paragraph
Because typedef is often used with structs, C provides syntax for
combining a typedef and a struct definition together by prefixing the
struct definition with `typedef` and listing the name of the type alias
after the closing `}` in the struct definition. For example, the
following defines both a struct type `struct studentT` and an alias for
the type named `studentT`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
typedef struct studentT {
  char name[MAXNAME];
  classYr year;     // use classYr type alias for field type
  float gpa;
} studentT;
```
:::
:::

::: paragraph
This definition is equivalent to doing the typedef separately, after the
the struct definition as in the previous example.
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
