
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](scope_memory.html){.nav-link}
        -   [2.2. C Pointer Variables](pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](strings.html){.nav-link}
        -   [2.7. Structs](structs.html){.nav-link}
        -   [2.8. Input / Output in C](IO.html){.nav-link}
        -   [2.9. Advanced C Features](advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](advanced_assembly.html){.nav-link}
        -   [2.10. Summary](summary.html){.nav-link}
        -   [2.11. Exercises](exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [2. A Deeper Dive Into C](index.html)
-   [2.2. C Pointer Variables](pointers.html)
:::

::: content
::: sect1
## [](#_cs_pointer_variables){.anchor}2.2. C's Pointer Variables {#_cs_pointer_variables}

::: sectionbody
::: paragraph
C's pointer variables provide a level of indirection to accessing
program memory. By understanding how to use pointer variables, a
programmer can write C programs that are both powerful and efficient.
For example, through pointer variables, a C programmer can:
:::

::: ulist
-   implement functions whose parameters can modify values in the
    caller's stack frame

-   dynamically allocate (and deallocate) program memory at runtime when
    the program needs it

-   efficiently pass large data structures to functions

-   create linked dynamic data structures

-   interpret bytes of program memory in different ways.
:::

::: paragraph
In this section we introduce the syntax and semantics of C's pointer
variables and introduce common examples of how to use them in C
programs.
:::

::: sect2
### [](#_pointer_variables){.anchor}2.2.1. Pointer Variables {#_pointer_variables}

::: paragraph
A **pointer variable** stores the address of a memory location in which
a value of a specific type can be stored. For example, a pointer
variable can store the value of an `int` address at which the integer
value 12 is stored. The pointer variable *points to* (refers to) the
value. A pointer provides *a level of indirection* for accessing values
stored in memory. [Figure 1](#FigPointerMem) illustrates an example of
what a pointer variable might look like in memory:
:::

::: {#FigPointerMem .imageblock .text-center}
::: content
![A pointer named \"ptr\" points to a memory location that stores the
integer value 12.](_images/ptr.png){width="300"}
:::

::: title
Figure 1. A pointer variable stores the address of a location in memory.
Here, the pointer stores the address of an integer variable that holds
the number 12.
:::
:::

::: paragraph
Through the pointer variable, `ptr`, the value (`12`) stored in the
memory location it points to can be indirectly accessed. C programs most
frequently use pointer variables for:
:::

::: {.olist .arabic}
1.  **\"Pass by pointer\" parameters**, for writing functions that can
    modify their argument's value through a pointer parameter

2.  **Dynamic memory allocation**, for writing programs that allocate
    (and free) space as the program runs. Dynamic memory is commonly
    used for dynamically allocating arrays. It is useful when a
    programmer doesn't know the size of a data structure at compile time
    (e.g., the array size depends on user input at runtime). It also
    enables data structures to be resized as the program runs.
:::

::: sect3
#### [](#_rules_for_using_pointer_variables){.anchor}Rules for Using Pointer Variables {#_rules_for_using_pointer_variables}

::: paragraph
The rules for using pointer variables are similar to regular variables,
except that you need to think about two types: the type of the pointer
variable, and the type stored in the memory address to which the pointer
variable points.
:::

::: {.olist .arabic}
1.  First, **declare a pointer variable** using `type_name *var_name`:

    ::: listingblock
    ::: content
    ``` {.highlightjs .highlight}
    int *ptr;   // stores the memory address of an int (ptr "points to" an int)
    char *cptr; // stores the memory address of a char (cptr "points to" a char)
    ```
    :::
    :::

    ::: {.admonitionblock .note}
    +-----------------------------------+-----------------------------------+
    |                                   | ::: title                         |
    |                                   | Pointer Types                     |
    |                                   | :::                               |
    |                                   |                                   |
    |                                   | ::: paragraph                     |
    |                                   | Note that although `ptr` and      |
    |                                   | `cptr` are both pointers, they    |
    |                                   | refer to different types:         |
    |                                   | :::                               |
    |                                   |                                   |
    |                                   | ::: ulist                         |
    |                                   | -   The type of `ptr` is          |
    |                                   |     *\"pointer to int\"*          |
    |                                   |     (`int *`). It can point to a  |
    |                                   |     memory location that stores   |
    |                                   |     an `int` value.               |
    |                                   |                                   |
    |                                   | -   The type of `cptr` is         |
    |                                   |     *\"pointer to char\"*         |
    |                                   |     (`char *`). It can point to a |
    |                                   |     memory location that stores a |
    |                                   |     `char` value.                 |
    |                                   | :::                               |
    +-----------------------------------+-----------------------------------+
    :::

2.  Next, **initialize the pointer variable** (make it point to
    something). Pointer variables *store address values*. A pointer
    should be initialized to store the address of a memory location
    whose type matches the type to which the pointer variable points.
    One way to initialize a pointer is to use the **address operator**
    (`&`) with a variable to get the variable's address value:

    ::: listingblock
    ::: content
    ``` {.highlightjs .highlight}
    int x;
    char ch;

    ptr = &x;    // ptr gets the address of x, pointer "points to" x
    cptr = &ch;  // cptr gets the address of ch, pointer "points to" ch
    ```
    :::
    :::

    ::: {#FigPointerInit .imageblock .text-center}
    ::: content
    ![Initialize ptr to the address of x and cptr to the address of ch
    (to point to x and ch,
    respectively).](_images/ptrinit.png){width="700"}
    :::

    ::: title
    Figure 2. A program can initialize a pointer by assigning it the
    address of an existing variable of the appropriate type.
    :::
    :::

    ::: paragraph
    Here's an example of an invalid pointer initialization due to
    mismatched types:
    :::

    ::: listingblock
    ::: content
    ``` {.highlightjs .highlight}
    cptr = &x;   // ERROR: cptr can hold a char memory location
                 // (&x is the address of an int)
    ```
    :::
    :::

    ::: paragraph
    Even though the C compiler may allow this type of assignment (with a
    warning about incompatible types), the behavior of accessing and
    modifying `x` through `cptr` will likely not behave as the
    programmer expects. Instead, the programmer should use an `int *`
    variable to point to an `int` storage location.
    :::

    ::: paragraph
    All pointer variables can also be assigned a special value,
    **NULL**, which represents an invalid address. While a **null
    pointer** (one whose value is `NULL`) should never be used to access
    memory, the value `NULL` is useful for testing a pointer variable to
    see if it points to a valid memory address. That is, C programmers
    will commonly check a pointer to ensure that its value isn't `NULL`
    before attempting to access the memory location to which it points.
    To set a pointer to `NULL`:
    :::

    ::: listingblock
    ::: content
    ``` {.highlightjs .highlight}
    ptr = NULL;
    cptr = NULL;
    ```
    :::
    :::

    ::: {#FigPointerNull .imageblock .text-center}
    ::: content
    ![Initialize ptr and cptr to
    NULL.](_images/ptrnull.png){width="600"}
    :::

    ::: title
    Figure 3. Any pointer can be given the special value NULL, which
    indicates that it doesn't refer to any particular address. Null
    pointers should never be dereferenced.
    :::
    :::
:::

::: {.olist .arabic}
3.  Finally, **use the pointer variable**: the **dereference operator**
    (`*`) follows a pointer variable to the location in memory that it
    points to and accesses the value at that location:

    ::: listingblock
    ::: content
    ``` {.highlightjs .highlight}
    /* Assuming an integer named x has already been declared, this code sets the
       value of x to 8. */

    ptr = &x;   /* initialize ptr to the address of x (ptr points to variable x) */
    *ptr = 8;   /* the memory location ptr points to is assigned 8 */
    ```
    :::
    :::

    ::: {#FigPointerDeref .imageblock .text-center}
    ::: content
    ![Dereference ptr to access the memory it points to (x, whose value
    is 8).](_images/ptrderef.png){width="400"}
    :::

    ::: title
    Figure 4. Dereferencing a pointer accesses the value to which the
    pointer refers.
    :::
    :::
:::
:::

::: sect3
#### [](#_pointer_examples){.anchor}Pointer Examples {#_pointer_examples}

::: paragraph
Here's an example sequence of C statements using two pointer variables:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int *ptr1, *ptr2, x, y;

x = 8;
ptr2 = &x;     // ptr2 is assigned the address of x
ptr1 = NULL;
```
:::
:::

::: {.imageblock .text-center}
::: content
![We initialize x to 8, ptr2 to the address of x, and ptr1 gets
NULL.](_images/ptrs1.png){width="400"}
:::
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
*ptr2 = 10;     // the memory location ptr2 points to is assigned 10
y = *ptr2 + 3;  // y is assigned what ptr2 points to plus 3
```
:::
:::

::: {.imageblock .text-center}
::: content
![Dereference ptr2 to change x to 10 and assign y
13.](_images/ptrs2.png){width="400"}
:::
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
ptr1 = ptr2;   // ptr1 gets the address value stored in ptr2 (both point to x)
```
:::
:::

::: {.imageblock .text-center}
::: content
![Assign ptr1 the value of ptr2 (they now both point to same
location).](_images/ptrs3.png){width="400"}
:::
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
*ptr1 = 100;
```
:::
:::

::: {.imageblock .text-center}
::: content
![Dereference ptr1 and assign 100 to the value it points to. Note: this
assignment changes value pointed to by both ptr1 and ptr2, since they
both refer to the same location.](_images/ptrs4.png){width="400"}
:::
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
ptr1 = &y;     // change ptr1's value (change what it points to)
*ptr1 = 80;
```
:::
:::

::: {.imageblock .text-center}
::: content
![Reassign ptr1 to point to the address of y and dereference it to
change y's value to 80.](_images/ptrs5.png){width="400"}
:::
:::

::: paragraph
When using pointer variables, carefully consider the types of the
relevant variables. Drawing pictures of memory (like those shown above)
can help with understanding what pointer code is doing. Some common
errors involve misusing the dereference operator (`*`) or the address
operator (`&`). For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
ptr = 20;       // ERROR?:  this assigns ptr to point to address 20
ptr = &x;
*ptr = 20;      // CORRECT: this assigns 20 to the memory pointed to by ptr
```
:::
:::

::: paragraph
If your program dereferences a pointer variable that does not contain a
valid address, the program crashes:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
ptr = NULL;
*ptr = 6;    // CRASH! program crashes with a segfault (a memory fault)

ptr = 20;
*ptr = 6;    // CRASH! segfault (20 is not a valid address)

ptr = x;
*ptr = 6;   // likely CRASH or may set some memory location with 6
            // (depends on the value of x which is used as an address value)

ptr = &x;   // This is probably what the programmer intended
*ptr = 6;
```
:::
:::

::: paragraph
These types of errors exemplify one reason to initialize pointer
variables to `NULL`; a program can then test a pointer's value for
`NULL` before dereferencing it:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
if (ptr != NULL) {
    *ptr = 6;
}
```
:::
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
