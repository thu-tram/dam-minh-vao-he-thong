
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](scope_memory.html){.nav-link}
        -   [2.2. C Pointer Variables](pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](strings.html){.nav-link}
        -   [2.7. Structs](structs.html){.nav-link}
        -   [2.8. Input / Output in C](IO.html){.nav-link}
        -   [2.9. Advanced C Features](advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](advanced_assembly.html){.nav-link}
        -   [2.10. Summary](summary.html){.nav-link}
        -   [2.11. Exercises](exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [2. A Deeper Dive Into C](index.html)
-   [2.9. Advanced C Features](advanced.html)
-   [2.9.4. Pointer Arithmetic](advanced_pointer_arithmetic.html)
:::

::: content
::: sect2
### [](#_c_ptr_arith_){.anchor}2.9.4. Pointer Arithmetic {#_c_ptr_arith_}

::: paragraph
If a pointer variable points to an array, a program can perform
arithmetic on the pointer to access any of the array's elements. In most
cases, we recommend against using pointer arithmetic to access array
elements: it's easy to make errors and more difficult to debug when you
do. However, occasionally it may be convenient to successively increment
a pointer to iterate over an array of elements.
:::

::: paragraph
When incremented, a pointer points to the next storage location *of the
type it points to*. For example, incrementing an integer pointer
(`int *`) makes it point to the next `int` storage address (the address
four bytes beyond its current value), and incrementing a character
pointer makes it point to the next `char` storage address (the address
one byte beyond its current value).
:::

::: paragraph
In the [following example program](_attachments/pointerarith.c), we
demonstrate how to use pointer arithmetic to manipulate an array. First
declare pointer variables whose type matches the array's element type:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#define N 10
#define M 20

int main(void) {
    // array declarations:
    char letters[N];
    int numbers[N], i, j;
    int matrix[N][M];

    // declare pointer variables that will access int or char array elements
    // using pointer arithmetic (the pointer type must match array element type)
    char *cptr = NULL;
    int *iptr = NULL;
    ...
```
:::
:::

::: paragraph
Next, initialize the pointer variables to the base address of the arrays
over which they will iterate:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// make the pointer point to the first element in the array
cptr = &(letters[0]); //  &(letters[0])  is the address of element 0
iptr = numbers;       // the address of element 0 (numbers is &(numbers[0]))
```
:::
:::

::: paragraph
Then, using pointer dereferencing, our program can access the array's
elements. Here, we're dereferencing to assign a value to an array
element and then incrementing the pointer variable by one to advance it
to point to the next element:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// initialized letters and numbers arrays through pointer variables
for (i = 0; i < N; i++) {
    // dereference each pointer and update the element it currently points to
    *cptr = 'a' + i;
    *iptr = i * 3;

    // use pointer arithmetic to set each pointer to point to the next element
    cptr++;  // cptr points to the next char address (next element of letters)
    iptr++;  // iptr points to the next int address  (next element of numbers)
}
```
:::
:::

::: paragraph
Note that in this example, the pointer values are incremented inside the
loop. Thus, incrementing their value makes them point to the next
element in the array. This pattern effectively walks through each
element of an array in the same way that accessing `cptr[i]` or
`iptr[i]` at each iteration would.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | The semantics of pointer          |
|                                   | arithmetic and the underlying     |
|                                   | arithmetic function               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The semantics of pointer          |
|                                   | arithmetic are type independent:  |
|                                   | changing any type of pointer's    |
|                                   | value by `N`, (`ptr = ptr + N`)   |
|                                   | makes the pointer point `N`       |
|                                   | storage locations beyond its      |
|                                   | current value (or makes it point  |
|                                   | to `N` elements beyond the        |
|                                   | current element it points to). As |
|                                   | a result, incrementing a pointer  |
|                                   | of any type makes it point to the |
|                                   | very next memory location of the  |
|                                   | type it points to.                |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | However, the actual arithmetic    |
|                                   | function that the compiler        |
|                                   | generates for a pointer           |
|                                   | arithmetic expression varies      |
|                                   | depending on the type of the      |
|                                   | pointer variable (depending on    |
|                                   | the number of bytes the system    |
|                                   | uses to store the type to which   |
|                                   | it points). For example,          |
|                                   | incrementing a `char` pointer     |
|                                   | will increase its value by one    |
|                                   | because the very next valid       |
|                                   | `char` address is one byte from   |
|                                   | the current location.             |
|                                   | Incrementing an `int` pointer     |
|                                   | will increase its value by four   |
|                                   | because the next valid integer    |
|                                   | address is four bytes from the    |
|                                   | current location.                 |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | A programmer can simply write     |
|                                   | `ptr++` to make a pointer point   |
|                                   | to the next element value. The    |
|                                   | compiler generates code to add    |
|                                   | the appropriate number of bytes   |
|                                   | for the corresponding type it     |
|                                   | points to. The addition           |
|                                   | effectively sets its value to the |
|                                   | next valid address in memory of   |
|                                   | that type.                        |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
You can see how the above code modified array elements by printing out
their values (we show this first using array indexing and then using
pointer arithmetic to access each array element's value):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("\n array values using indexing to access: \n");
// see what the code above did:
for (i = 0; i < N; i++) {
    printf("letters[%d] = %c, numbers[%d] = %d\n",
           i, letters[i], i, numbers[i]);
}

// we could also use pointer arith to print these out:
printf("\n array values using pointer arith to access: \n");
// first: initialize pointers to base address of arrays:
cptr = letters;  // letters == &letters[0]
iptr = numbers;
for (i = 0; i < N; i++) {
    // dereference pointers to access array element values
    printf("letters[%d] = %c, numbers[%d] = %d\n",
            i, *cptr, i, *iptr);

    // increment pointers to point to the next element
    cptr++;
    iptr++;
}
```
:::
:::

::: paragraph
Here's what the output looks like:
:::

::: listingblock
::: content
     array values using indexing to access:
    letters[0] = a, numbers[0] = 0
    letters[1] = b, numbers[1] = 3
    letters[2] = c, numbers[2] = 6
    letters[3] = d, numbers[3] = 9
    letters[4] = e, numbers[4] = 12
    letters[5] = f, numbers[5] = 15
    letters[6] = g, numbers[6] = 18
    letters[7] = h, numbers[7] = 21
    letters[8] = i, numbers[8] = 24
    letters[9] = j, numbers[9] = 27

     array values using pointer arith to access:
    letters[0] = a, numbers[0] = 0
    letters[1] = b, numbers[1] = 3
    letters[2] = c, numbers[2] = 6
    letters[3] = d, numbers[3] = 9
    letters[4] = e, numbers[4] = 12
    letters[5] = f, numbers[5] = 15
    letters[6] = g, numbers[6] = 18
    letters[7] = h, numbers[7] = 21
    letters[8] = i, numbers[8] = 24
    letters[9] = j, numbers[9] = 27
:::
:::

::: paragraph
Pointer arithmetic can be used to iterate over any contiguous chunk of
memory. Here's an example using pointer arithmetic to initialize a
statically declared 2D array:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// sets matrix to:
// row 0:   0,   1,   2, ...,  99
// row 1: 100, 110, 120, ..., 199
//        ...
iptr = &(matrix[0][0]);
for (i = 0; i < N*M; i++) {
    *iptr = i;
    iptr++;
}

// see what the code above did:
printf("\n 2D array values inited using pointer arith: \n");
for (i = 0; i < N; i++) {
    for (j = 0; j < M; j++) {
        printf("%3d ", matrix[i][j]);
    }
    printf("\n");
}

return 0;
}
```
:::
:::

::: paragraph
The output will look like:
:::

::: listingblock
::: content
     2D array values initialized using pointer arith:
      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
     20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39
     40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59
     60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79
     80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99
    100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
    120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139
    140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
    160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179
    180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199
:::
:::

::: paragraph
Pointer arithmetic can access contiguous memory locations in any
pattern, starting and ending anywhere in a contiguous chunk of memory.
For example, after initializing a pointer to the address of an array
element, its value can be changed by more than one. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
iptr = &numbers[2];
*iptr = -13;
iptr += 4;
*iptr = 9999;
```
:::
:::

::: paragraph
After executing the preceding code, printing the `numbers` array's
values would look like this (note that the values at index 2 and index 6
have changed):
:::

::: listingblock
::: content
    numbers[0] = 0
    numbers[1] = 3
    numbers[2] = -13
    numbers[3] = 9
    numbers[4] = 12
    numbers[5] = 15
    numbers[6] = 9999
    numbers[7] = 21
    numbers[8] = 24
    numbers[9] = 27
:::
:::

::: paragraph
Pointer arithmetic works on dynamically allocated arrays too. However,
programmers must be careful working with dynamically allocated
multidimensional arrays. If, for example, a program uses multiple
`malloc` calls to dynamically allocate individual rows of a 2D array
([method 2, array of
arrays](arrays.html#_method_2_the_programmer_friendly_way){.page}), then
the pointer must be reset to point to the address of the starting
element of every row. Resetting the pointer is necessary because only
elements within a row are located in contiguous memory addresses. On the
other hand, if the 2D array is allocated as a single `malloc` of total
rows times columns space ([method
1](arrays.html#_method_1_memory_efficient_allocation){.page}), then all
the rows are in contiguous memory (like in the statically declared 2D
array from the example above). In the latter case, the pointer only
needs to be initialized to point to the base address, and then pointer
arithmetic will correctly access any element in the 2D array.
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
