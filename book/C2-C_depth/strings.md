
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](scope_memory.html){.nav-link}
        -   [2.2. C Pointer Variables](pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](strings.html){.nav-link}
        -   [2.7. Structs](structs.html){.nav-link}
        -   [2.8. Input / Output in C](IO.html){.nav-link}
        -   [2.9. Advanced C Features](advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](advanced_assembly.html){.nav-link}
        -   [2.10. Summary](summary.html){.nav-link}
        -   [2.11. Exercises](exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [2. A Deeper Dive Into C](index.html)
-   [2.6. Strings and the String Library](strings.html)
:::

::: content
::: sect1
## [](#_strings_and_the_string_library){.anchor}2.6. Strings and the String Library {#_strings_and_the_string_library}

::: sectionbody
::: paragraph
In the previous chapter we introduced [arrays and strings in
C](../C1-C_intro/arrays_strings.html#_arrays_and_strings){.page}. In
this chapter we discuss dynamically allocated C strings and their use
with the C string library. We first give a brief overview of statically
declared strings.
:::

::: sect2
### [](#_cs_support_for_statically_allocated_strings_arrays_of_char){.anchor}2.6.1. C's Support for Statically Allocated Strings (Arrays of char) {#_cs_support_for_statically_allocated_strings_arrays_of_char}

::: paragraph
C does not support a separate string type, but a string can be
implemented in C programs using an array of `char` values that is
terminated by a special null character value `'\0'`. The terminating
null character identifies the end of the sequence of character values
that make up a string. Not every character array is a C string, but
every C string is an array of `char` values.
:::

::: paragraph
Because strings frequently appear in programs, C provides libraries with
functions for manipulating strings. Programs that use the C string
library need to include `string.h`. Most string library functions
require the programmer to allocate space for the array of characters
that the functions manipulate. When printing out the value of a string,
use the `%s` placeholder.
:::

::: paragraph
Here's an example program that uses strings and some string library
functions:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <string.h>   // include the C string library

int main(void) {
    char str1[10];
    char str2[10];

    str1[0] = 'h';
    str1[1] = 'i';
    str1[2] = '\0';   // explicitly add null terminating character to end

    // strcpy copies the bytes from the source parameter (str1) to the
    // destination parameter (str2) and null terminates the copy.
    strcpy(str2, str1);
    str2[1] = 'o';
    printf("%s %s\n", str1, str2);  // prints: hi ho

    return 0;
}
```
:::
:::
:::

::: sect2
### [](#_dynamically_allocating_strings){.anchor}2.6.2. Dynamically Allocating Strings {#_dynamically_allocating_strings}

::: paragraph
Arrays of characters can be dynamically allocated (as discussed in the
[Pointers](pointers.html#_cs_pointer_variables){.page} and
[Arrays](arrays.html#_arrays_in_c){.page} sections). When dynamically
allocating space to store a string, it's important to remember to
allocate space in the array for the terminating `'\0'` character at the
end of the string.
:::

::: paragraph
The following example program demonstrates static and dynamically
allocated strings (note the value passed to `malloc`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    int size;
    char str[64];         // statically allocated
    char *new_str = NULL; // for dynamically allocated

    strcpy(str, "Hello");
    size = strlen(str);   // returns 5

    new_str = malloc(sizeof(char) * (size+1)); // need space for '\0'
    if(new_str == NULL) {
        printf("Error: malloc failed!  exiting.\n");
        exit(1);
    }
    strcpy(new_str, str);
    printf("%s %s\n", str, new_str);    // prints "Hello Hello"

    strcat(str, " There");  // concatenate " There" to the end of str
    printf("%s\n", str);    // prints "Hello There"

    free(new_str);  // free malloc'ed space when done
    new_str = NULL;

    return 0;
}
```
:::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | C String Functions and            |
|                                   | Destination Memory                |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Many C string functions (notably  |
|                                   | `strcpy` and `strcat`) store      |
|                                   | their results by following a      |
|                                   | *destination* string pointer      |
|                                   | (`char *`) parameter and writing  |
|                                   | to the location it points to.     |
|                                   | Such functions assume that the    |
|                                   | destination contains enough       |
|                                   | memory to store the result. Thus, |
|                                   | as a programmer, you must ensure  |
|                                   | that sufficient memory is         |
|                                   | available at the destination      |
|                                   | prior to calling these functions. |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Failure to allocate enough memory |
|                                   | will yield undefined results that |
|                                   | range from program crashes to     |
|                                   | [major security                   |
|                                   | vulnerabilities](..               |
|                                   | /C8-IA32/buffer_overflow.html#_re |
|                                   | al_world_buffer_overflow){.page}. |
|                                   | For example, the following calls  |
|                                   | to `strcpy` and `strcat`          |
|                                   | demonstrate mistakes that novice  |
|                                   | C programmers often make:         |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | // Attempt to write a 12-byte     |
|                                   |  string into a 5-character array. |
|                                   | char mystr[5];                    |
|                                   | strcpy(mystr, "hello world");     |
|                                   |                                   |
|                                   | // Attempt to write to            |
|                                   | a string with a NULL destination. |
|                                   | char *mystr = NULL;               |
|                                   | strcpy(mystr, "try again");       |
|                                   |                                   |
|                                   | // Attempt to m                   |
|                                   | odify a read-only string literal. |
|                                   | char                              |
|                                   |  *mystr = "string literal value"; |
|                                   | strcat(mystr, "s                  |
|                                   | tring literals aren't writable"); |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect2
### [](#_libraries_for_manipulating_c_strings_and_characters){.anchor}2.6.3. Libraries for Manipulating C Strings and Characters {#_libraries_for_manipulating_c_strings_and_characters}

::: paragraph
C provides several libraries with functions for manipulating strings and
characters. The string library (`string.h`) is particularly useful when
writing programs that use C strings. The `stdlib.h` and `stdio.h`
libraries also contain functions for string manipulation, and the
`ctype.h` library contains functions for manipulating individual
character values.
:::

::: paragraph
When using C string library functions, it's important to remember that
most do not allocate space for the strings they manipulate, nor do they
check that you pass in valid strings; your program must allocate space
for the strings that the C string library will use. Furthermore, if the
library function modifies the passed string, the caller needs to ensure
that the string is correctly formatted (that is, it has a terminating
`\0` character at the end). Calling string library functions with bad
array argument values will often cause a program to crash. The
documentation (for example, manual pages) for different library
functions specifies whether the library function allocates space or if
the caller is responsible for passing in allocated space to the library
function.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | `char[]` and `char *` Parameters  |
|                                   | and `char *` Return Type          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Both statically declared and      |
|                                   | dynamically allocated arrays of   |
|                                   | characters can be passed to a     |
|                                   | `char *` parameter because the    |
|                                   | name of either type of variable   |
|                                   | evaluates to the base address of  |
|                                   | the array in memory. Declaring    |
|                                   | the parameter as type `char []`   |
|                                   | will also work for both           |
|                                   | statically and dynamically        |
|                                   | allocated argument values, but    |
|                                   | `char *` is more commonly used    |
|                                   | for specifying the type of string |
|                                   | (array of `char`) parameters.     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | If a function returns a string    |
|                                   | (its return type is a `char *`),  |
|                                   | its return value can only be      |
|                                   | assigned to a variable whose type |
|                                   | is also `char *`; it cannot be    |
|                                   | assigned to a statically          |
|                                   | allocated array variable. This    |
|                                   | restriction exists because the    |
|                                   | name of a statically declared     |
|                                   | array variable is not a valid     |
|                                   | [lvalue](../C1-C_in               |
|                                   | tro/structs.html#_lvalues){.page} |
|                                   | (its base address in memory       |
|                                   | cannot be changed), so it cannot  |
|                                   | be assigned a `char *` return     |
|                                   | value.                            |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: sect3
#### [](#_strlen_strcpy_strncpy){.anchor}strlen, strcpy, strncpy {#_strlen_strcpy_strncpy}

::: paragraph
The string library provides functions for copying strings and finding
the length of a string:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// returns the number of characters in the string (not including the null character)
int strlen(char *s);

// copies string src to string dst up until the first '\0' character in src
// (the caller needs to make sure src is initialized correctly and
// dst has enough space to store a copy of the src string)
// returns the address of the dst string
char *strcpy(char *dst, char *src);

// like strcpy but copies up to the first '\0' or size characters
// (this provides some safety to not copy beyond the bounds of the dst
// array if the src string is not well formed or is longer than the
// space available in the dst array); size_t is an unsigned integer type
char *strncpy(char *dst, char *src, size_t size);
```
:::
:::

::: paragraph
The `strcpy` function is unsafe to use in situations when the source
string might be longer than the total capacity of the destination
string. In this case, one should use `strncpy`. The `size` parameter
stops `strncpy` from copying more than `size` characters from the `src`
string into the `dst` string. When the length of the `src` string is
greater than or equal to `size`, `strncpy` copies the first `size`
characters from `src` to `dst` and does not add a null character to the
end of the `dst`. As a result, the programmer should explicitly add a
null character to the end of `dst` after calling `strncpy`.
:::

::: paragraph
Here are some example uses of these functions in a program:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>   // include the string library

int main(void) {
    // variable declarations that will be used in examples
    int len, i, ret;
    char str[32];
    char *d_str, *ptr;

    strcpy(str, "Hello There");
    len = strlen(str);  // len is 11

    d_str = malloc(sizeof(char) * (len+1));
    if (d_str == NULL) {
        printf("Error: malloc failed\n");
        exit(1);
    }

    strncpy(d_str, str, 5);
    d_str[5] = '\0';   // explicitly add null terminating character to end

    printf("%d:%s\n", strlen(str), str);      // prints 11:Hello There
    printf("%d:%s\n", strlen(d_str), d_str);  // prints 5:Hello

    free(d_str);

    return 0;
}
```
:::
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | `strlcpy`                         |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The `strlcpy` function is similar |
|                                   | to `strncpy`, except it always    |
|                                   | adds the `'\0'` character to the  |
|                                   | end of the destination string.    |
|                                   | Always terminating the string     |
|                                   | makes it a safer alternative to   |
|                                   | strncpy because it doesn't        |
|                                   | require the programmer to         |
|                                   | remember to explicitly null       |
|                                   | terminate the string.             |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |     //                            |
|                                   |  like strncpy but copies up to th |
|                                   | e first '\0' or size-1 characters |
|                                   |     // and null terminat          |
|                                   | es the dest string (if size > 0). |
|                                   |     char *strlcpy(cha             |
|                                   | r *dest, char *src, size_t size); |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Linux's GNU C library added       |
|                                   | `strlcpy` in a recent version     |
|                                   | (2.38). It's currently only       |
|                                   | available on some systems, but    |
|                                   | its availability will increase as |
|                                   | newer versions of the C library   |
|                                   | become more widespread. We        |
|                                   | recommend using `strlcpy` when it |
|                                   | is available.                     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | On systems where `strlcpy` is     |
|                                   | available, the following call to  |
|                                   | `strncpy` from the example above: |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |       // cop                      |
|                                   | y up to 5 chars from str to d_str |
|                                   |       strncpy(d_str, str, 5);     |
|                                   |       d_st                        |
|                                   | r[5] = '\0';   // explicitly add  |
|                                   | null terminating character to end |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | could be replaced with this call  |
|                                   | to `strlcpy`:                     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |       // cop                      |
|                                   | y up to 5 chars from str to d_str |
|                                   |                                   |
|                                   |    strlcpy(d_str, str, 6);  // st |
|                                   | rlcpy always adds '\0' to the end |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect3
#### [](#_strcmp_strncmp){.anchor}strcmp, strncmp {#_strcmp_strncmp}

::: paragraph
The string library also provides a function to compare two strings.
Comparing string variables using the `==` operator *does not* compare
the characters in the strings --- it compares only the base addresses of
the two strings. For example, the expression:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
if (d_str == str) { ...
```
:::
:::

::: paragraph
compares the base address of the `char` array in the heap pointed to by
`d_str` to the base address of the `str` `char` array allocated on the
stack.
:::

::: paragraph
To compare the values of the strings, a programmer needs to either write
code by hand to compare corresponding element values, or use the
`strcmp` or `strncmp` functions from the string library:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int strcmp(char *s1, char *s2);
// returns 0 if s1 and s2 are the same strings
// a value < 0 if s1 is less than s2
// a value > 0 if s1 is greater than s2

int strncmp(char *s1, char *s2, size_t n);
// compare s1 and s2 up to at most n characters
```
:::
:::

::: paragraph
The `strcmp` function compares strings character by character based on
their [ASCII
representation](../C4-Binary/index.html#_binary_and_data_representation){.page}.
In other words, it compares the `char` values in corresponding positions
of the two parameter arrays to produce the result of the string
comparison, which occasionally yields unintuitive results. For example,
the ASCII encoding for the `char` value `'a'` is *larger* than the
encoding for the `char` value `'Z'`. As a result, `strcmp("aaa", "Zoo")`
returns a positive value indicating that `"aaa"` is greater than
`"Zoo"`, and a call to `strcmp("aaa", "zoo")` returns a negative value
indicating that `"aaa"` is less than `"zoo"`.
:::

::: paragraph
Here are some string comparison examples:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
strcpy(str, "alligator");
strcpy(d_str, "Zebra");

ret =  strcmp(str,d_str);
if (ret == 0) {
    printf("%s is equal to %s\n", str, d_str);
} else if (ret < 0) {
    printf("%s is less than %s\n", str, d_str);
} else {
    printf("%s is greater than %s\n", str, d_str);  // true for these strings
}

ret = strncmp(str, "all", 3);  // returns 0: they are equal up to first 3 chars
```
:::
:::
:::

::: sect3
#### [](#_strcat_strstr_strchr){.anchor}strcat, strstr, strchr {#_strcat_strstr_strchr}

::: paragraph
String library functions can concatenate strings (note that it's up to
the caller to ensure that the destination string has enough space to
store the result):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// append chars from src to end of dst
// returns ptr to dst and adds '\0' to end
char *strcat(char *dst, char *src)

// append the first chars from src to end of dst, up to a maximum of size
// returns ptr to dst and adds '\0' to end
char *strncat(char *dst, char *src, size_t size);
```
:::
:::

::: paragraph
It also provides functions for finding substrings or character values in
strings:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// locate a substring inside a string
// (const means that the function doesn't modify string)
// returns a pointer to the beginning of substr in string
// returns NULL if substr not in string
char *strstr(const char *string, const char *substr);

// locate a character (c) in the passed string (s)
// (const means that the function doesn't modify s)
// returns a pointer to the first occurrence of the char c in string
// or NULL if c is not in the string
char *strchr(const char *s, int c);
```
:::
:::

::: paragraph
Here are some examples using these functions (we omit some error
handling for the sake of readability):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
char str[32];
char *ptr;

strcpy(str, "Zebra fish");
strcat(str, " stripes");  // str gets "Zebra fish stripes"
printf("%s\n", str);     // prints: Zebra fish stripes

strncat(str, " are black.", 8);
printf("%s\n", str);     // prints: Zebra fish stripes are bla  (spaces count)

ptr = strstr(str, "trip");
if (ptr != NULL) {
    printf("%s\n", ptr);   // prints: tripes are bla
}

ptr = strchr(str, 'e');
if (ptr != NULL) {
    printf("%s\n", ptr);   // prints: ebra fish stripes are bla
}
```
:::
:::

::: paragraph
Calls to `strchr` and `strstr` return the address of the first element
in the parameter array with a matching character value or a matching
substring value, respectively. This element address is the start of an
array of `char` values terminated by a `\0` character. In other words,
`ptr` points to the beginning of a substring inside another string. When
printing the value of `ptr` as a string with `printf`, the character
values starting at the index pointed to by `ptr` are printed, yielding
the results listed above.
:::
:::

::: sect3
#### [](#_strtok_strtok_r){.anchor}strtok, strtok_r {#_strtok_strtok_r}

::: paragraph
The string library also provides functions that divide a string into
tokens. A **token** refers to a subsequence of characters in a string
separated by any number of delimiter characters of the programmer's
choosing.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
char *strtok(char *str, const char *delim);

// a reentrant version of strtok (reentrant is defined in later chapters):
char *strtok_r(char *str, const char *delim, char **saveptr);
```
:::
:::

::: paragraph
The `strtok` (or `strtok_r`) functions find individual tokens within a
larger string. For example, setting `strtok`\'s delimiters to the set of
whitespace characters yields words in a string that originally contains
an English sentence. That is, each word in the sentence is a token in
the string.
:::

::: paragraph
Below is an example program that uses `strtok` to find individual words
as the tokens in an input string. (it can also be copied from here:
[strtokexample.c](_attachments/strtokexample.c)).
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
/*
 * Extract whitespace-delimited tokens from a line of input
 * and print them one per line.
 *
 * to compile:
 *   gcc -g -Wall strtokexample.c
 *
 * example run:
 *   Enter a line of text:        aaaaa             bbbbbbbbb          cccccc
 *
 *   The input line is:
 *         aaaaa             bbbbbbbbb          cccccc
 *   Next token is aaaaa
 *   Next token is bbbbbbbbb
 *   Next token is cccccc
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(void) {
     /* whitespace stores the delim string passed to strtok.  The delim
      * string  is initialized to the set of characters that delimit tokens
      * We initialize the delim string to the following set of chars:
      *   ' ': space  '\t': tab  '\f': form feed  '\r': carriage return
      *   '\v': vertical tab  '\n': new line
      * (run "man ascii" to list all ASCII characters)
      *
      * This line shows one way to statically initialize a string variable
      * (using this method the string contents are constant, meaning that they
      *  cannot be modified, which is fine for the way we are using the
      *  whitespace string in this program).
      */
    char *whitespace = " \t\f\r\v\n";  /* Note the space char at beginning */

    char *token;  /* The next token in the line. */
    char *line;   /* The line of text read in that we will tokenize. */

    /* Allocate some space for the user's string on the heap. */
    line = malloc(200 * sizeof(char));
    if (line == NULL) {
        printf("Error: malloc failed\n");
        exit(1);
    }

    /* Read in a line entered by the user from "standard in". */
    printf("Enter a line of text:\n");
    line = fgets(line, 200 * sizeof(char), stdin);
    if (line == NULL) {
        printf("Error: reading input failed, exiting...\n");
        exit(1);
    }
    printf("The input line is:\n%s\n", line);

    /* Divide the string into tokens. */
    token = strtok(line, whitespace);       /* get the first token */
    while (token != NULL) {
        printf("Next token is %s\n", token);
        token = strtok(NULL, whitespace);     /* get the next token */
    }

    free(line);

    return 0;
}
```
:::
:::
:::

::: sect3
#### [](#_sprintf){.anchor}sprintf {#_sprintf}

::: paragraph
The C `stdio` library also provides functions that manipulate C strings.
Perhaps the most useful is the `sprintf` function, which \"prints\" into
a string rather than printing output to a terminal:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// like printf(), the format string allows for placeholders like %d, %f, etc.
// pass parameters after the format string to fill them in
int sprintf(char *s, const char *format, ...);
```
:::
:::

::: paragraph
`sprintf` initializes the contents of a string from values of various
types. Its parameter `format` resembles those of `printf` and `scanf`.
Here are some examples:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
char str[64];
float ave = 76.8;
int num = 2;

// initialize str to format string, filling in each placeholder with
// a char representation of its arguments' values
sprintf(str, "%s is %d years old and in grade %d", "Henry", 12, 7);
printf("%s\n", str);  // prints: Henry is 12 years old and in grade 7

sprintf(str, "The average grade on exam %d is %g", num, ave);
printf("%s\n", str);  // prints: The average grade on exam 2 is 76.8
```
:::
:::
:::

::: sect3
#### [](#_functions_for_individual_character_values){.anchor}Functions for Individual Character Values {#_functions_for_individual_character_values}

::: paragraph
The standard C library (`stdlib.h`) contains a set of functions for
manipulating and testing individual `char` values, including:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdlib.h>   // include stdlib and ctypes to use these
#include <ctype.h>

int islower(ch);
int isupper(ch);       // these functions return a non-zero value if the
int isalpha(ch);       // test is TRUE, otherwise they return 0 (FALSE)
int isdigit(ch);
int isalnum(ch);
int ispunct(ch);
int isspace(ch);
char tolower(ch);     // returns ASCII value of lower-case of argument
char toupper(ch);
```
:::
:::

::: paragraph
Here are some examples of their use:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
char str[64];
int len, i;

strcpy(str, "I see 20 ZEBRAS, GOATS, and COWS");

if ( islower(str[2]) ){
    printf("%c is lower case\n", str[2]);   // prints: s is lower case
}

len = strlen(str);
for (i = 0; i < len; i++) {
    if ( isupper(str[i]) ) {
        str[i] = tolower(str[i]);
    } else if( isdigit(str[i]) ) {
        str[i] = 'X';
    }
}
printf("%s\n", str);  // prints: i see XX zebras, goats, and cows
```
:::
:::
:::

::: sect3
#### [](#_functions_to_convert_strings_to_other_types){.anchor}Functions to Convert Strings to Other Types {#_functions_to_convert_strings_to_other_types}

::: paragraph
`stdlib.h` also contains functions to convert between strings and other
C types. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdlib.h>

int atoi(const char *nptr);     // convert a string to an integer
double atof(const char *nptr);  // convert a string to a float
```
:::
:::

::: paragraph
Here's an example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("%d %g\n", atoi("1234"), atof("4.56"));
```
:::
:::

::: paragraph
For more information about these and other C library functions
(including what they do, their parameter format, what they return, and
which headers need to be included to use them), see their [man
pages](http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html). For
example, to view the `strcpy` man page, run:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ man strcpy
```
:::
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
