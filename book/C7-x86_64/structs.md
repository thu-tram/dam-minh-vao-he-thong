
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](index.html){.nav-link}
        -   [7.1. Assembly Basics](basics.html){.nav-link}
        -   [7.2. Common Instructions](common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [7.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [7.4.2. If Statements](if_statements.html){.nav-link}
            -   [7.4.3. Loops](loops.html){.nav-link}
        -   [7.5. Functions in Assembly](functions.html){.nav-link}
        -   [7.6. Recursion](recursion.html){.nav-link}
        -   [7.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [7.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [7.9. Structs in Assembly](structs.html){.nav-link}
        -   [7.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [7. 64-bit x86 Assembly](index.html)
-   [7.9. Structs in Assembly](structs.html)
:::

::: content
::: sect1
## [](#_structs_in_assembly){.anchor}7.9. structs in Assembly {#_structs_in_assembly}

::: sectionbody
::: paragraph
A [struct](../C2-C_depth/structs.html#_c_structs){.page} is another way
to create a collection of data types in C. Unlike arrays, structs enable
different data types to be grouped together. C stores a `struct` like a
single-dimension array, where the data elements (fields) are stored
contiguously.
:::

::: paragraph
Let's revisit `struct studentT` from Chapter 1:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct studentT {
    char name[64];
    int  age;
    int  grad_yr;
    float gpa;
};

struct studentT student;
```
:::
:::

::: paragraph
[Figure 1](#structArray6) shows how `student` is laid out in memory.
Each x~i~ denotes the address of a particular field.
:::

::: {#structArray6 .imageblock}
::: content
![structArray](_images/structArray.png)
:::

::: title
Figure 1. The memory layout of a struct studentT
:::
:::

::: paragraph
The fields are stored contiguously next to one another in memory in the
order in which they are declared. In [Figure 1](#structArray6), the
`age` field is allocated at the memory location directly after the
`name` field (at byte offset x~64~) and is followed by the `grad_yr`
(byte offset x~68~) and `gpa` (byte offset x~72~) fields. This
organization enables memory-efficient access to the fields.
:::

::: paragraph
To understand how the compiler generates assembly code to work with a
`struct`, consider the function `initStudent`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
void initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {
    strncpy(s->name, nm, 64);
    s->grad_yr = gr;
    s->age = ag;
    s->gpa = g;
}
```
:::
:::

::: paragraph
The `initStudent` function uses the base address of a `struct studentT`
as its first parameter, and the desired values for each field as its
remaining parameters. The following listing depicts this function in
assembly:
:::

::: listingblock
::: content
    Dump of assembler code for function initStudent:
    0x4006aa <+0>:  push  %rbp                   #save rbp
    0x4006ab <+1>:  mov   %rsp,%rbp              #update rbp (new stack frame)
    0x4006ae <+4>:  sub   $0x20,%rsp             #add 32 bytes to stack frame
    0x4006b2 <+8>:  mov   %rdi,-0x8(%rbp)        #copy 1st param to %rbp-0x8 (s)
    0x4006b6 <+12>: mov   %rsi,-0x10(%rbp)       #copy 2nd param to %rpb-0x10 (nm)
    0x4006ba <+16>: mov   %edx,-0x14(%rbp)       #copy 3rd param to %rbp-0x14 (ag)
    0x4006bd <+19>: mov   %ecx,-0x18(%rbp)       #copy 4th param to %rbp-0x18 (gr)
    0x4006c0 <+22>: movss %xmm0,-0x1c(%rbp)      #copy 5th param to %rbp-0x1c (g)
    0x4006c5 <+27>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006c9 <+31>: mov   -0x10(%rbp),%rcx       #copy nm to %rcx
    0x4006cd <+35>: mov   $0x40,%edx             #copy 0x40 (or 64) to %edx
    0x4006d2 <+40>: mov   %rcx,%rsi              #copy nm to %rsi
    0x4006d5 <+43>: mov   %rax,%rdi              #copy s to %rdi
    0x4006d8 <+46>: callq 0x400460 <strncpy@plt> #call strcnpy(s->name, nm, 64)
    0x4006dd <+51>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006e1 <+55>: mov   -0x18(%rbp),%edx       #copy gr to %edx
    0x4006e4 <+58>: mov   %edx,0x44(%rax)        #copy gr to %rax+0x44 (s->grad_yr)
    0x4006e7 <+61>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006eb <+65>: mov   -0x14(%rbp),%edx       #copy ag to %edx
    0x4006ee <+68>: mov   %edx,0x40(%rax)        #copy ag to %rax+0x40 (s->age)
    0x4006f1 <+71>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006f5 <+75>: movss -0x1c(%rbp),%xmm0      #copy g to %xmm0
    0x4006fa <+80>: movss %xmm0,0x48(%rax)       #copy g to %rax+0x48
    0x400700 <+86>: leaveq                       #prepare stack to exit function
    0x400701 <+87>: retq                         #return (void func, %rax ignored)
:::
:::

::: paragraph
Being mindful of the byte offsets of each field is key to understanding
this code. Here are a few things to keep in mind.
:::

::: ulist
-   The `strncpy` call takes the base address of the `name` field of
    `s`, the address of array `nm`, and a length specifier as its three
    arguments. Recall that because `name` is the first field in the
    `struct studentT`, the address of `s` is synonymous with the address
    of `s→name`.
:::

::: listingblock
::: content
    0x4006b2 <+8>:  mov   %rdi,-0x8(%rbp)        #copy 1st param to %rbp-0x8 (s)
    0x4006b6 <+12>: mov   %rsi,-0x10(%rbp)       #copy 2nd param to %rpb-0x10 (nm)
    0x4006ba <+16>: mov   %edx,-0x14(%rbp)       #copy 3rd param to %rbp-0x14 (ag)
    0x4006bd <+19>: mov   %ecx,-0x18(%rbp)       #copy 4th param to %rbp-0x18 (gr)
    0x4006c0 <+22>: movss %xmm0,-0x1c(%rbp)      #copy 5th param to %rbp-0x1c (g)
    0x4006c5 <+27>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006c9 <+31>: mov   -0x10(%rbp),%rcx       #copy nm to %rcx
    0x4006cd <+35>: mov   $0x40,%edx             #copy 0x40 (or 64) to %edx
    0x4006d2 <+40>: mov   %rcx,%rsi              #copy nm to %rsi
    0x4006d5 <+43>: mov   %rax,%rdi              #copy s to %rdi
    0x4006d8 <+46>: callq 0x400460 <strncpy@plt> #call strcnpy(s->name, nm, 64)
:::
:::

::: ulist
-   This code snippet contains the previously undiscussed register
    (`%xmm0`) and instruction (`movss`). The `%xmm0` register is an
    example of a register reserved for floating-point values. The
    `movss` instruction indicates that the data being moved onto the
    call stack is of type single-precision floating point.

-   The next part of the code (instructions `<initStudent+51>` thru
    `<initStudent+58>`) places the value of the `gr` parameter at an
    offset of 0x44 (or 68) from the start of `s`. Revisiting the memory
    layout in [Figure 1](#structArray6) shows that this address
    corresponds to `s→grad_yr`:
:::

::: listingblock
::: content
    0x4006dd <+51>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006e1 <+55>: mov   -0x18(%rbp),%edx       #copy gr to %edx
    0x4006e4 <+58>: mov   %edx,0x44(%rax)        #copy gr to %rax+0x44 (s->grad_yr)
:::
:::

::: ulist
-   The next section of code (instructions `<initStudent+61>` thru
    `<initStudent+68>`) copies the `ag` parameter to the `s→age` field
    of the `struct`, which is located at an offset of 0x40 (or 64) bytes
    from the address of `s`:
:::

::: listingblock
::: content
    0x4006e7 <+61>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006eb <+65>: mov   -0x14(%rbp),%edx       #copy ag to %edx
    0x4006ee <+68>: mov   %edx,0x40(%rax)        #copy ag to %rax+0x40 (s->age)
:::
:::

::: ulist
-   Lastly, the `g` parameter value is copied to the `s→gpa` field (byte
    offset 72 or 0x48) of the `struct`. Notice the use of the `%xmm0`
    register since the data contained at location `%rbp-0x1c` is
    single-precision floating point:
:::

::: listingblock
::: content
    0x4006f1 <+71>: mov   -0x8(%rbp),%rax        #copy s to %rax
    0x4006f5 <+75>: movss -0x1c(%rbp),%xmm0      #copy g to %xmm0
    0x4006fa <+80>: movss %xmm0,0x48(%rax)       #copy g to %rax+0x48
:::
:::

::: sect2
### [](#_data_alignment_and_structs){.anchor}7.9.1. Data Alignment and structs {#_data_alignment_and_structs}

::: paragraph
Consider the following modified declaration of `struct studentT`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct studentTM {
    char name[63]; //updated to 63 instead of 64
    int  age;
    int  grad_yr;
    float gpa;
};

struct studentTM student2;
```
:::
:::

::: paragraph
The size of the `name` field is modified to be 63 bytes, instead of the
original 64. Consider how this affects the way the `struct` is laid out
in memory. It may be tempting to visualize it as in [Figure
2](#wrongLayout).
:::

::: {#wrongLayout .imageblock}
::: content
![struct2wrong](_images/struct2wrong.png)
:::

::: title
Figure 2. An incorrect memory layout for the updated struct studentTM.
Note that the struct's \"name\" field is reduced from 64 to 63 bytes.
:::
:::

::: paragraph
In this depiction, the `age` field occurs in the byte immediately
following the `name` field. But this is incorrect. [Figure
3](#correctLayout) depicts the actual layout in memory.
:::

::: {#correctLayout .imageblock}
::: content
![struct2right](_images/struct2right.png)
:::

::: title
Figure 3. The correct memory layout for the updated struct studentTM.
Byte x~63~ is added by the compiler to satisfy memory alignment
constraints, but it doesn't correspond to any of the fields.
:::
:::

::: paragraph
x64's alignment policy requires that two-byte data types (i.e., `short`)
reside at a two-byte-aligned address, four-byte data types (i.e., `int`,
`float`, and `unsigned`) reside at four-byte-aligned addresses, whereas
larger data types (`long`, `double`, and pointer data) reside at
eight-byte-aligned addresses. For a `struct`, the compiler adds empty
bytes as **padding** between fields to ensure that each field satisfies
its alignment requirements. For example, in the `struct` declared in
[Figure 3](#correctLayout), the compiler adds a byte of padding at byte
x~63~ to ensure that the `age` field starts at an address that is at a
multiple of four. Values aligned properly in memory can be read or
written in a single operation, enabling greater efficiency.
:::

::: paragraph
Consider what happens when a `struct` is defined as follows:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct studentTM {
    int  age;
    int  grad_yr;
    float gpa;
    char name[63];
};

struct studentTM student3;
```
:::
:::

::: paragraph
Moving the `name` array to the end moves the byte of padding to the end
of the struct, ensuring that `age`, `grad_yr`, and `gpa` are four-byte
aligned.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
