
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](index.html){.nav-link}
        -   [7.1. Assembly Basics](basics.html){.nav-link}
        -   [7.2. Common Instructions](common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [7.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [7.4.2. If Statements](if_statements.html){.nav-link}
            -   [7.4.3. Loops](loops.html){.nav-link}
        -   [7.5. Functions in Assembly](functions.html){.nav-link}
        -   [7.6. Recursion](recursion.html){.nav-link}
        -   [7.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [7.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [7.9. Structs in Assembly](structs.html){.nav-link}
        -   [7.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [7. 64-bit x86 Assembly](index.html)
-   [7.1. Assembly Basics](basics.html)
:::

::: content
::: sect1
## [](#_diving_into_assembly_basics){.anchor}7.1. Diving into Assembly: Basics {#_diving_into_assembly_basics}

::: sectionbody
::: paragraph
For a first look at x64 assembly, we modify the `adder` function from
[Chapter 6](index.html#_assembly_chapter){.page} to simplify its
behavior. The modified function (`adder2`) is shown below:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

//adds two to an integer and returns the result
int adder2(int a) {
    return a + 2;
}

int main(void){
    int x = 40;
    x = adder2(x);
    printf("x is: %d\n", x);
    return 0;
}
```
:::
:::

::: paragraph
To compile this code, use the following command:
:::

::: listingblock
::: content
    $ gcc -o adder adder.c
:::
:::

::: paragraph
Next, let's view the corresponding assembly of this code by using the
`objdump` command:
:::

::: listingblock
::: content
    $ objdump -d adder > output
    $ less output
:::
:::

::: paragraph
Search for the code snippet associated with `adder2` by typing `/adder2`
while examining the file `output` using `less`. The section associated
with `adder2` should look similar to the following:
:::

::: {#Assembly .listingblock}
::: title
Assembly output for the `adder2` function
:::

::: content
    0000000000400526 <adder2>:
      400526:       55                      push   %rbp
      400527:       48 89 e5                mov    %rsp,%rbp
      40052a:       89 7d fc                mov    %edi,-0x4(%rbp)
      40052d:       8b 45 fc                mov    -0x4(%rbp),%eax
      400530:       83 c0 02                add    $0x2,%eax
      400533:       5d                      pop    %rbp
      400534:       c3                      retq
:::
:::

::: paragraph
Don't worry if you don't understand what's going on just yet. We will
cover assembly in greater detail in later sections. For now, let's study
the structure of these individual instructions.
:::

::: paragraph
Each line in the preceding example contains an instruction's 64-bit
address in program memory, the bytes corresponding to the instruction,
and the plaintext representation of the instruction itself. For example,
`55` is the machine code representation of the instruction `push %rbp`,
and the instruction occurs at address `0x400526` in program memory. Note
that `0x400526` is an abbreviation of the full 64-bit address associated
with the `push %rbp` instruction; the leading zeroes are ignored for
readability.
:::

::: paragraph
It is important to note that a single line of C code often translates to
multiple instructions in assembly. The operation `a + 2` is represented
by the two instructions `mov -0x4(%rbp), %eax` and `add $0x2, %eax`.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Your assembly may look different! |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | If you are compiling your code    |
|                                   | along with us, you may notice     |
|                                   | that some of your assembly        |
|                                   | examples look different from what |
|                                   | is shown in this book. The        |
|                                   | precise assembly instructions     |
|                                   | that are output by any compiler   |
|                                   | depend on that compiler's version |
|                                   | and the underlying operating      |
|                                   | system. Most of the assembly      |
|                                   | examples in this book were        |
|                                   | generated on systems running      |
|                                   | Ubuntu or Red Hat Enterprise      |
|                                   | Linux (RHEL).                     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In the examples that follow, we   |
|                                   | do not use any optimization       |
|                                   | flags. For example, we compile    |
|                                   | any example file (`example.c`)    |
|                                   | using the command                 |
|                                   | `gcc -o example example.c`.       |
|                                   | Consequently, there are many      |
|                                   | seemingly redundant instructions  |
|                                   | in the examples that follow.      |
|                                   | Remember that the compiler is not |
|                                   | \"smart\" --- it simply follows a |
|                                   | series of rules to translate      |
|                                   | human-readable code into machine  |
|                                   | language. During this translation |
|                                   | process, it is not uncommon for   |
|                                   | some redundancy to occur.         |
|                                   | Optimizing compilers remove many  |
|                                   | of these redundancies during      |
|                                   | optimization, which is covered in |
|                                   | a [later                          |
|                                   | chapter](../C12-CodeOpt/index     |
|                                   | .html#_code_optimization){.page}. |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: sect2
### [](#_registers){.anchor}7.1.1. Registers {#_registers}

::: paragraph
Recall that a **register** is a word-sized storage unit located directly
on the CPU. There may be separate registers for data, instructions, and
addresses. For example, the Intel CPU has a total of 16 registers for
storing 64-bit data:
:::

::: paragraph
`%rax`, `%rbx`, `%rcx`, `%rdx`, `%rdi`, `%rsi`, `%rsp`, `%rbp`, and
`%r8`-`%r15`. All the registers save for `%rsp` and `%rbp` hold
general-purpose 64-bit data. While a program may interpret a register's
contents as, say, an integer or an address, the register itself makes no
distinction. Programs can read from or write to all sixteen registers.
:::

::: paragraph
The registers `%rsp` and `%rbp` are known as the **stack pointer** and
the **frame pointer** (or **base pointer**), respectively. The compiler
reserves these registers for operations that maintain the layout of the
program stack. For example, register `%rsp` always points to the top of
the stack. In earlier x86 systems (e.g., IA32), the frame pointer
commonly tracked the base of the active stack frame and helped to
reference parameters. However, the base pointer is less frequently used
in x86-64 systems. Compilers typically store the first six parameters in
registers `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8` and `%r9`, respectively.
Register `%rax` stores the return value from a function.
:::

::: paragraph
The last register worth mentioning is `%rip` or the **instruction
pointer**, sometimes called the **program counter** (PC). It points to
the next instruction to be executed by the CPU. Unlike the 16 registers
mentioned previously, programs cannot write directly to register `%rip`.
:::
:::

::: sect2
### [](#_advanced_register_notation){.anchor}7.1.2. Advanced Register Notation {#_advanced_register_notation}

::: paragraph
Since x86-64 is an extension of the 32-bit x86 architecture (which
itself was an extension of an earlier 16-bit version), the ISA provides
mechanisms to access the lower 32 bits, 16 bits, and lower bytes of each
register. [Table 1](#RegisterList) lists each of the 16 registers and
the ISA notations to access their component bytes.
:::

+-----------------+-----------------+-----------------+-----------------+
| 64-bit Register | 32-bit Register | Lower 16 Bits   | Lower 8 Bits    |
+=================+=================+=================+=================+
| `%rax`          | `%eax`          | `%ax`           | `%al`           |
+-----------------+-----------------+-----------------+-----------------+
| `%rbx`          | `%ebx`          | `%bx`           | `%bl`           |
+-----------------+-----------------+-----------------+-----------------+
| `%rcx`          | `%ecx`          | `%cx`           | `%cl`           |
+-----------------+-----------------+-----------------+-----------------+
| `%rdx`          | `%edx`          | `%dx`           | `%dl`           |
+-----------------+-----------------+-----------------+-----------------+
| `%rdi`          | `%edi`          | `%di`           | `%dil`          |
+-----------------+-----------------+-----------------+-----------------+
| `%rsi`          | `%esi`          | `%si`           | `%sil`          |
+-----------------+-----------------+-----------------+-----------------+
| `%rsp`          | `%esp`          | `%sp`           | `%spl`          |
+-----------------+-----------------+-----------------+-----------------+
| `%rbp`          | `%ebp`          | `%bp`           | `%bpl`          |
+-----------------+-----------------+-----------------+-----------------+
| `%r8`           | `%r8d`          | `%r8w`          | `%r8b`          |
+-----------------+-----------------+-----------------+-----------------+
| `%r9`           | `%r9d`          | `%r9w`          | `%r9b`          |
+-----------------+-----------------+-----------------+-----------------+
| `%r10`          | `%r10d`         | `%r10w`         | `%r10b`         |
+-----------------+-----------------+-----------------+-----------------+
| `%r11`          | `%r11d`         | `%r11w`         | `%r11b`         |
+-----------------+-----------------+-----------------+-----------------+
| `%r12`          | `%r12d`         | `%r12w`         | `%r12b`         |
+-----------------+-----------------+-----------------+-----------------+
| `%r13`          | `%r13d`         | `%r13w`         | `%r13b`         |
+-----------------+-----------------+-----------------+-----------------+
| `%r14`          | `%r14d`         | `%r14w`         | `%r14b`         |
+-----------------+-----------------+-----------------+-----------------+
| `%r15`          | `%r15d`         | `%r15w`         | `%r15b`         |
+-----------------+-----------------+-----------------+-----------------+

: Table 1. x86-64 Registers and Mechanisms for Accessing Lower Bytes

::: paragraph
The first eight registers (`%rax`, `%rbx`, `%rcx`, `%rdx`, `%rdi`,
`%rsi`, `%rsp`, and `%rbp`) are 64-bit extensions of 32-bit registers in
x86 and have a common mechanism for accessing their lower 32 bits, lower
16 bits, and least-significant byte. To access the lower 32 bits of the
first eight registers, simply replace the `r` in the register name with
`e`. Thus, the register corresponding to the lower 32 bits of register
`%rax` is register `%eax`. To access the lower 16 bits of each of these
eight registers, reference the last two letters of the register's name.
So, the mechanism to access the lower two bytes of register `%rax` is
`%ax`.
:::

::: {#Register .imageblock .text-center}
::: content
![Register %rax's names for accessing a subset of the register's bits.
%eax refers to its lower 32 bits, %ax refers to its lower 16 bits, %al
refers to the low-order byte (bits 0-7), and %ah refers to the second
byte (bits 8-15).](_images/register.png){width="500"}
:::

::: title
Figure 1. The names that refer to subsets of register %rax.
:::
:::

::: paragraph
The ISA provides a separate mechanism to access the eight-bit components
within the lower 16 bits of the first four listed registers. [Figure
1](#Register) depicts the access mechanisms for register `%rax`. The
*higher* and *lower* bytes within the lower 16 bits of the first four
listed registers can be accessed by taking the last two letters of the
register name and replacing the last letter with either an `h` (for
*higher*) or an `l` (for *lower*) depending on which byte is desired.
For example, `%al` references the lower eight-bits of register `%ax`,
whereas `%ah` references the higher eight-bits of register `%ax`. These
eight-bit registers are commonly used for storing single-byte values for
certain operations, such as bitwise shifts (a 32-bit register cannot be
shifted more than 32 places, and the number 32 requires only a single
byte of storage).
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Compiler may choose component     |
|                                   | registers depending on type       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | When reading assembly code, keep  |
|                                   | in mind that the compiler         |
|                                   | typically uses the 64-bit         |
|                                   | registers when dealing with       |
|                                   | 64-bit values (e.g., pointers or  |
|                                   | `long` types) and the 32-bit      |
|                                   | component registers when dealing  |
|                                   | with 32-bit types (e.g., `int`).  |
|                                   | In x86-64, it is very common to   |
|                                   | see 32-bit component registers    |
|                                   | intermixed with the full 64-bit   |
|                                   | registers. For example, in the    |
|                                   | `adder2` function shown in the    |
|                                   | previous example, the compiler    |
|                                   | references component register     |
|                                   | `%eax` instead of `%rax` since    |
|                                   | `int` types typically take up 32  |
|                                   | bits (four bytes) of space on     |
|                                   | 64-bit systems. If the `adder2`   |
|                                   | function had a `long` parameter   |
|                                   | instead of a `int`, the compiler  |
|                                   | would store `a` in register       |
|                                   | `%rax` instead of register        |
|                                   | `%eax`.                           |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
The last eight registers (`%r8`-`%r15`) were not part of the IA32 ISA.
However, they also have mechanisms to access their different byte
components. To access the lower 32 bits, 16 bits, or byte of the last
eight registers, append the letter `d`, `w`, or `b`, respectively, to
the end of the register's name. Thus, `%r9d` accesses the lower 32 bits
of register `%r9`, whereas `%r9w` accesses the lower 16 bits, and `%r9b`
accesses the lowest byte of register `%r9`.
:::
:::

::: sect2
### [](#_instruction_structure){.anchor}7.1.3. Instruction Structure {#_instruction_structure}

::: paragraph
Each instruction consists of an operation code (or **opcode**) that
specifies what it does, and one or more **operands** that tell the
instruction how to do it. For example, the instruction `add $0x2, %eax`
has the opcode `add` and the operands `$0x2` and `%eax`.
:::

::: paragraph
Each operand corresponds to a source or destination location for a
specific operation. Two operand instructions typically follow the
source, destination (`S`, `D`) format, where the first operand specifies
a source register, and the second operand specifies the destination.
:::

::: paragraph
There are multiple types of operands:
:::

::: ulist
-   **Constant (literal)** values are preceded by the `$` sign. For
    example, in the instruction `add $0x2, %eax`, `$0x2` is a literal
    value that corresponds to the hexadecimal value 0x2.

-   **Register** forms refer to individual registers. The instruction
    `mov  %rsp, %rbp` specifies that the value in the source register
    (`%rsp`) should be copied to the destination location (register
    `%rbp`).

-   **Memory** forms correspond to some value inside main memory (RAM)
    and are commonly used for address lookups. Memory address forms can
    contain a combination of registers and constant values. For example,
    in the instruction `mov -0x4(%rbp),%eax`, the operand `-0x4(%rbp)`
    is an example of a memory form. It loosely translates to \"add -0x4
    to the value in register `%rbp` (i.e., subtract 0x4 from `%rbp`),
    and then perform a memory lookup.\" If this sounds like a pointer
    dereference, that's because it is!
:::
:::

::: sect2
### [](#_an_example_with_operands){.anchor}7.1.4. An Example with Operands {#_an_example_with_operands}

::: paragraph
The best way to explain operands in detail is to present a quick
example. Suppose that memory contains the following values:
:::

+-----------------------------------+-----------------------------------+
| Address                           | Value                             |
+===================================+===================================+
| 0x804                             | 0xCA                              |
+-----------------------------------+-----------------------------------+
| 0x808                             | 0xFD                              |
+-----------------------------------+-----------------------------------+
| 0x80c                             | 0x12                              |
+-----------------------------------+-----------------------------------+
| 0x810                             | 0x1E                              |
+-----------------------------------+-----------------------------------+

::: paragraph
Let's also assume that the following registers contain the values shown:
:::

+-----------------------------------+-----------------------------------+
| Register                          | Value                             |
+===================================+===================================+
| %rax                              | 0x804                             |
+-----------------------------------+-----------------------------------+
| %rbx                              | 0x10                              |
+-----------------------------------+-----------------------------------+
| %rcx                              | 0x4                               |
+-----------------------------------+-----------------------------------+
| %rdx                              | 0x1                               |
+-----------------------------------+-----------------------------------+

::: paragraph
Then the operands in [Table 2](#Operands) evaluate to the values shown
there. Each row of the table matches an operand with its form (e.g.,
constant, register, memory), how it is translated, and its value. Note
that the notation M\[x\] in this context denotes the value at the memory
location specified by address x.
:::

+-----------------+-----------------+-----------------+-----------------+
| Operand         | Form            | Translation     | Value           |
+=================+=================+=================+=================+
| %rcx            | Register        | %rcx            | 0x4             |
+-----------------+-----------------+-----------------+-----------------+
| (%rax)          | Memory          | M\[%rax\] or    | 0xCA            |
|                 |                 | M\[0x804\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| \$0x808         | Constant        | 0x808           | 0x808           |
+-----------------+-----------------+-----------------+-----------------+
| 0x808           | Memory          | M\[0x808\]      | 0xFD            |
+-----------------+-----------------+-----------------+-----------------+
| 0x8(%rax)       | Memory          | M\[%rax + 8\]   | 0x12            |
|                 |                 | or M\[0x80c\]   |                 |
+-----------------+-----------------+-----------------+-----------------+
| (%rax, %rcx)    | Memory          | M\[%rax +       | 0xFD            |
|                 |                 | %rcx\] or       |                 |
|                 |                 | M\[0x808\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| 0x4(%rax, %rcx) | Memory          | M\[%rax +       | 0x12            |
|                 |                 | %rcx + 4\] or   |                 |
|                 |                 | M\[0x80c\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| 0x800(,%rdx,4)  | Memory          | M\[0x800 +      | 0xCA            |
|                 |                 | %rdx\*4\] or    |                 |
|                 |                 | M\[0x804\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| (%rax, %rdx, 8) | Memory          | M\[%rax +       | 0x12            |
|                 |                 | %rdx\*8\] or    |                 |
|                 |                 | M\[0x80c\]      |                 |
+-----------------+-----------------+-----------------+-----------------+

: Table 2. Example operands

::: paragraph
In [Table 2](#Operands), the notation `%rcx` indicates the value stored
in register `%rcx`. In contrast, M\[`%rax`\] indicates that the value
inside `%rax` should be treated as an address, and to dereference (look
up) the value at that address. Therefore, the operand `(%rax)`
corresponds to M\[0x804\] which corresponds to the value 0xCA.
:::

::: paragraph
A few important notes before continuing. Although [Table 2](#Operands)
shows many valid operand forms, not all forms can be used
interchangeably in all circumstances. Specifically:
:::

::: ulist
-   Constant forms cannot serve as destination operands.

-   Memory forms cannot serve as *both* the source and destination
    operand in a single instruction.

-   In cases of scaling operations (see the last two operands in [Table
    2](#Operands)), the scaling factor is a third parameter in the
    parentheses. Scaling factors can be one of 1, 2, 4, or 8.
:::

::: paragraph
[Table 2](#Operands) is provided as a reference; however, understanding
key operand forms will help improve the reader's speed in parsing
assembly language.
:::
:::

::: sect2
### [](#_instruction_suffixes){.anchor}7.1.5. Instruction Suffixes {#_instruction_suffixes}

::: paragraph
In several cases in upcoming examples, common and arithmetic
instructions have a suffix that indicates the *size* (associated with
the *type*) of the data being operated on at the code level. The
compiler automatically translates code to instructions with the
appropriate suffix. [Table 3](#Suffixes) shows the common suffixes for
x86-64 instructions.
:::

+----------------------+----------------------+-----------------------+
| Suffix               | C Type               | Size (bytes)          |
+======================+======================+=======================+
| b                    | `char`               | 1                     |
+----------------------+----------------------+-----------------------+
| w                    | `short`              | 2                     |
+----------------------+----------------------+-----------------------+
| l                    | `int` or `unsigned`  | 4                     |
+----------------------+----------------------+-----------------------+
| s                    | `float`              | 4                     |
+----------------------+----------------------+-----------------------+
| q                    | `long`,              | 8                     |
|                      | `unsigned long`, all |                       |
|                      | pointers             |                       |
+----------------------+----------------------+-----------------------+
| d                    | `double`             | 8                     |
+----------------------+----------------------+-----------------------+

: Table 3. Example Instruction Suffixes

::: paragraph
Note that instructions involved with conditional execution have
different suffixes based on the evaluated condition. We cover
instructions associated with conditional execution in a [later
section](conditional_control_loops.html#_conditional_control_and_loops){.page}.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
