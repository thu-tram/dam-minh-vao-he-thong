
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](index.html){.nav-link}
        -   [7.1. Assembly Basics](basics.html){.nav-link}
        -   [7.2. Common Instructions](common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [7.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [7.4.2. If Statements](if_statements.html){.nav-link}
            -   [7.4.3. Loops](loops.html){.nav-link}
        -   [7.5. Functions in Assembly](functions.html){.nav-link}
        -   [7.6. Recursion](recursion.html){.nav-link}
        -   [7.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [7.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [7.9. Structs in Assembly](structs.html){.nav-link}
        -   [7.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [7. 64-bit x86 Assembly](index.html)
-   [7.4. Conditional Control and Loops](conditional_control_loops.html)
-   [7.4.1. Preliminaries](preliminaries.html)
:::

::: content
::: sect2
### [](#_preliminaries){.anchor}7.4.1. Preliminaries {#_preliminaries}

### Conditional Comparison Instructions {#_conditional_comparison_instructions .discrete}

::: paragraph
Comparison instructions perform an arithmetic operation for the purpose
of guiding the conditional execution of a program. [Table
1](#ConditionalControl) lists the basic instructions associated with
conditional control.
:::

+-----------------------------------+-----------------------------------+
| Instruction                       | Translation                       |
+===================================+===================================+
| `cmp R1, R2`                      | Compares R2 with R1 (i.e.,        |
|                                   | evaluates R2 - R1)                |
+-----------------------------------+-----------------------------------+
| `test R1, R2`                     | Computes R1 & R2                  |
+-----------------------------------+-----------------------------------+

: Table 1. Conditional Control Instructions

::: paragraph
The `cmp` instruction compares the values of two registers, R2 and R1.
Specifically, it subtracts R1 from R2. The `test` instruction performs
bitwise AND. It is common to see an instruction like:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
test %rax, %rax
```
:::
:::

::: paragraph
In this example, the bitwise AND of `%rax` with itself is zero only when
`%rax` contains zero. In other words, this is a test for a zero value
and is equivalent to:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
cmp $0, %rax
```
:::
:::

::: paragraph
Unlike the arithmetic instructions covered thus far, `cmp` and `test` do
not modify the destination register. Instead, both instructions modify a
series of single-bit values known as **condition code flags**. For
example, `cmp` will modify condition code flags based on whether the
value R2 - R1 results in a positive (greater), negative (less), or zero
(equal) value. Recall that [condition
code](../C5-Arch/cpu.html#_the_alu){.page} values encode information
about an operation in the ALU. The condition code flags are part of the
`FLAGS` register on x86 systems.
:::

+-----------------------------------+-----------------------------------+
| Flag                              | Translation                       |
+===================================+===================================+
| `ZF`                              | Is equal to zero (1: yes; 0: no)  |
+-----------------------------------+-----------------------------------+
| `SF`                              | Is negative (1: yes; 0: no)       |
+-----------------------------------+-----------------------------------+
| `OF`                              | Overflow has occurred (1:yes; 0:  |
|                                   | no)                               |
+-----------------------------------+-----------------------------------+
| `CF`                              | Arithmetic carry has occurred (1: |
|                                   | yes; 0:no)                        |
+-----------------------------------+-----------------------------------+

: Table 2. Common Condition Code Flags.

::: paragraph
[Table 2](#ConditionFlags) depicts the common flags used for condition
code operations. Revisiting the `cmp R1, R2` instruction:
:::

::: ulist
-   The `ZF` flag is set to 1 if R1 and R2 are equal.

-   The `SF` flag is set to 1 if R2 is *less* than R1 (R2 - R1 results
    in a negative value).

-   The `OF` flag is set to 1 if the operation R2 - R1 results in an
    integer overflow (useful for signed comparisons).

-   The `CF` flag is set to 1 if the operation R2 - R1 results in a
    carry operation (useful for unsigned comparisons).
:::

::: paragraph
The `SF` and `OF` flags are used for comparison operations on signed
integers, whereas the `CF` flag is used for comparisons on unsigned
integers. Although an in-depth discussion of condition code flags is
beyond the scope of this book, the setting of these registers by `cmp`
and `test` enables the next set of instructions we cover (the *jump*
instructions) to operate correctly.
:::

### The Jump Instructions {#_the_jump_instructions .discrete}

::: paragraph
A jump instruction enables a program's execution to \"jump\" to a new
position in the code. In the assembly programs we have traced through
thus far, `%rip` always points to the next instruction in program
memory. The jump instructions enable `%rip` to be set to either a new
instruction not yet seen (as in the case of an `if` statement) or to a
previously executed instruction (as in the case of a loop).
:::

#### Direct jump instructions {#_direct_jump_instructions .discrete}

+-----------------------------------+-----------------------------------+
| Instruction                       | Description                       |
+===================================+===================================+
| `jmp L`                           | Jump to location specified by L   |
+-----------------------------------+-----------------------------------+
| `jmp *addr`                       | Jump to specified address         |
+-----------------------------------+-----------------------------------+

: Table 3. Direct Jump Instructions

::: paragraph
[Table 3](#DirectJmp) lists the set of direct jump instructions; `L`
refers to a **symbolic label**, which serves as an identifier in the
program's object file. All labels consist of some letters and digits
followed by a colon. Labels can be *local* or *global* to an object
file's scope. Function labels tend to be *global* and usually consist of
the function name and a colon. For example, `main:` (or `<main>:`) is
used to label a user-defined `main` function. By convention, labels
whose scope are *local* are typically preceded by a period. One may
encounter a local label with a name like `.L1` in the context of an `if`
statement or loop.
:::

::: paragraph
All labels have an associated address. When the CPU executes a `jmp`
instruction, it modifies `%rip` to reflect the program address specified
by label `L`. A programmer writing assembly can also specify a
particular address to jump to using the `jmp *` instruction. Sometimes,
local labels are shown as an offset from the start of a function.
Therefore, an instruction whose address is 28 bytes away from the start
of `main` may be represented with the label `<main+28>`.
:::

::: paragraph
For example, the instruction `jmp 0x8048427 <main+28>` indicates a jump
to address 0x8048427, which has the associated label `<main+28>`,
representing that it is 28 bytes away from the starting address of the
`main` function. Executing this instruction sets `%rip` to 0x8048427.
:::

#### Conditional jump instructions {#_conditional_jump_instructions .discrete}

::: paragraph
The behavior of conditional jump instructions depends on the condition
code registers set by the `cmp` instruction. [Table 4](#ConditionalJmp)
lists the set of common conditional jump instructions. Each instruction
starts with the letter `j` denoting that it is a jump instruction. The
suffix of each instruction indicates the *condition* for the jump. The
jump instruction suffixes also determine whether to interpret numerical
comparisons as signed or unsigned.
:::

+----------------------+----------------------+-----------------------+
| Signed Comparison    | Unsigned Comparison  | Description           |
+======================+======================+=======================+
| `je` (`jz`)          |                      | jump if equal (==) or |
|                      |                      | jump if zero          |
+----------------------+----------------------+-----------------------+
| `jne` (`jnz`)        |                      | jump if not equal     |
|                      |                      | (!=)                  |
+----------------------+----------------------+-----------------------+
| `js`                 |                      | jump if negative      |
+----------------------+----------------------+-----------------------+
| `jns`                |                      | jump if non-negative  |
+----------------------+----------------------+-----------------------+
| `jg` (`jnle`)        | `ja` (`jnbe`)        | jump if greater (\>)  |
+----------------------+----------------------+-----------------------+
| `jge` (`jnl`)        | `jae` (`jnb`)        | jump if greater than  |
|                      |                      | or equal (\>=)        |
+----------------------+----------------------+-----------------------+
| `jl` (`jnge`)        | `jb` (`jnae`)        | jump if less (\<)     |
+----------------------+----------------------+-----------------------+
| `jle` (`jng`)        | `jbe` (`jna`)        | jump if less than or  |
|                      |                      | equal (\<=)           |
+----------------------+----------------------+-----------------------+

: Table 4. Conditional Jump Instructions; Synonyms Shown in Parentheses

::: paragraph
Instead of memorizing these different conditional jump instructions, it
is more helpful to sound out the instruction suffixes. [Table
5](#JmpSuffixes) lists the letters commonly found in jump instructions
and their word correspondence.
:::

+-----------------------------------+-----------------------------------+
| Letter                            | Word                              |
+===================================+===================================+
| `j`                               | jump                              |
+-----------------------------------+-----------------------------------+
| `n`                               | not                               |
+-----------------------------------+-----------------------------------+
| `e`                               | equal                             |
+-----------------------------------+-----------------------------------+
| `s`                               | signed                            |
+-----------------------------------+-----------------------------------+
| `g`                               | greater (signed interpretation)   |
+-----------------------------------+-----------------------------------+
| `l`                               | less (signed interpretation)      |
+-----------------------------------+-----------------------------------+
| `a`                               | above (unsigned interpretation)   |
+-----------------------------------+-----------------------------------+
| `b`                               | below (unsigned interpretation)   |
+-----------------------------------+-----------------------------------+

: Table 5. Jump Instruction Suffixes.

::: paragraph
Sounding it out, we can see that `jg` corresponds to *jump greater* and
that its signed synonym `jnl` stands for *jump not less*. Likewise, the
unsigned version `ja` stands for *jump above*, whereas its synonym
`jnbe` stands for *jump not below or equal*.
:::

::: paragraph
If you sound out the instructions, it helps to explain why certain
synonyms correspond to particular instructions. The other thing to
remember is that the terms *greater* and *less* instruct the CPU to
interpret the numerical comparison as a signed value, whereas *above*
and *below* indicate that the numerical comparison is unsigned.
:::

### The `goto` Statement {#_the_goto_statement .discrete}

::: paragraph
In the following subsections, we look at conditionals and loops in
assembly and reverse engineer them back to C. When translating assembly
code of conditionals and loops back into C, it is useful to understand
the corresponding C language `goto` forms. The `goto` statement is a C
primitive that forces program execution to switch to another line in the
code. The assembly instruction associated with the `goto` statement is
`jmp`.
:::

::: paragraph
The `goto` statement consists of the `goto` keyword followed by a **goto
label**, a type of program label that indicates where execution should
continue. So, `goto done` means that the program execution should jump
to the line marked by label `done`. Other examples of program labels in
C include the [switch statement
labels](../C2-C_depth/advanced_switch.html#_c_switch_stmt_){.page}
previously covered in Chapter 2.
:::

+-----------------------------------+-----------------------------------+
| Regular C version                 | Goto version                      |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int getSmallest(int x, int y) {   | int getSmallest(int x, int y) {   |
|     int smallest;                 |     int smallest;                 |
|                                   |                                   |
| if ( x > y ) { //if (conditional) |     i                             |
|                                   | f (x <= y ) { //if (!conditional) |
|    smallest = y; //then statement |         goto else_statement;      |
|     }                             |     }                             |
|     else {                        |                                   |
|                                   |    smallest = y; //then statement |
|    smallest = x; //else statement |     goto done;                    |
|     }                             |                                   |
|     return smallest;              | else_statement:                   |
| }                                 |                                   |
| ```                               |    smallest = x; //else statement |
| :::                               |                                   |
| :::                               | done:                             |
| :::                               |     return smallest;              |
|                                   | }                                 |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 6. Comparison of a C function and its associated goto form.

::: paragraph
[Table 6](#CGoTo) depicts a function `getSmallest()` written in regular
C code and its associated `goto` form in C. The `getSmallest()` function
compares the value of two integers (`x` and `y`), and assigns the
smaller value to variable `smallest`.
:::

::: paragraph
The `goto` form of this function may seem counterintuitive, but let's
discuss what exactly is going on. The conditional checks to see whether
variable `x` is less than or equal to `y`.
:::

::: ulist
-   If `x` is less than or equal to `y`, the program transfers control
    to the label marked by `else_statement`, which contains the single
    statement `smallest = x`. Since the program executes linearly, the
    program continues on to execute the code under the label `done`,
    which returns the value of `smallest` (`x`).

-   If `x` is greater than `y`, `smallest` is assigned the value `y`.
    The program then executes the statement `goto done`, which transfers
    control to the `done` label, which returns the value of `smallest`
    (`y`).
:::

::: paragraph
While `goto` statements were commonly used in the early days of
programming, the use of `goto` statements in modern code is considered
bad practice, as it reduces the overall readability of code. In fact,
computer scientist Edsger Dijkstra wrote a famous paper lambasting the
use of `goto` statements called *Go To Statement Considered Harmful*^1^.
:::

::: paragraph
In general, well-designed C programs do not use `goto` statements and
programmers are discouraged from using them to avoid writing code that
is difficult to read, debug, and maintain. However, the C `goto`
statement is important to understand, as GCC typically changes C code
with conditionals into a `goto` form prior to translating it to
assembly, including code that contains `if` statements and loops.
:::

::: paragraph
The following subsections cover the assembly representation of `if`
statements and loops in greater detail.
:::

::: ulist
-   [If
    Statements](if_statements.html#_if_statements_in_assembly){.page}

-   [Loops](loops.html#_loops_in_assembly){.page}
:::

### References {#_references .discrete}

::: {.olist .arabic}
1.  Edsger Dijkstra. \"Go To Statement Considered Harmful\".
    *Communications of the ACM* 11(3) pp. 147---​148. 1968.
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
