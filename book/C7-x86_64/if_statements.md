
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](index.html){.nav-link}
        -   [7.1. Assembly Basics](basics.html){.nav-link}
        -   [7.2. Common Instructions](common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [7.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [7.4.2. If Statements](if_statements.html){.nav-link}
            -   [7.4.3. Loops](loops.html){.nav-link}
        -   [7.5. Functions in Assembly](functions.html){.nav-link}
        -   [7.6. Recursion](recursion.html){.nav-link}
        -   [7.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [7.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [7.9. Structs in Assembly](structs.html){.nav-link}
        -   [7.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [7. 64-bit x86 Assembly](index.html)
-   [7.4. Conditional Control and Loops](conditional_control_loops.html)
-   [7.4.2. If Statements](if_statements.html)
:::

::: content
::: sect2
### [](#_if_statements_in_assembly){.anchor}7.4.2. if Statements in Assembly {#_if_statements_in_assembly}

::: paragraph
Let's take a look at the `getSmallest` function in assembly. For
convenience, the function is reproduced below.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest(int x, int y) {
    int smallest;
    if ( x > y ) {
        smallest = y;
    }
    else {
        smallest = x;
    }
    return smallest;
}
```
:::
:::

::: paragraph
The corresponding assembly code extracted from GDB looks similar to the
following:
:::

::: listingblock
::: content
    (gdb) disas getSmallest
    Dump of assembler code for function getSmallest:
       0x40059a <+4>:   mov    %edi,-0x14(%rbp)
       0x40059d <+7>:   mov    %esi,-0x18(%rbp)
       0x4005a0 <+10>:  mov    -0x14(%rbp),%eax
       0x4005a3 <+13>:  cmp    -0x18(%rbp),%eax
       0x4005a6 <+16>:  jle    0x4005b0 <getSmallest+26>
       0x4005a8 <+18>:  mov    -0x18(%rbp),%eax
       0x4005ae <+24>:  jmp    0x4005b9 <getSmallest+35>
       0x4005b0 <+26>:  mov    -0x14(%rbp),%eax
       0x4005b9 <+35>:  pop    %rbp
       0x4005ba <+36>:  retq
:::
:::

::: paragraph
This is a different view of the assembly code than we have seen before.
Here, we can see the *address* associated with each instruction, but not
the *bytes*. Note that this assembly segment has been lightly edited for
the sake of simplicity. The instructions that are normally part of
function creation (i.e., `push %rbp`, `mov %rsp, %rbp`) are removed. By
convention, GCC places the first and second parameters of a function in
registers `%rdi` and `%rsi`, respectively. Since the parameters to
`getSmallest` are of type `int`, the compiler places the parameters in
the respective component registers `%edi` and `%esi` instead. For the
sake of clarity, we refer to these parameters as `x` and `y`,
respectively.
:::

::: paragraph
Let's trace through the first few lines of the previous assembly code
snippet. Note that we will not draw out the stack explicitly in this
example. We leave this as an exercise for the reader, and encourage you
to practice your stack tracing skills by drawing it out yourself.
:::

::: ulist
-   The first `mov` instruction copies the value located in register
    `%edi` (the first parameter, `x`) and places it at memory location
    `%rbp-0x14` on the call stack. The instruction pointer (`%rip`) is
    set to the address of the next instruction, or 0x40059d.

-   The second `mov` instruction copies the value located in register
    `%esi` (the second parameter, `y`) and places it at memory location
    `%rbp-0x18` on the call stack. The instruction pointer (`%rip`)
    updates to point to the address of the next instruction, or
    0x4005a0.

-   The third `mov` instruction copies `x` to register `%eax`. Register
    `%rip` updates to point to the address of the next instruction in
    sequence.

-   The `cmp` instruction compares the value at location `%rbp-0x18`
    (the second parameter, `y`) to `x` and sets appropriate condition
    code flag registers. Register `%rip` advances to the address of the
    next instruction, or 0x4005a6.

-   The `jle` instruction at address 0x4005a6 indicates that if `x` is
    less than or equal to `y`, the next instruction that should execute
    should be at location `<getSmallest+26>` and that `%rip` should be
    set to address 0x4005b0. Otherwise, `%rip` is set to the next
    instruction in sequence, or 0x4005a8.
:::

::: paragraph
The next instructions to execute depend on whether the program follows
the branch (i.e., executes the jump) at address 0x4005a6. Let's first
suppose that the branch was *not* followed. In this case, `%rip` is set
to 0x4005a8 (i.e., `<getSmallest+18>`) and the following sequence of
instructions executes:
:::

::: ulist
-   The `mov -0x18(%rbp), %eax` instruction at `<getSmallest+18>` copies
    `y` to register `%eax`. Register `%rip` advances to 0x4005ae.

-   The `jmp` instruction at `<getSmallest+24>` sets register `%rip` to
    address 0x4005b9.

-   The last instructions to execute are the `pop %rbp` instruction and
    the `retq` instruction, which cleans up the stack and returns from
    the function call. In this case, `y` is in the return register.
:::

::: paragraph
Now, suppose that the branch was taken at `<getSmallest+16>`. In other
words, the `jle` instruction sets register `%rip` to 0x4005b0
(`<getSmallest+26>`). Then, the next instructions to execute are:
:::

::: ulist
-   The `mov -0x14(%rbp),%eax` instruction at address 0x4005b0 copies
    `x` to register `%eax`. Register `%rip` advances to 0x4005b9.

-   The last instructions that execute are `pop %rbp` and `retq`, which
    clean up the stack and returns the value in the return register. In
    this case, component register `%eax` contains `x`, and `getSmallest`
    returns `x`.
:::

::: paragraph
We can then annotate the preceding assembly as follows:
:::

::: listingblock
::: content
    0x40059a <+4>:  mov %edi,-0x14(%rbp)          # copy x to %rbp-0x14
    0x40059d <+7>:  mov %esi,-0x18(%rbp)          # copy y to %rbp-0x18
    0x4005a0 <+10>: mov -0x14(%rbp),%eax          # copy x to %eax
    0x4005a3 <+13>: cmp -0x18(%rbp),%eax          # compare x with y
    0x4005a6 <+16>: jle 0x4005b0 <getSmallest+26> # if x<=y goto <getSmallest+26>
    0x4005a8 <+18>: mov -0x18(%rbp),%eax          # copy y to %eax
    0x4005ae <+24>: jmp 0x4005b9 <getSmallest+35> # goto <getSmallest+35>
    0x4005b0 <+26>: mov -0x14(%rbp),%eax          # copy x to %eax
    0x4005b9 <+35>: pop %rbp                      # restore %rbp (clean up stack)
    0x4005ba <+36>: retq                          # exit function (return %eax)
:::
:::

::: paragraph
Translating this back to C code yields:
:::

+-----------------------------------+-----------------------------------+
| goto Form                         | Translated C code                 |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int getSmallest(int x, int y) {   | int getSmallest(int x, int y) {   |
|     int smallest;                 |     int smallest;                 |
|     if (x <= y) {                 |     if (x <= y) {                 |
|         goto assign_x;            |         smallest = x;             |
|     }                             |     }                             |
|     smallest = y;                 |     else {                        |
|     goto done;                    |         smallest = y;             |
|                                   |     }                             |
| assign_x:                         |     return smallest;              |
|     smallest = x;                 | }                                 |
|                                   | ```                               |
| done:                             | :::                               |
|     return smallest;              | :::                               |
| }                                 | :::                               |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 1. Translating `getSmallest()` into goto C form and C code.

::: paragraph
In [Table 1](#TranslateSmallest), the variable `smallest` corresponds to
register `%eax`. If `x` is less than or equal to `y`, the code executes
the statement `smallest = x`, which is associated with the `goto` label
`assign_x` in our `goto` form of this function. Otherwise, the statement
`smallest = y` is executed. The `goto` label `done` is used to indicate
that the value in `smallest` should be returned.
:::

::: paragraph
Notice that the preceding C translation of the assembly code is a bit
different from the original `getSmallest` function. These differences
don't matter; close inspection of both functions reveals that the two
programs are logically equivalent. However, the compiler first converts
any `if` statement into an equivalent `goto` form, which results in the
slightly different, but equivalent, version. [Table 2](#StandardGotoIf)
shows the standard `if` statement format and its equivalent `goto` form:
:::

+-----------------------------------+-----------------------------------+
| C if statement                    | Compiler's equivalent goto form   |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| if (condition) {                  |     if (!condition) {             |
|     then_statement;               |         goto else;                |
| }                                 |     }                             |
| else {                            |     then_statement;               |
|     else_statement;               |     goto done;                    |
| }                                 | else:                             |
| ```                               |     else_statement;               |
| :::                               | done:                             |
| :::                               | ```                               |
| :::                               | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 2. Standard if statement format and its equivalent goto form.

::: paragraph
Compilers translating code into assembly designate a jump when a
condition is true. Contrast this behavior with the structure of an `if`
statement, where a \"jump\" (to the `else`) occurs when conditions are
*not* true. The `goto` form captures this difference in logic.
:::

::: paragraph
Considering the original `goto` translation of the `getSmallest`
function, we can see that:
:::

::: ulist
-   `x <= y` corresponds to `!condition`.

-   `smallest = x` is the `else_statement`.

-   The line `smallest = y` is the `then_statement`.

-   The last line in the function is `return smallest`.
:::

::: paragraph
Rewriting the original version of the function with the preceding
annotations yields:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest(int x, int y) {
    int smallest;
    if (x > y) {     //!(x <= y)
        smallest = y; //then_statement
    }
    else {
        smallest = x; //else_statement
    }
    return smallest;
}
```
:::
:::

::: paragraph
This version is identical to the original `getSmallest` function. Keep
in mind that a function written in different ways at the C code level
can translate to the same set of assembly instructions.
:::

::: sect3
#### [](#_the_cmov_instructions){.anchor}The cmov Instructions {#_the_cmov_instructions}

::: paragraph
The last set of conditional instructions we cover are **conditional
move** (`cmov`) instructions. The `cmp`, `test`, and `jmp` instructions
implement a *conditional transfer of control* in a program. In other
words, the execution of the program branches in many directions. This
can be very problematic for optimizing code, because these branches are
very expensive.
:::

::: paragraph
In contrast, the `cmov` instruction implements a *conditional transfer
of data*. In other words, both the `then_statement` and `else_statement`
of the conditional are executed, and the data is placed in the
appropriate register based on the result of the condition.
:::

::: paragraph
The use of C's **ternary expression** often results in the compiler
generating a `cmov` instruction in place of jumps. For the standard
if-then-else statement, the ternary expression has the form:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
result = (condition) ? then_statement : else_statement;
```
:::
:::

::: paragraph
Let's use this format to rewrite the `getSmallest` function as a ternary
expression. Keep in mind that this new version of the function behaves
exactly as the original `getSmallest` function:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest_cmov(int x, int y) {
    return x > y ? y : x;
}
```
:::
:::

::: paragraph
Although this may not seem like a big change, let's look at the
resulting assembly. Recall that the first and second parameters (`x` and
`y`) are stored in registers `%edi` and `%esi`, respectively.
:::

::: listingblock
::: content
    0x4005d7 <+0>:   push   %rbp             #save %rbp
    0x4005d8 <+1>:   mov    %rsp,%rbp        #update %rbp
    0x4005db <+4>:   mov    %edi,-0x4(%rbp)  #copy x to %rbp-0x4
    0x4005de <+7>:   mov    %esi,-0x8(%rbp)  #copy y to %rbp-0x8
    0x4005e1 <+10>:  mov    -0x8(%rbp),%eax  #copy y to %eax
    0x4005e4 <+13>:  cmp    %eax,-0x4(%rbp)  #compare x and y
    0x4005e7 <+16>:  cmovle -0x4(%rbp),%eax  #if (x <=y) copy x to %eax
    0x4005eb <+20>:  pop    %rbp             #restore %rbp
    0x4005ec <+21>:  retq                    #return %eax
:::
:::

::: paragraph
This assembly code has no jumps. After the comparison of `x` and `y`,
`x` moves into the return register only if `x` is less than or equal to
`y`. Like the jump instructions, the suffix of the `cmov` instructions
indicates the condition on which the conditional move occurs. [Table
3](#CmovInstr) lists the set of conditional move instructions.
:::

+----------------------+----------------------+-----------------------+
| Signed               | Unsigned             | Description           |
+======================+======================+=======================+
| `cmove` (`cmovz`)    |                      | move if equal (==)    |
+----------------------+----------------------+-----------------------+
| `cmovne` (`cmovnz`)  |                      | move if not equal     |
|                      |                      | (!=)                  |
+----------------------+----------------------+-----------------------+
| `cmovs`              |                      | move if negative      |
+----------------------+----------------------+-----------------------+
| `cmovns`             |                      | move if non-negative  |
+----------------------+----------------------+-----------------------+
| `cmovg` (`cmovnle`)  | `cmova` (`cmovnbe`)  | move if greater (\>)  |
+----------------------+----------------------+-----------------------+
| `cmovge` (`cmovnl`)  | `cmovae` (`cmovnb`)  | move if greater than  |
|                      |                      | or equal (\>=)        |
+----------------------+----------------------+-----------------------+
| `cmovl` (`cmovnge`)  | `cmovb` (`cmovnae`)  | move if less (\<)     |
+----------------------+----------------------+-----------------------+
| `cmovle` (`cmovng`)  | `cmovbe` (`cmovna`)  | move if less than or  |
|                      |                      | equal (\<=)           |
+----------------------+----------------------+-----------------------+

: Table 3. The cmov Instructions.

::: paragraph
In the case of the original `getSmallest` function, the compiler's
internal optimizer (see chapter 12) will replace the jump instructions
with a `cmov` instruction if level 1 optimizations are turned on (i.e.,
`-O1`):
:::

::: listingblock
::: content
    #compiled with: gcc -O1 -o getSmallest getSmallest.c
    <getSmallest>:
       0x400546 <+0>: cmp    %esi,%edi      #compare x and y
       0x400548 <+2>: mov    %esi,%eax      #copy y to %eax
       0x40054a <+4>: cmovle %edi,%eax      #if (x<=y) copy x to %eax
       0x40054d <+7>: retq                  #return %eax
:::
:::

::: paragraph
In general, the compiler is very cautious about optimizing jump
instructions into `cmov` instructions, especially in cases where side
effects and pointer values are involved. [Table 4](#incrementX) shows
two equivalent ways of writing a function, `incrementX`:
:::

+-----------------------------------+-----------------------------------+
| C code                            | C ternary form                    |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int incrementX(int *x) {          | int incrementX2(int *x){          |
|     if                            |     return x ? (*x)++ : 1;        |
|  (x != NULL) { //if x is not NULL | }                                 |
|                                   | ```                               |
|      return (*x)++; //increment x | :::                               |
|     }                             | :::                               |
|     else { //if x is NULL         | :::                               |
|         return 1; //return 1      |                                   |
|     }                             |                                   |
| }                                 |                                   |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 4. Two functions that attempt to increment the value of integer
`x`.

::: paragraph
Each function takes a pointer to an integer as input and checks if it is
`NULL`. If `x` is not `NULL`, the function increments and returns the
dereferenced value of `x`. Otherwise, the function returns the value 1.
:::

::: paragraph
It is tempting to think that `incrementX2` uses a `cmov` instruction
since it uses a ternary expression. However, both functions yield the
exact same assembly code:
:::

::: listingblock
::: content
    0x4005ed <+0>:   push   %rbp
    0x4005ee <+1>:   mov    %rsp,%rbp
    0x4005f1 <+4>:   mov    %rdi,-0x8(%rbp)
    0x4005f5 <+8>:   cmpq   $0x0,-0x8(%rbp)
    0x4005fa <+13>:  je     0x40060d <incrementX+32>
    0x4005fc <+15>:  mov    -0x8(%rbp),%rax
    0x400600 <+19>:  mov    (%rax),%eax
    0x400602 <+21>:  lea    0x1(%rax),%ecx
    0x400605 <+24>:  mov    -0x8(%rbp),%rdx
    0x400609 <+28>:  mov    %ecx,(%rdx)
    0x40060b <+30>:  jmp    0x400612 <incrementX+37>
    0x40060d <+32>:  mov    $0x1,%eax
    0x400612 <+37>:  pop    %rbp
    0x400613 <+38>:  retq
:::
:::

::: paragraph
Recall that the `cmov` instruction *executes both branches of the
conditional*. In other words, `x` gets dereferenced no matter what.
Consider the case where `x` is a null pointer. Recall that dereferencing
a null pointer leads to a null pointer exception in the code, causing a
segmentation fault. To prevent any chance of this happening, the
compiler takes the safe road and uses jumps.
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
