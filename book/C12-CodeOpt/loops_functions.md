
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](index.html){.nav-link}
        -   [12.1. First Steps](basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](memory_considerations.html){.nav-link}
        -   [12.4. Summary](summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [12. Code Optimization](index.html)
-   [12.2. Other Compiler Optimizations](loops_functions.html)
:::

::: content
::: sect1
## [](#_other_compiler_optimizations_loop_unrolling_and_function_inlining){.anchor}12.2. Other Compiler Optimizations: Loop Unrolling and Function Inlining {#_other_compiler_optimizations_loop_unrolling_and_function_inlining}

::: sectionbody
::: paragraph
The loop-invariant code motion optimization described in the previous
section was a simple change that resulted in a massive reduction in
execution time. However, such optimizations are situationally dependent,
and may not always result in improvements to performance. In most cases,
loop-invariant code motion is taken care of by the compiler.
:::

::: paragraph
Code today is more often read than it is written. In most cases,
fractional performance gains are not worth the hit to code readability.
In general, a programmer should let the compiler optimize whenever
possible. In this section, we cover some optimization techniques that
were previously manually implemented by programmers but are today
commonly implemented by compilers.
:::

::: paragraph
There are several sources online that advocate for the manual
implementation of the techniques we describe in the following sections.
However, we encourage readers to check whether their compilers support
the following optimizations before attempting to manually implement them
in their code. All the optimizations described in this section are
implemented in GCC, but may not be available in older compilers.
:::

::: sect2
### [](#_function_inlining){.anchor}12.2.1. Function Inlining {#_function_inlining}

::: paragraph
One optimization step that compilers attempt to perform is **function
inlining**, which replaces calls to a function with the body of the
function. For example, in the `main` function, a compiler inlining the
`allocateArray` function will replace the call to `allocateArray` with a
direct call to `malloc`:
:::

+-----------------------------------+-----------------------------------+
| Original Version                  | Version with `allocateArray`      |
|                                   | in-lined                          |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int main(int argc, char **argv) { | int main(int argc, char **argv) { |
|     // omitted for brevity        |     // omitted for brevity        |
|     // some variables s           |     // some variables s           |
| hortened for space considerations | hortened for space considerations |
|     int                           |     int                           |
|  lim = strtol(argv[1], NULL, 10); |  lim = strtol(argv[1], NULL, 10); |
|                                   |                                   |
|     // allocation of array        |                                   |
|     int *a = allocateArray(lim);  | // allocation of array (in-lined) |
|                                   |     in                            |
|                                   | t *a = malloc(lim * sizeof(int)); |
|   // generates sequence of primes |                                   |
|     in                            |                                   |
| t len = genPrimeSequence(a, lim); |   // generates sequence of primes |
|                                   |     in                            |
|     return 0;                     | t len = genPrimeSequence(a, lim); |
| }                                 |                                   |
| ```                               |     return 0;                     |
| :::                               | }                                 |
| :::                               | ```                               |
| :::                               | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 1. Example of compiler inlining the `allocateArray` function.

::: paragraph
Inlining functions can result in some runtime savings for a program.
Recall that every time a program calls a function, many instructions
associated with function creation and destruction are necessarily
generated. Inlining functions enables the compiler to eliminate these
excessive calls, and makes it easier for the compiler to identify other
potential improvements, including constant propagation, constant
folding, and dead code elimination. In the case of the `optExample`
program, inlining likely allows the compiler to replace the call to
`sqrt` with the `fsqrt` instruction, and subsequently move it outside
the loop.
:::

::: paragraph
The `-finline-functions` flag suggests to GCC that functions should be
inlined. This optimization is turned on at level 3. Even though
`-finline-functions` can be used independently of the `-O3` flag, it is
a *suggestion* to the compiler to look for functions to inline.
Likewise, the `static inline` keyword can be used to suggest to the
compiler that a particular function should be inlined. Keep in mind that
the compiler will not inline all functions, and that function inlining
is not guaranteed to make code faster.
:::

::: paragraph
Programmers should generally avoid inlining functions manually. Inlining
functions carries a high risk of significantly reducing the readability
of code, increasing the likelihood of errors, and making it harder to
update and maintain functions. For example, trying to inline the
`isPrime` function in the `getNextPrime` function will greatly reduce
the readability of `getNextPrime`.
:::
:::

::: sect2
### [](#_loop_unrolling){.anchor}12.2.2. Loop Unrolling {#_loop_unrolling}

::: paragraph
The last compiler optimization strategy we discuss in this section is
loop unrolling. Let's revisit the `isPrime` function:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// helper function: checks to see if a number is prime
int isPrime(int x) {
    int i;
    int max = sqrt(x) + 1;

    // no prime number is less than 2
    for (i = 2; i < max; i++) {
        // if the number is divisible by i
        if (x % i == 0) {
            return 0; // it's not prime
        }
    }
    return 1; // otherwise it is
}
```
:::
:::

::: paragraph
The `for` loop executes a total of `max` times, where `max` is one more
than the square root of integer `x`. At the assembly level, every
execution of the loop checks to see whether `i` is less than `max`. If
so, the instruction pointer jumps to the body of the loop, which
computes the modulo operation. If the modulo operation results in 0, the
program immediately exits the loop and returns 0. Otherwise, the loop
continues execution. While branch predictors are fairly good at
predicting what a conditional expression evaluates to (especially inside
loops), wrong guesses can result in a hit to performance, due to
disruptions in the instruction pipeline.
:::

::: paragraph
**Loop unrolling** is an optimization that compilers perform to reduce
the impact of wrong guesses. In loop unrolling, the goal is to reduce
the number of iterations of a loop by a factor of *n* by increasing the
workload that each iteration performs by a factor of *n*. When a loop is
unrolled by a factor of 2, the number of iterations in the loop is cut
by *half*, whereas the amount work performed per iteration is *doubled*.
:::

::: paragraph
Let's manually apply 2-factor loop unrolling to our `isPrime` function
(available in [optExample3.c](_attachments/optExample3.c)):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// helper function: checks to see if a number is prime
int isPrime(int x) {
    int i;
    int max = sqrt(x)+1;

    // no prime number is less than 2
    for (i = 2; i < max; i+=2) {
        // if the number is divisible by i or i+1
        if ( (x % i == 0) || (x % (i+1) == 0) ) {
            return 0; // it's not prime
        }
    }
    return 1; // otherwise it is
}
```
:::
:::

::: paragraph
Notice that even though we have halved the number of iterations that the
`for` loop takes, each iteration of the loop now performs two modulo
checks, doubling the amount of work per iteration. Recompiling and
rerunning the program results in marginally improved times (see [Table
2](#NextTimes)). The readability of the code is also reduced. A better
way to utilize loop unrolling is to invoke the `-funroll-loops` compiler
optimization flag, which tells the compiler to unroll loops whose
iterations can be determined at compile time. The `-funroll-all-loops`
compiler flag is a more aggressive option that unrolls all loops whether
or not the compiler is certain of the number of iterations. [Table
2](#NextTimes) shows the runtimes of the manual 2-factor loop unrolling
(available in `optExample3.c`) compared to adding the `-funroll-loops`
and `-funroll-all-loops` compiler optimization flags to the previous
program ([optExample2.c](_attachments/optExample2.c)).
:::

+-------------+-------------+-------------+-------------+-------------+
| Version     | Unoptimized | `-O1`       | `-O2`       | `-O3`       |
+=============+=============+=============+=============+=============+
| Original    | 3.86        | 2.32        | 2.14        | 2.15        |
| ([optExamp  |             |             |             |             |
| le.c](_atta |             |             |             |             |
| chments/opt |             |             |             |             |
| Example.c)) |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| With        | 1.83        | 1.63        | 1.71        | 1.63        |
| loo         |             |             |             |             |
| p-invariant |             |             |             |             |
| code motion |             |             |             |             |
| (           |             |             |             |             |
| [optExample |             |             |             |             |
| 2.c](_attac |             |             |             |             |
| hments/optE |             |             |             |             |
| xample2.c)) |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| With manual | 1.65        | 1.53        | 1.45        | 1.45        |
| 2-factor    |             |             |             |             |
| loop        |             |             |             |             |
| unrolling   |             |             |             |             |
| (           |             |             |             |             |
| [optExample |             |             |             |             |
| 3.c](_attac |             |             |             |             |
| hments/optE |             |             |             |             |
| xample3.c)) |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| With        | 1.82        | 1.48        | 1.46        | 1.46        |
| `-fun       |             |             |             |             |
| roll-loops` |             |             |             |             |
| (           |             |             |             |             |
| [optExample |             |             |             |             |
| 2.c](_attac |             |             |             |             |
| hments/optE |             |             |             |             |
| xample2.c)) |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| With        | 1.81        | 1.47        | 1.47        | 1.46        |
| `-funroll   |             |             |             |             |
| -all-loops` |             |             |             |             |
| (           |             |             |             |             |
| [optExample |             |             |             |             |
| 2.c](_attac |             |             |             |             |
| hments/optE |             |             |             |             |
| xample2.c)) |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+

: Table 2. Time in Seconds to Produce 5,000,000 Prime Numbers

::: paragraph
While manual loop unrolling does result in some performance improvement,
the compiler's built-in loop unrolling flags when combined with the
other optimization flags yield comparable performance. If a programmer
wants to incorporate loop unrolling optimizations into their code, they
should default to using the appropriate compiler flags, and *not*
manually unroll loops themselves.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
