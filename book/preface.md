
### [Dive Into Systems](index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](index-2.html){.nav-link}
        -   [Copyright](copyright.html){.nav-link}
        -   [Acknowledgements](acknowledgements.html){.nav-link}
        -   [Preface](preface.html){.nav-link}
    -   [0. Introduction](introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful C](C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](C3-C_debug/summary.html){.nav-link}

-   -   [4. Binary and Data
        Representation](C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common Instructions](C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in Assembly](C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](C8-IA32/basics.html){.nav-link}
        -   [8.2. Common Instructions](C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in Assembly](C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common Instructions](C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in Assembly](C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in Assembly](C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3. Locality](C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared Memory](C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](Appendix2/timing.html){.nav-link}
        -   [17.11 Command History](Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](Appendix2/sysinfo.html){.nav-link}
:::

::: {.nav-panel-explore panel="explore"}
::: context
[Dive Into Systems]{.title} [1.2]{.version}
:::

-   [Dive Into Systems]{.title}
    -   [1.2](index-2.html)
:::
:::
:::

::: {.article role="main"}
::: {.toolbar role="navigation"}
[](index-2.html){.home-link}

-   Dive Into Systems
-   [Preface](preface.html)
:::

::: content
# Preface {#preface .page}

::: paragraph
In today's world, much emphasis is placed on learning to code, and
programming is touted as a golden ticket to a successful life. Despite
all the code boot camps and programming being taught in elementary
schools, the computer itself is often treated as an
afterthought --- it's increasingly becoming invisible in the discussions
of raising the next generations of computer scientists.
:::

::: paragraph
The purpose of this book is to give readers a gentle yet accessible
introduction to computer systems. To write effective programs,
programmers must understand a computer's underlying subsystems and
architecture. However, the expense of modern textbooks often limits
their availability to the set of students that can afford them. This
free online textbook seeks to make computer systems concepts accessible
to everyone. It is targeted toward students with an introductory
knowledge of computer science who have some familiarity with Python. If
you're looking for a free book to introduce you to basic computing
principles in Python, we encourage you to read [*How To Think Like a
Computer Scientist with
Python*](https://runestone.academy/ns/books/published/thinkcspy/index.html)
first.
:::

::: paragraph
If you're ready to proceed, please come in --- the water is warm!
:::

## What This Book Is About {#_what_this_book_is_about .discrete}

::: paragraph
Our book is titled *Dive into Systems* and is meant to be a gentle
introduction to topics in computer systems, including C programming,
architecture fundamentals, assembly language, and multithreading. The
ocean metaphor is very fitting for computer systems. As modern life is
thought to have risen from the depths of the primordial ocean, so has
modern programming risen from the design and construction of early
computer architecture. The first programmers studied the hardware
diagrams of the first computers to create the first programs.
:::

::: paragraph
Yet as life (and computing) began to wander away from the oceans from
which they emerged, the ocean began to be perceived as a foreboding and
dangerous place, inhabited by monsters. Ancient navigators used to place
pictures of sea monsters and other mythical creatures in the uncharted
waters. *Here be dragons*, the text would warn. Likewise, as computing
has wandered ever further away from its machine-level origins, computer
systems topics have often emerged as personal dragons for many computing
students.
:::

::: paragraph
In writing this book, we hope to encourage students to take a gentle
dive into computer systems topics. Even though the sea may look like a
dark and dangerous place from above, there is a beautiful and remarkable
world to be discovered for those who choose to peer just below the
surface. So too can a student gain a greater appreciation for computing
by looking below the code and examining the architectural reef below.
:::

::: paragraph
We are not trying to throw you into the open ocean here. Our book
assumes only a CS1 knowledge and is designed to be a first exposure to
many computer systems topics. We cover topics such as C programming,
logic gates, binary, assembly, the memory hierarchy, threading, and
parallelism. Our chapters are written to be as independent as possible,
with the goal of being widely applicable to a broad range of courses.
:::

::: paragraph
Lastly, a major goal for us writing this book is for it to be freely
available. We want our book to be a living document, peer reviewed by
the computing community, and evolving as our field continues to evolve.
If you have feedback for us, please drop us a line. We would love to
hear from you!
:::

## Ways to Use This Book {#_ways_to_use_this_book .discrete}

::: paragraph
Our textbook covers a broad range of topics related to computer systems,
specifically targeting intermediate-level courses such as introduction
to computer systems or computer organization. It can also be used to
provide background reading for upper-level courses such as operating
systems, compilers, parallel and distributed computing, and computer
architecture.
:::

::: paragraph
This textbook is not designed to provide complete coverage of all
systems topics. It does not include advanced or full coverage of
operating systems, computer architecture, or parallel and distributed
computing topics, nor is it designed to be used in place of textbooks
devoted to advanced coverage of these topics in upper-level courses.
Instead, it focuses on introducing computer systems, common themes in
systems in the context of understanding how a computer runs a program,
and how to design programs to run efficiently on systems. The topic
coverage provides a common knowledge base and skill set for more
advanced study in systems topics.
:::

::: paragraph
Our book's topics can be viewed as a vertical slice through a computer.
At the lowest layer we discuss binary representation of programs and
circuits designed to store and execute programs, building up a simple
CPU from basic gates that can execute program instructions. At the next
layer we introduce the operating system, focusing on its support for
running programs and for managing computer hardware, particularly on the
mechanisms of implementing multiprogramming and virtual memory support.
At the highest layer, we present the C programming language and how it
maps to low-level code, how to design efficient code, compiler
optimizations, and parallel computing. A reader of the entire book will
gain a basic understanding of how a program written in C (and Pthreads)
executes on a computer and, based on this understanding, will know some
ways in which they can change the structure of their program to improve
its performance.
:::

::: paragraph
Although as a whole the book provides a vertical slice through the
computer, the book chapters are written as independently as possible so
that an instructor can mix and match chapters for their particular
needs. The chapter dependency graph is shown below, though individual
sections within chapters may not have as deep a dependency hierarchy as
the entire chapter.
:::

::: {.imageblock .text-center}
::: content
![Chapters 1 and 4 are independent of other chapters. Chapters 2, 3, 5,
and 6-10 depend on chapter 1. Chapters 5 and 13 additionally depend on
chapter 4. The remaining chapters depend on a combination of the above
chapters.](_images/chaptdeps.png){width="600"}
:::
:::

### Summary of Chapter Topics {#_summary_of_chapter_topics .discrete}

::: ulist
-   Chapter 0, *Introduction*: Introduction to computer systems and some
    tips for reading this book.

-   Chapter 1, *Introduction to C Programming*: Covers C programming
    basics, including compiling and running C programs. We assume
    readers of this book have had an introduction to programming in some
    programming language. We compare example C syntax to Python syntax
    so that readers familiar with Python can see how they may translate.
    However, Python programming experience is not necessary for reading
    or understanding this chapter.

-   Chapter 2, *A Deeper Dive into C*: Covers most of the C language,
    notably pointers and dynamic memory. We also elaborate on topics
    from Chapter 1 in more detail and discuss some advanced C features.

-   Chapter 3, *C Debugging Tools*: Covers common C debugging tools (GDB
    and Valgrind) and illustrates how they can be used to debug a
    variety of applications.

-   Chapter 4, *Binary and Data Representation*: Covers encoding data
    into binary, binary representation of C types, arithmetic operations
    on binary data, and arithmetic overflow.

-   Chapter 5, *Gates, Circuits, and Computer Architecture*: Covers the
    von Neumann architecture from logic gates to the construction of a
    basic CPU. We characterize clock-driven execution and the stages of
    instruction execution though arithmetic, storage, and control
    circuits. We also briefly introduce pipelining, some modern
    architecture features, and a short history of computer architecture.

-   Chapters 6-10, *Assembly Programming*: Covers translating C into
    assembly code from basic arithmetic expressions to functions, the
    stack, and array and `struct` access. In three separate chapters we
    cover assembly from three different instruction set architectures:
    32-bit x86, 64-bit x86, and 64-bit ARM.

-   Chapter 11, *Storage and the Memory Hierarchy*: Covers storage
    devices, the memory hierarchy and its effects on program
    performance, locality, caching, and the Cachegrind profiling tool.

-   Chapter 12, *Code Optimization*: Covers compiler optimizations,
    designing programs with performance in mind, tips for code
    optimization, and quantitatively measuring a program's performance.

-   Chapter 13, *Operating Systems*: Covers core operating system
    abstractions and the mechanisms behind them. We primarily focus on
    processes, virtual memory, and interprocess communication (IPC).

-   Chapter 14, *Shared Memory Parallelism*: Covers multicore
    processors, threads and Pthreads programming, synchronization, race
    conditions, and deadlock. This chapter includes some advanced topics
    on measuring parallel performance (speed-up, efficiency, Amdahl's
    law), thread safety, and cache coherence.

-   Chapter 15, *Advanced Parallel Systems and Programming Models*:
    Introduces the basics of distributed memory systems and the Message
    Passing Interface (MPI), hardware accelerators and CUDA, and cloud
    computing and MapReduce.
:::

### Example Uses of This Book {#_example_uses_of_this_book .discrete}

::: paragraph
*Dive into Systems* can be used as a primary textbook for courses that
introduce computer systems topics, or individual chapters can be used to
provide background information in courses that cover topics in more
depth.
:::

::: paragraph
As examples from the authors\' two institutions, we have been using it
as the primary textbook for two different intermediate-level courses:
:::

::: ulist
-   *Introduction To Computer Systems* at Swarthmore College. Chapter
    ordering: 4, 1 (some 3), 5, 6, 7, 10, 2 (more 3), 11, 13, 14.

-   *Computer Organization* at West Point. Chapter ordering: 1, 4, 2
    (some 3), 6, 7, 10, 11, 12, 13, 14, 15.
:::

::: paragraph
Additionally, we use individual chapters as background reading in many
of our upper-level courses, including:
:::

+-----------------------------------+-----------------------------------+
| Upper-level Course Topic          | Chapters for Background Readings  |
+===================================+===================================+
| Architecture                      | 5, 11                             |
+-----------------------------------+-----------------------------------+
| Compilers                         | 6, 7, 8, 9, 10, 11, 12            |
+-----------------------------------+-----------------------------------+
| Database Systems                  | 11, 14, 15                        |
+-----------------------------------+-----------------------------------+
| Networking                        | 4, 13, 14                         |
+-----------------------------------+-----------------------------------+
| Operating Systems                 | 11, 13, 14                        |
+-----------------------------------+-----------------------------------+
| Parallel and Distributed Systems  | 11, 13, 14, 15                    |
+-----------------------------------+-----------------------------------+

::: paragraph
Finally, Chapters 2 and 3 are used as C programming and debugging
references in many of our courses.
:::

### Available Online {#_available_online .discrete}

::: paragraph
The free online version of our textbook is available at
[https://diveintosystems.org/](https://diveintosystems.org/){.bare}.
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
