
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](../C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](../C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](../C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](../C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](../C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](../C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](../C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](../C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](../C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](../C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](../C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](../C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](../C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](../C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](../C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](../C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](../C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](../C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](../C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](index.html){.nav-link}
        -   [3.1. Debugging with GDB](gdb.html){.nav-link}
        -   [3.2. GDB Commands in Detail](gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](valgrind.html){.nav-link}
        -   [3.4. Advanced GDB Features](gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly Code](gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [3. C Debugging Tools](index.html)
-   [3.1. Debugging with GDB](gdb.html)
:::

::: content
::: sect1
## [](#_debugging_with_gdb){.anchor}3.1. Debugging with GDB {#_debugging_with_gdb}

::: sectionbody
::: paragraph
[GDB](https://www.gnu.org/software/gdb/) can help programmers find and
fix bugs in their programs. GDB works with programs compiled in a
variety of languages, but we focus on C here. A debugger is a program
that controls the execution of another program (the program being
debugged) --- it allows programmers to see what their programs are doing
as they run. Using a debugger can help programmers discover bugs and
determine the causes of the bugs they find. Here are some useful actions
that GDB can perform:
:::

::: ulist
-   Start a program and step through it line by line

-   Pause the execution of a program when it reaches certain points in
    its code

-   Pause the execution of a program on user-specified conditions

-   Show the values of variables at the point in execution that a
    program is paused

-   Continue a program's execution after a pause

-   Examine the program's execution state at the point when it crashes

-   Examine the contents of any stack frame on the call stack
:::

::: paragraph
GDB users typically set **breakpoints** in their programs. A breakpoint
specifies a point in the program where GDB will pause the program's
execution. When the executing program hits a breakpoint, GDB pauses its
execution and allows the user to enter GDB commands to examine program
variables and stack contents, step through the execution of the program
one line at a time, add new breakpoints, and continue the program's
execution until it hits the next breakpoint.
:::

::: paragraph
Many Unix systems also provide the [Data Display Debugger
(DDD)](https://www.gnu.org/software/ddd/), an easy-to-use GUI wrapper
around a command-line debugger program (GDB, for example). The DDD
program accepts the same parameters and commands as GDB, but it provides
a GUI interface with debugging menu options as well as the command line
interface to GDB.
:::

::: paragraph
After discussing a few preliminaries about how to [get started with
GDB](#_getting_started_with_gdb), we present two example GDB debugging
sessions that introduce commonly used GDB commands in the context of
finding different types of bugs. The first session ([GDB on
badprog.c](#_example_gdb_sessions)), shows how to use GDB commands to
find logic bugs in a C program. The second session ([GDB on
segfaulter.c](#_segfaulter_)) shows an example of using GDB commands to
examine the program execution state at the point when a program crashes
in order to discover the cause of the crash.
:::

::: paragraph
In the [common GDB
commands](gdb_commands.html#_common_gdb_commands){.page} section, we
describe commonly used GDB commands in more detail, showing more
examples of some commands. In later sections, we discuss some advanced
GDB features.
:::

::: sect2
### [](#_getting_started_with_gdb){.anchor}3.1.1. Getting Started with GDB {#_getting_started_with_gdb}

::: paragraph
When debugging a program, it helps to compile it with the `-g` option,
which adds extra debugging information to the binary executable file.
This extra information helps the debugger find program variables and
functions in the binary executable and enables it to map machine code
instructions to lines of C source code (the form of the program that the
C programmer understands). Also, when compiling for debugging, avoid
compiler optimizations (for example, do not build with `-O2`).
Compiler-optimized code is often very difficult to debug because
sequences of optimized machine code often do not clearly map back to C
source code. Although we cover the use of the `-g` flag in the following
sections, some users may get better results with the `-g3` flag, which
can reveal extra debugging information.
:::

::: paragraph
Here is an example `gcc` command that will build a suitable executable
for debugging with GDB:
:::

::: listingblock
::: content
    $ gcc -g myprog.c
:::
:::

::: paragraph
To start GDB, invoke it on the executable file. For example:
:::

::: listingblock
::: content
    $ gdb a.out
    (gdb)          # the gdb command prompt
:::
:::

::: paragraph
When GDB starts, it prints the `(gdb)` prompt, which allows the user to
enter GDB commands (such as setting breakpoints) before it starts
running the `a.out` program.
:::

::: paragraph
Similarly, to invoke DDD on the executable file:
:::

::: listingblock
::: content
    $ ddd a.out
:::
:::

::: paragraph
Sometimes, when a program terminates with an error, the operating system
dumps a core file containing information about the state of the program
when it crashed. The contents of this core file can be examined in GDB
by running GDB with the core file and the executable that generated it:
:::

::: listingblock
::: content
    $ gdb core a.out
    (gdb) where       # the where command shows point of crash
:::
:::
:::

::: sect2
### [](#_example_gdb_sessions){.anchor}3.1.2. Example GDB Sessions {#_example_gdb_sessions}

::: paragraph
We demonstrate common features of GDB through two example sessions of
using GDB to debug programs. The first is an example of using GDB to
find and fix two bugs in a program, and the second is an example of
using GDB to debug a program that crashes. The set of GDB commands that
we demonstrate in these two example sessions includes:
:::

+-------------+--------------------------------------------------------+
| Command     | Description                                            |
+=============+========================================================+
| `break`     | Set a breakpoint                                       |
+-------------+--------------------------------------------------------+
| `run`       | Start program running from the beginning               |
+-------------+--------------------------------------------------------+
| `cont`      | Continue execution of the program until it hits a      |
|             | breakpoint                                             |
+-------------+--------------------------------------------------------+
| `quit`      | Quit the GDB session                                   |
+-------------+--------------------------------------------------------+
| `next`      | Allow program to execute the next line of C code and   |
|             | then pause it                                          |
+-------------+--------------------------------------------------------+
| `step`      | Allow program to execute the next line of C code; if   |
|             | the next line contains a function call, step into the  |
|             | function and pause                                     |
+-------------+--------------------------------------------------------+
| `list`      | List C source code around pause point or specified     |
|             | point                                                  |
+-------------+--------------------------------------------------------+
| `print`     | Print out the value of a program variable (or          |
|             | expression)                                            |
+-------------+--------------------------------------------------------+
| `where`     | Print the call stack                                   |
+-------------+--------------------------------------------------------+
| `frame`     | Move into the context of a specific stack frame        |
+-------------+--------------------------------------------------------+

::: sect3
#### [](#badprog){.anchor}Example Using GDB to Debug a Program (badprog.c) {#badprog}

::: paragraph
The first example GDB session debugs the
[badprog.c](_attachments/badprog.c) program. This program is supposed to
find the largest value in an array of `int` values. However, when run,
it incorrectly finds that 17 is the largest value in the array instead
of the correct largest value, which is 60. This example shows how GDB
can examine the program's runtime state to determine why the program is
not computing the expected result. In particular, this example debugging
session reveals two bugs:
:::

::: {.olist .arabic}
1.  An error with loop bounds resulting in the program accessing
    elements beyond the bounds of the array.

2.  An error in a function not returning the correct value to its
    caller.
:::

::: paragraph
To examine a program with GDB, first compile the program with `-g` to
add debugging information to the executable:
:::

::: listingblock
::: content
    $ gcc -g badprog.c
:::
:::

::: paragraph
Next, run GDB on the binary executable program (`a.out`). GDB
initializes and prints the `(gdb)` prompt, where the user can enter GDB
commands:
:::

::: listingblock
::: content
    $ gdb ./a.out

    GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
    Copyright (C) 2018 Free Software Foundation, Inc.
      ...
    (gdb)
:::
:::

::: paragraph
At this point GDB has not yet started running the program. A common
first debugging step is to set a breakpoint in the `main()` function to
pause the program's execution right before it executes the first
instruction in `main()`. The `break` command sets a \"breakpoint\"
(pauses the program) at a specified location (in this case at the start
of the `main()` function):
:::

::: listingblock
::: content
    (gdb) break main

    Breakpoint 1 at 0x8048436: file badprog.c, line 36.
:::
:::

::: paragraph
The `run` command tells GDB to start the program:
:::

::: listingblock
::: content
    (gdb) run
    Starting program: ./a.out
:::
:::

::: paragraph
If the program takes command line arguments, provide them after the
`run` command (for example, `run 100 200` would run `a.out` with the
command line arguments `100` and `200`).
:::

::: paragraph
After entering `run`, GDB starts the program's execution at its
beginning, and it runs until it hits a breakpoint. Upon reaching a
breakpoint, GDB pauses the program before executing the line of code at
the breakpoint, and prints out the breakpoint number and source code
line associated with the breakpoint. In this example, GDB pauses the
program just before executing line 36 of the program. It then prints out
the `(gdb)` prompt and waits for further instructions:
:::

::: listingblock
::: content
    Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36
    36     int main(int argc, char *argv[]) {

    (gdb)
:::
:::

::: paragraph
Often when a program pauses at a breakpoint, the user wants to see the C
source code around the breakpoint. The GDB `list` command displays the
code surrounding the breakpoint:
:::

::: listingblock
::: content
    (gdb) list
    29      }
    30      return 0;
    31  }
    32
    33  /***************************************/
    34  int main(int argc, char *argv[]) {
    35
    36      int arr[5] = { 17, 21, 44, 2, 60 };
    37
    38      int max = arr[0];
:::
:::

::: paragraph
Subsequent calls to `list` display the next lines of source code
following these. `list` can also be used with a specific line number
(for example, `list 11`) or with a function name to list the source code
at a specified part of the program. For example:
:::

::: listingblock
::: content
    (gdb) list findAndReturnMax
    12   *  array: array of integer values
    13   *  len: size of the array
    14   *  max: set to the largest value in the array
    15   *      returns: 0 on success and non-zero on an error
    16   */
    17  int findAndReturnMax(int *array1, int len, int max) {
    18
    19      int i;
    20
    21      if (!array1 || (len <=0) ) {
:::
:::

::: paragraph
The user may want to execute one line of code at a time after hitting a
breakpoint, examining program state after each line is executed. The GDB
`next` command executes just the very next line of C code. After the
program executes this line of code, GDB pauses the program again. The
`print` command prints the values of program variables. Here are a few
calls to `next` and `print` to show their effects on the next two lines
of execution. Note that the source code line listed after a `next` has
not yet been executed --- it shows the line where the program is paused,
which represents the line that will be executed next:
:::

::: listingblock
::: content
    (gdb) next
    36    int arr[5] = { 17, 21, 44, 2, 60 };
    (gdb) next
    38    int max = arr[0];
    (gdb) print max
    $3 = 0
    (gdb) print arr[3]
    $4 = 2
    (gdb) next
    40    if ( findAndReturnMax(arr, 5, max) != 0 ) {
    (gdb) print max
    $5 = 17
    (gdb)
:::
:::

::: paragraph
At this point in the program's execution, the main function has
initialized its local variables `arr` and `max` and is about to make a
call to the `findAndReturnMax()` function. The GDB `next` command
executes the next full line of C source code. If that line includes a
function call, the full execution of that function call and its return
is executed as part of a single `next` command. A user who wants to
observe the execution of the function should issue GDB's `step` command
instead of the `next` command: `step` steps into a function call,
pausing the program before the first line of the function is executed.
:::

::: paragraph
Because we suspect that the bug in this program is related to the
`findAndReturnMax()` function, we want to step into the function's
execution rather than past it. So, when paused at line 40, the `step`
command will next pause the program at the start of the
`findAndReturnMax()` (alternately, the user could set a breakpoint at
`findAndReturnMax()` to pause the program's execution at that point):
:::

::: listingblock
::: content
    (gdb) next
    40    if ( findAndReturnMax(arr, 5, max) != 0 ) {
    (gdb) step
    findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21
    21    if (!array1 || (len <=0) ) {
    (gdb)
:::
:::

::: paragraph
The program is now paused inside the `findAndReturnMax` function, whose
local variables and parameters are now in scope. The `print` command
shows their values, and `list` displays the C source code around the
pause point:
:::

::: listingblock
::: content
    (gdb) print array1[0]
    $6 = 17
    (gdb) print max
    $7 = 17
    (gdb) list
    16   */
    17  int findAndReturnMax(int *array1, int len, int max) {
    18
    19      int i;
    20
    21      if (!array1 || (len <=0) ) {
    22          return -1;
    23      }
    24      max = array1[0];
    25      for (i=1; i <= len; i++) {
    (gdb) list
    26          if(max < array1[i]) {
    27              max = array1[i];
    28          }
    29      }
    30      return 0;
    31  }
    32
    33  /***************************************/
    34  int main(int argc, char *argv[]) {
    35
:::
:::

::: paragraph
Because we think there is a bug related to this function, we may want to
set a breakpoint inside the function so that we can examine the runtime
state part way through its execution. In particular, setting a
breakpoint on the line when `max` is changed may help us see what this
function is doing.
:::

::: paragraph
We can set a breakpoint at a specific line number in the program (line
27) and use the `cont` command to tell GDB to let the application's
execution continue from its paused point. Only when the program hits a
breakpoint will GDB pause the program and grab control again, allowing
the user to enter other GDB commands.
:::

::: listingblock
::: content
    (gdb) break 27
    Breakpoint 2 at 0x555555554789: file badprog.c, line 27.

    (gdb) cont
    Continuing.

    Breakpoint 2, findAndReturnMax (array1=0x...e290,len=5,max=17) at badprog.c:27
    27        max = array1[i];
    (gdb) print max
    $10 = 17
    (gdb) print i
    $11 = 1
:::
:::

::: paragraph
The `display` command asks GDB to automatically print out the same set
of program variables every time a breakpoint is hit. For example, we
will display the values of `i`, `max`, and `array1[i]` every time the
program hits a breakpoint (in each iteration of the loop in
`findAndReturnMax()`):
:::

::: listingblock
::: content
    (gdb) display i
    1: i = 1
    (gdb) display max
    2: max = 17
    (gdb) display array1[i]
    3: array1[i] = 21

    (gdb) cont
    Continuing.

    Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)
        at badprog.c:27
    27        max = array1[i];
    1: i = 2
    2: max = 21
    3: array1[i] = 44

    (gdb) cont
    Continuing.

    Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)
        at badprog.c:27
    27        max = array1[i];
    1: i = 3
    2: max = 44
    3: array1[i] = 2

    (gdb) cont

    Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=44)
        at badprog.c:27
    27        max = array1[i];
    1: i = 4
    2: max = 44
    3: array1[i] = 60

    (gdb) cont
    Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)
        at badprog.c:27
    27        max = array1[i];
    1: i = 5
    2: max = 60
    3: array1[i] = 32767

    (gdb)
:::
:::

::: paragraph
We found our first bug! The value of `array1[i]` is 32767, a value not
in the passed array, and the value of `i` is 5, but 5 is not a valid
index into this array. Through GDB we discovered that the `for` loop
bounds need to be fixed to `i < len`.
:::

::: paragraph
At this point, we could exit the GDB session and fix this bug in the
code. To quit a GDB session, type `quit`:
:::

::: listingblock
::: content
    (gdb) quit
    The program is running.  Exit anyway? (y or n) y
    $
:::
:::

::: paragraph
After fixing this bug, recompiling, and running the program, it still
does not find the correct max value (it still finds that 17 is the max
value and not 60). Based on our previous GDB run, we may suspect that
there is an error in calling or returning from the `findAndReturnMax()`
function. We re-run the new version of our program in GDB, this time
setting a breakpoint at the entry to the `findAndReturnMax()` function:
:::

::: listingblock
::: content
    $ gdb ./a.out
    ...
    (gdb) break main
    Breakpoint 1 at 0x7c4: file badprog.c, line 36.

    (gdb) break findAndReturnMax
    Breakpoint 2 at 0x748: file badprog.c, line 21.

    (gdb) run
    Starting program: ./a.out

    Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36
    36  int main(int argc, char *argv[]) {
    (gdb) cont
    Continuing.

    Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=17)
        at badprog.c:21
    21    if (!array1 || (len <=0) ) {
    (gdb)
:::
:::

::: paragraph
If we suspect a bug in the arguments or return value of a function, it
may be helpful to examine the contents of the stack. The `where` (or
`bt`, for \"backtrace\") GDB command prints the current state of the
stack. In this example, the `main()` function is on the bottom of the
stack (in frame 1) and is executing a call to `findAndReturnMax()` at
line 40. The `findAndReturnMax()` function is on the top of the stack
(in frame 0), and is currently paused at line 21:
:::

::: listingblock
::: content
    (gdb) where
    #0  findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21
    #1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40
:::
:::

::: paragraph
GDB's `frame` command moves into the context of any frame on the stack.
Within each stack frame context, a user can examine the local variables
and parameters in that frame. In this example, we move into stack frame
1 (the caller's context) and print out the values of the arguments that
the `main()` function passes to `findAndReturnMax()` (for example, `arr`
and `max`):
:::

::: listingblock
::: content
    (gdb) frame 1
    #1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40
    40    if ( findAndReturnMax(arr, 5, max) != 0 ) {
    (gdb) print arr
    $1 = {17, 21, 44, 2, 60}
    (gdb) print max
    $2 = 17
    (gdb)
:::
:::

::: paragraph
The argument values look fine, so let's check the `findAndReturnMax()`
function's return value. To do this, we add a breakpoint right before
`findAndReturnMax()` returns to see what value it computes for its
`max`:
:::

::: listingblock
::: content
    (gdb) break 30
    Breakpoint 3 at 0x5555555547ae: file badprog.c, line 30.
    (gdb) cont
    Continuing.

    Breakpoint 3, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)
        at badprog.c:30
    30    return 0;

    (gdb) print max
    $3 = 60
:::
:::

::: paragraph
This shows that the function has found the correct max value (60). Let's
execute the next few lines of code and see what value the `main()`
function receives:
:::

::: listingblock
::: content
    (gdb) next
    31  }
    (gdb) next
    main (argc=1, argv=0x7fffffffe398) at badprog.c:44
    44    printf("max value in the array is %d\n", max);

    (gdb) where
    #0  main (argc=1, argv=0x7fffffffe398) at badprog.c:44

    (gdb) print max
    $4 = 17
:::
:::

::: paragraph
We found the second bug! The `findAndReturnMax()` function identifies
the correct largest value in the passed array (60), but it doesn't
return that value back to the `main()` function. To fix this error, we
need to either change `findAndReturnMax()` to return its value of `max`
or add a \"pass-by-pointer\" parameter that the function will use to
modify the value of the `main()` function's `max` local variable.
:::
:::

::: sect3
#### [](#_segfaulter_){.anchor}Example Using GDB to Debug a Program That Crashes (segfaulter.c) {#_segfaulter_}

::: paragraph
The second example GDB session (run on the
[segfaulter.c](_attachments/segfaulter.c) program) demonstrates how GDB
behaves when a program crashes and how we can use GDB to help discover
why the crash occurs.
:::

::: paragraph
In this example, we just run the `segfaulter` program in GDB and let it
crash:
:::

::: listingblock
::: content
    $ gcc -g -o segfaulter segfaulter.c
    $ gdb ./segfaulter

    (gdb) run
    Starting program: ./segfaulter

    Program received signal SIGSEGV, Segmentation fault.
    0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14
    14      array[i] = i;
:::
:::

::: paragraph
As soon as the program crashes, GDB pauses the program's execution at
the point it crashes and grabs control. GDB allows a user to issue
commands to examine the program's runtime state at the point of the
program crash, often leading to discovering why the program crashed and
how to fix the cause of the crash. The GDB `where` and `list` commands
are particularly useful for determining where a program crashes:
:::

::: listingblock
::: content
    (gdb) where
    #0 0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14
    #1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37

    (gdb) list
    9   int initfunc(int *array, int len) {
    10
    11      int i;
    12
    13      for(i=1; i <= len; i++) {
    14          array[i] = i;
    15      }
    16      return 0;
    17  }
    18
:::
:::

::: paragraph
This output tells us that the program crashes on line 14, in the
`initfunc()` function. Examining the values of the parameters and local
variables on line 14 may tell us why it crashes:
:::

::: listingblock
::: content
    (gdb) print i
    $2 = 1
    (gdb) print array[i]
    Cannot access memory at address 0x4
:::
:::

::: paragraph
The value of `i` seems fine, but we see an error when trying to access
index `i` of `array`. Let's print out the value of `array` (the value of
the base address of the array) to see if that tells us anything:
:::

::: listingblock
::: content
    (gdb) print array
    $3 = (int *) 0x0
:::
:::

::: paragraph
We have found the cause of the crash! The base address of the array is
zero (or `NULL`), and we know that dereferencing a null pointer (via
`array[i]`) causes programs to crash.
:::

::: paragraph
Let's see if we can figure out why the `array` parameter is `NULL` by
looking in the caller's stack frame:
:::

::: listingblock
::: content
    (gdb) frame 1
    #1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37
    37    if(initfunc(arr, 100) != 0 ) {
    (gdb) list
    32  int main(int argc, char *argv[]) {
    33
    34      int *arr = NULL;
    35      int max = 6;
    36
    37      if(initfunc(arr, 100) != 0 ) {
    38          printf("init error\n");
    39          exit(1);
    40      }
    41
    (gdb) print arr
    $4 = (int *) 0x0
    (gdb)
:::
:::

::: paragraph
Moving into the caller's stack frame and printing out the value of the
arguments `main()` passes to `initfunc()` shows that the `main()`
function passes a null pointer to the `initfunc()` function. In other
words, the user forgot to allocate the `arr` array prior to the call to
`initfunc()`. The fix is to use the `malloc()` function to allocate some
space to `arr` at line 34.
:::

::: paragraph
These two example GDB sessions illustrate commonly used commands for
finding bugs in programs. In the next section, we discuss these and
other GDB commands in more detail.
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
