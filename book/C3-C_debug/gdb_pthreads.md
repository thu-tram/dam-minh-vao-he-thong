
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](../C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](../C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](../C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](../C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](../C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](../C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](../C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](../C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](../C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](../C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](../C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](../C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](../C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](../C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](../C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](../C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](../C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](../C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](../C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](index.html){.nav-link}
        -   [3.1. Debugging with GDB](gdb.html){.nav-link}
        -   [3.2. GDB Commands in Detail](gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](valgrind.html){.nav-link}
        -   [3.4. Advanced GDB Features](gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly Code](gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [3. C Debugging Tools](index.html)
-   [3.6. Debugging Multi-threaded Programs](gdb_pthreads.html)
:::

::: content
::: sect1
## [](#_debugging_multithreaded_programs_with_gdb){.anchor}3.6. Debugging Multithreaded Programs with GDB {#_debugging_multithreaded_programs_with_gdb}

::: sectionbody
::: paragraph
Debugging multithreaded programs can be tricky due to the multiple
streams of execution and due to interactions between the concurrently
executing threads. In general, here are some things to make debugging
multithreaded programs a bit easier:
:::

::: ulist
-   When possible, try to debug a version of the program with as few
    threads as possible.

-   When adding debugging `printf` statements to the code, print out the
    executing thread's ID to identify which thread is printing and end
    the line with a `\n`.

-   Limit the amount of debug output by having only one of the threads
    print its information and common information. For example, if each
    thread stores its logical ID in a local variable named `my_tid`, a
    conditional statement on the value of `my_tid` can be used to limit
    printing debug output to one thread, as illustrated in the following
    example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
if (my_tid == 1) {
    printf("Tid:%d: value of count is %d and my i is %d\n", my_tid, count, i);
    fflush(stdout);
}
```
:::
:::

::: sect2
### [](#_gdb_and_pthreads){.anchor}3.6.1. GDB and Pthreads {#_gdb_and_pthreads}

::: paragraph
The GDB debugger has specific support for debugging threaded programs,
including setting breakpoints for individual threads and examining the
stacks of individual threads. One thing to note when debugging Pthreads
programs in GDB is that there are at least three identifiers for each
thread:
:::

::: ulist
-   The Pthreads library's ID for the thread (its `pthread_t` value).

-   The operating system's lightweight process (LWP) ID value for the
    thread. This ID is used in part for the OS to keep track of this
    thread for scheduling purposes.

-   The GDB ID for the thread. This is the ID to use when specifying a
    specific thread in GDB commands.
:::

::: paragraph
The specific relationship between thread IDs can differ from one OS and
Pthreads library implementation to another, but on most systems there is
a one-to-one-to-one correspondence between a Pthreads ID, an LWP ID, and
a GDB thread ID.
:::

::: paragraph
We present a few GDB basics for debugging threaded programs in GDB. See
the following for more information about [debugging threaded programs in
GDB](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html#Threads).
:::
:::

::: sect2
### [](#_gdb_thread_specific_commands){.anchor}3.6.2. GDB Thread-Specific Commands: {#_gdb_thread_specific_commands}

::: ulist
-   Enable printing thread start and exit events:

    ::: listingblock
    ::: content
        set print thread-events
    :::
    :::

-   List all existing threads in the program (the GDB thread number is
    the first value listed and the thread that hit the breakpoint is
    denoted with an `*`):

    ::: listingblock
    ::: content
        info threads
    :::
    :::

-   Switch to a specific thread's execution context (for example, to
    examine its stack when executing `where`), specify the thread by its
    thread ID:

    ::: listingblock
    ::: content
        thread <threadno>

        thread 12        # Switch to thread 12's execution context
        where            # Thread 12's stack trace
    :::
    :::

-   Set a breakpoint for just a particular thread. Other threads
    executing at the point in the code where the breakpoint is set will
    not trigger the breakpoint to pause the program and print the GDB
    prompt:

    ::: listingblock
    ::: content
        break <where> thread <threadno>

        break foo thread 12    # Break when thread 12 executes function foo
    :::
    :::

-   To apply a specific GDB command to all or to a subset of threads, by
    adding the prefix `thread apply <threadno | all>` to a GDB command,
    where `threadno` refers to the GDB thread ID:

    ::: listingblock
    ::: content
        thread apply <threadno|all> command
    :::
    :::

    ::: paragraph
    This doesn't work for every GDB command, setting breakpoints in
    particular, so use this syntax instead for setting thread-specific
    breakpoints:
    :::

    ::: listingblock
    ::: content
        break <where> thread <threadno>
    :::
    :::
:::

::: paragraph
Upon reaching a breakpoint, by default, GDB pauses all threads until the
user types `cont`. The user can change the behavior to request that GDB
only pause the threads that hit a breakpoint, allowing other threads to
continue executing.
:::
:::

::: sect2
### [](#_examples){.anchor}3.6.3. Examples: {#_examples}

::: paragraph
We show some GDB commands and output from a GDB run on a multithreaded
executable compiled from the file [racecond.c](_attachments/racecond.c).
:::

::: paragraph
This errant program lacks synchronization around accesses to the shared
variable `count`. As a result, different runs of the program produce
different final values for `count`, indicating a race condition. For
example, here are two runs of the program with five threads that produce
different results:
:::

::: listingblock
::: content
    ./a.out 5
    hello I'm thread 0 with pthread_id 139673141077760
    hello I'm thread 3 with pthread_id 139673115899648
    hello I'm thread 4 with pthread_id 139673107506944
    hello I'm thread 1 with pthread_id 139673132685056
    hello I'm thread 2 with pthread_id 139673124292352
    count = 159276966

    ./a.out 5
    hello I'm thread 0 with pthread_id 140580986918656
    hello I'm thread 1 with pthread_id 140580978525952
    hello I'm thread 3 with pthread_id 140580961740544
    hello I'm thread 2 with pthread_id 140580970133248
    hello I'm thread 4 with pthread_id 140580953347840
    count = 132356636
:::
:::

::: paragraph
The fix is to put accesses to `count` inside a critical section, using a
`pthread_mutex_t` variable. If the user was not able to see this fix by
examining the C code alone, running in GDB and putting breakpoints
around accesses to the `count` variable may help the programmer discover
the problem.
:::

::: paragraph
Here are some example commands from a GDB run of this program:
:::

::: listingblock
::: content
    (gdb) break worker_loop   # Set a breakpoint for all spawned threads
    (gdb) break 77 thread 4   # Set a breakpoint just for thread 4
    (gdb) info threads        # List information about all threads
    (gdb) where               # List stack of thread that hit the breakpoint
    (gdb) print i             # List values of its local variable i
    (gdb) thread 2            # Switch to different thread's (2) context
    (gdb) print i             # List thread 2's local variables i
:::
:::

::: paragraph
Shown in the example that follows is partial output of a GDB run of the
`racecond` program with 3 threads (`run 3`), showing examples of GDB
thread commands in the context of a GDB debugging session. The main
thread is always GDB thread number 1, and the three spawned threads are
GDB threads 2 to 4.
:::

::: paragraph
When debugging multithreaded programs, the GDB user must keep track of
which threads exist when issuing commands. For example, when the
breakpoint in `main` is hit, only thread 1 (the main thread) exists. As
a result, the GDB user must wait until threads are created before
setting a breakpoint for only a specific thread (this example shows
setting a breakpoint for thread 4 only at line 77 in the program). In
viewing this output, note when breakpoints are set and deleted, and note
the value of each thread's local variable `i` when thread contexts are
switched with GDB's `thread` command:
:::

::: listingblock
::: content
    $ gcc -g racecond.c -pthread

    $ gdb ./a.out
    (gdb) break main
    Breakpoint 1 at 0x919: file racecond.c, line 28.
    (gdb) run 3
    Starting program: ...
    [Thread debugging using libthread_db enabled] ...

    Breakpoint 1, main (argc=2, argv=0x7fffffffe388) at racecond.c:28
    28      if (argc != 2) {
    (gdb) list 76
    71    myid = *((int *)arg);
    72
    73    printf("hello I'm thread %d with pthread_id %lu\n",
    74        myid, pthread_self());
    75
    76    for (i = 0; i < 10000; i++) {
    77        count += i;
    78    }
    79
    80    return (void *)0;

    (gdb) break 76
    Breakpoint 2 at 0x555555554b06: file racecond.c, line 76.
    (gdb) cont
    Continuing.

    [New Thread 0x7ffff77c4700 (LWP 5833)]
    hello I'm thread 0 with pthread_id 140737345505024
    [New Thread 0x7ffff6fc3700 (LWP 5834)]
    hello I'm thread 1 with pthread_id 140737337112320
    [New Thread 0x7ffff67c2700 (LWP 5835)]
    [Switching to Thread 0x7ffff77c4700 (LWP 5833)]

    Thread 2 "a.out" hit Breakpoint 2, worker_loop (arg=0x555555757280)
        at racecond.c:76
    76    for (i = 0; i < 10000; i++) {
    (gdb) delete 2

    (gdb) break 77 thread 4
    Breakpoint 3 at 0x555555554b0f: file racecond.c, line 77.
    (gdb) cont
    Continuing.

    hello I'm thread 2 with pthread_id 140737328719616
    [Switching to Thread 0x7ffff67c2700 (LWP 5835)]

    Thread 4 "a.out" hit Breakpoint 3, worker_loop (arg=0x555555757288)
        at racecond.c:77
    77        count += i;
    (gdb) print i
    $2 = 0
    (gdb) cont
    Continuing.
    [Switching to Thread 0x7ffff67c2700 (LWP 5835)]

    Thread 4 "a.out" hit Breakpoint 3, worker_loop (arg=0x555555757288)
        at racecond.c:77
    77        count += i;
    (gdb) print i
    $4 = 1

    (gdb) thread 3
    [Switching to thread 3 (Thread 0x7ffff6fc3700 (LWP 5834))]
    #0  0x0000555555554b12 in worker_loop (arg=0x555555757284) at racecond.c:77
    77        count += i;
    (gdb) print i
    $5 = 0

    (gdb) thread 2
    [Switching to thread 2 (Thread 0x7ffff77c4700 (LWP 5833))]
    #0  worker_loop (arg=0x555555757280) at racecond.c:77
    77        count += i;
    (gdb) print i
    $6 = 1
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
