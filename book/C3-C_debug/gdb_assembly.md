
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful
        C](../C1-C_intro/index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](../C1-C_intro/getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](../C1-C_intro/input_output.html){.nav-link}
        -   [1.3. Conditionals and
            Loops](../C1-C_intro/conditionals.html){.nav-link}
        -   [1.4. Functions](../C1-C_intro/functions.html){.nav-link}
        -   [1.5. Arrays and
            Strings](../C1-C_intro/arrays_strings.html){.nav-link}
        -   [1.6. Structs](../C1-C_intro/structs.html){.nav-link}
        -   [1.7. Summary](../C1-C_intro/summary.html){.nav-link}
        -   [1.8. Exercises](../C1-C_intro/exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](../C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](../C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](../C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](../C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](../C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](../C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](../C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](../C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](../C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](../C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](../C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](../C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](../C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](../C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](../C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](../C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](../C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](../C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](../C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](index.html){.nav-link}
        -   [3.1. Debugging with GDB](gdb.html){.nav-link}
        -   [3.2. GDB Commands in Detail](gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](valgrind.html){.nav-link}
        -   [3.4. Advanced GDB Features](gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly Code](gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [3. C Debugging Tools](index.html)
-   [3.5. Debugging Assembly Code](gdb_assembly.html)
:::

::: content
::: sect1
## [](#_debugging_assembly_code){.anchor}3.5. Debugging Assembly Code {#_debugging_assembly_code}

::: sectionbody
::: paragraph
In addition to high-level C and C++ debugging, GDB can debug a program
at its assembly code level. Doing so enables GDB to list disassembled
code sequences from functions, set breakpoints at the assembly
instruction level, step through program execution one assembly
instruction at a time, and examine the values stored in machine
registers and in stack and heap memory addresses at runtime. We use IA32
as the example assembly language in this section, but the GDB commands
presented here apply to any assembly language that GCC supports. We note
that readers may find this subsection most useful after reading more
about assembly code in later chapters.
:::

::: paragraph
We use the following short C program as an example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int main(void) {
    int x, y;

    x = 1;
    x = x + 2;
    x = x - 14;
    y = x * 100;
    x = x + y * 6;

    return 0;
}
```
:::
:::

::: paragraph
To compile to an IA32 executable, use the `-m32` flag:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc -m32 -o simpleops simpleops.c
```
:::
:::

::: paragraph
Optionally, compiling with `gcc`\'s `-fno-asynchronous-unwind-tables`
command line option generates IA32 code that's a bit easier for the
programmer to read and understand:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc -m32 -fno-asynchronous-unwind-tables -o simpleops simpleops.c
```
:::
:::

::: sect2
### [](#_using_gdb_to_examine_binary_code){.anchor}3.5.1. Using GDB to Examine Binary Code {#_using_gdb_to_examine_binary_code}

::: paragraph
In this section we show some example GDB commands to debug the short C
program at the assembly code level. The following table summarizes many
of the commands this section demonstrates:
:::

+---------------------------+------------------------------------------+
| GDB command               | Description                              |
+===========================+==========================================+
| `break sum`               | Set a breakpoint at the beginning of the |
|                           | function `sum`                           |
+---------------------------+------------------------------------------+
| `break *0x0804851a`       | Set a breakpoint at memory address       |
|                           | 0x0804851a                               |
+---------------------------+------------------------------------------+
| `disass main`             | Disassemble the `main` function          |
+---------------------------+------------------------------------------+
| `ni`                      | Execute the next instruction             |
+---------------------------+------------------------------------------+
| `si`                      | Step into a function call (step          |
|                           | instruction)                             |
+---------------------------+------------------------------------------+
| `info registers`          | List the register contents               |
+---------------------------+------------------------------------------+
| `p $eax`                  | Print the value stored in register %eax  |
+---------------------------+------------------------------------------+
| `p  *(int *)($ebp+8)`     | Print out the value of an int at an      |
|                           | address (%ebp+8)                         |
+---------------------------+------------------------------------------+
| `x/d $ebp+8`              | Examine the contents of memory at an     |
|                           | address                                  |
+---------------------------+------------------------------------------+

::: paragraph
First, compile to IA32 assembly and run GDB on the IA32 executable
program `simpleops`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc -m32 -fno-asynchronous-unwind-tables -o simpleops simpleops.c
$ gdb ./simpleops
```
:::
:::

::: paragraph
Then, set a breakpoint in `main`, and then start running the program
with the `run` command:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) break main
(gdb) run
```
:::
:::

::: paragraph
The `disass` command disassembles (lists the assembly code associated
with) parts of the program. For example, to view the assembly
instructions of the main function:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) disass main         # Disassemble the main function
```
:::
:::

::: paragraph
GDB allows a programmer to set breakpoints at individual assembly
instructions by dereferencing the memory address of the instruction:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) break *0x080483c1   # Set breakpoint at instruction at 0x080483c1
```
:::
:::

::: paragraph
The program's execution can be executed one assembly instruction at a
time using `si` or `ni` to step into or execute the next instruction:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) ni     # Execute the next instruction

(gdb) si     # Execute next instruction; if it is a call instruction,
             # then step into the function
```
:::
:::

::: paragraph
The `si` command steps into function calls, meaning that GDB will pause
the program at the first instruction of the called function. The `ni`
command skips over them, meaning that GDB will pause the program at the
next instruction following the call instruction (after the function
executes and returns to the caller).
:::

::: paragraph
The programmer can print values stored in machine registers using the
`print` command and the name of the register prefixed by `$`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) print $eax    # print the value stored in register eax
```
:::
:::

::: paragraph
The `display` command automatically displays values upon reaching a
breakpoint:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) display $eax
(gdb) display $edx
```
:::
:::

::: paragraph
The `info registers` command shows all of the values stored in the
machine registers:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
(gdb) info registers
```
:::
:::
:::

::: sect2
### [](#_using_ddd_to_debug_at_the_assembly_level){.anchor}3.5.2. Using DDD to Debug at the Assembly Level {#_using_ddd_to_debug_at_the_assembly_level}

::: paragraph
The DDD debugger provides a graphical interface on top of another
debugger (GDB in this case). It provides a nice interface for displaying
assembly code, viewing registers, and stepping through IA32 instruction
execution. Because DDD has separate windows for displaying disassembled
code, register values, and the GDB command prompt, it's often easier to
use than GDB when debugging at the assembly code level.
:::

::: paragraph
To debug with DDD, substitute `ddd` for `gdb`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ ddd ./simpleops
```
:::
:::

::: paragraph
The GDB prompt appears in the bottom window, where it accepts GDB
commands at the prompt. Although it provides menu options and buttons
for some GDB commands, often the GDB prompt at the bottom is easier to
use.
:::

::: paragraph
DDD displays the assembly code view of a program by selecting the *View*
→ *Machine Code Window* menu option. That option creates a new subwindow
with a listing of the program's assembly code (you will likely want to
resize this window to make it larger).
:::

::: paragraph
To view all of the program's register values in a separate window,
enable the *Status* → *Registers* menu option.
:::
:::

::: sect2
### [](#_gdb_assembly_code_debugging_commands_and_examples){.anchor}3.5.3. GDB Assembly Code Debugging Commands and Examples {#_gdb_assembly_code_debugging_commands_and_examples}

::: paragraph
Here are some details and examples of GDB commands that are useful for
debugging at the assembly code level (see the [Common GDB
Commands](gdb_commands.html#_common_gdb_commands){.page} section for
more details about some of these commands, particularly for the `print`
and `x` formatting options):
:::

::: ulist
-   `disass`: Disassemble code for a function or range of addresses.

    ::: listingblock
    ::: content
        disass <func_name>   # Lists assembly code for function
        disass <start> <end> # Lists assembly instructions between start & end address

        disass main          # Disassemble main function
        disass 0x1234 0x1248 # Disassemble instructions between addr 0x1234 & 0x1248
    :::
    :::

-   `break`: Set a breakpoint at an instruction address.

    ::: listingblock
    ::: content
        break *0x80dbef10  # Sets breakpoint at the instruction at address 0x80dbef10
    :::
    :::

-   `stepi` (`si`), `nexti` (`ni`) :

    ::: listingblock
    ::: content
        stepi, si          # Execute next machine code instruction,
                           # stepping into function call if it is a call instr
        nexti,  ni         # Execute next machine code instruction,
                           # treating function call as a single instruction
    :::
    :::

-   `info registers`: Lists all the register values.

-   `print`: Display the value of an expression.

    ::: listingblock
    ::: content
        print $eax                # Print the value stored in the eax register
        print *(int *)0x8ff4bc10  # Print int value stored at memory addr 0x8ff4bc10
    :::
    :::

-   `x` Display the contents of the memory location given an address.
    Remember that the format of `x` is sticky, so it needs to be
    explicitly changed.

    ::: listingblock
    ::: content
        (gdb) x $ebp-4      # Examine memory at address: (contents of register ebp)-4
                            # if the location stores an address x/a, an int x/wd, ...

        (gdb) x/s 0x40062d  # Examine the memory location 0x40062d as a string
        0x40062d   "Hello There"

        (gdb) x/4c 0x40062d # Examine the first 4 char memory locations
                            # starting at address 0x40062d
        0x40062d   72 'H'  101 'e' 108 'l' 108 'l'

        (gdb) x/d 0x40062d  # Examine the memory location 0x40062d in decimal
        0x40062d   72       # NOTE: units is 1 byte, set by previous x/4c command

        (gdb) x/wd 0x400000 # Examine memory location 0x400000 as 4 bytes in decimal
        0x400000   100      # NOTE: units was 1 byte set, need to reset to w
    :::
    :::

-   `set`: Set the contents of memory locations and registers.

    ::: listingblock
    ::: content
        set $eax = 10                 Set the value of register eax to 10
        set $esp = $esp + 4           Pop a 4-byte value off the stack
        set *(int *)0x8ff4bc10 = 44   Store 44 at address 0x8ff4bc10
    :::
    :::

-   `display`: Print an expression each time a breakpoint is hit.

    ::: listingblock
    ::: content
        display $eax         Display value of register eax
    :::
    :::
:::
:::

::: sect2
### [](#_quick_summary_of_common_commands_for_assembly_debugging){.anchor}3.5.4. Quick Summary of Common Commands for Assembly Debugging {#_quick_summary_of_common_commands_for_assembly_debugging}

::: listingblock
::: content
    $ ddd ./a.out
    (gdb) break main
    (gdb) run

    (gdb) disass main         # Disassemble the main function
    (gdb) break sum           # Set a breakpoint at the beginning of a function
    (gdb) cont                # Continue execution of the program
    (gdb) break *0x0804851a   # Set a breakpoint at memory address 0x0804851a
    (gdb) ni                  # Execute the next instruction
    (gdb) si                  # Step into a function call (step instruction)
    (gdb) info registers      # List the register contents
    (gdb) p $eax              # Print the value stored in register %eax
    (gdb) p  *(int *)($ebp+8) # Print out value of an int at addr (%ebp+8)
    (gdb) x/d $ebp+8          # Examine the contents of memory at the given
                              #  address (/d: prints the value as an int)
    (gdb) x/s 0x0800004       # Examine contents of memory at address as a string
    (gdb) x/wd 0xff5634       # After x/s, the unit size is 1 byte, so if want
                              # to examine as an int specify both the width w & d
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
