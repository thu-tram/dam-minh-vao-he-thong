
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](index.html){.nav-link}
        -   [8.1. Assembly Basics](basics.html){.nav-link}
        -   [8.2. Common Instructions](common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [8.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [8.4.2. If Statements](if_statements.html){.nav-link}
            -   [8.4.3. Loops](loops.html){.nav-link}
        -   [8.5. Functions in Assembly](functions.html){.nav-link}
        -   [8.6. Recursion](recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [8.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [8.9. Structs in Assembly](structs.html){.nav-link}
        -   [8.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [8. 32-bit x86 Assembly](index.html)
-   [8.1. Assembly Basics](basics.html)
:::

::: content
::: sect1
## [](#_diving_into_assembly_basics){.anchor}8.1. Diving into Assembly: Basics {#_diving_into_assembly_basics}

::: sectionbody
::: paragraph
For a first look at assembly, we modify the `adder` function from the
beginning of the chapter to simplify its behavior. Here's the modified
function (`adder2`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

//adds two to an integer and returns the result
int adder2(int a) {
    return a + 2;
}

int main(void) {
    int x = 40;
    x = adder2(x);
    printf("x is: %d\n", x);
    return 0;
}
```
:::
:::

::: paragraph
To compile this code, use the following command:
:::

::: listingblock
::: content
    $ gcc -m32 -o modified modified.c
:::
:::

::: paragraph
The `-m32` flag tells GCC to compile the code to a 32-bit executable.
Forgetting to include this flag may result in assembly that is wildly
different from the examples shown in this chapter; by default, GCC
compiles to x86-64 assembly, the 64-bit variant of x86. However,
virtually all 64-bit architectures have a 32-bit operating mode for
backward compatibility. This chapter covers IA32; other chapters cover
x86-64 and ARM. Despite its age, IA32 is still extremely useful for
understanding how programs work and how to optimize code.
:::

::: paragraph
Next, let's view the corresponding assembly of this code by typing the
following command:
:::

::: listingblock
::: content
    $ objdump -d modified > output
    $ less output
:::
:::

::: paragraph
Search for the code snippet associated with `adder2` by typing `/adder2`
while examining the file `output` using `less`. The section associated
with `adder2` should look similar to the following:
:::

::: {#Assembly32 .listingblock}
::: title
Assembly output for the `adder2` function
:::

::: content
    0804840b <adder2>:
     804840b:       55                      push   %ebp
     804840c:       89 e5                   mov    %esp,%ebp
     804840e:       8b 45 08                mov    0x8(%ebp),%eax
     8048411:       83 c0 02                add    $0x2,%eax
     8048414:       5d                      pop    %ebp
     8048415:       c3                      ret
:::
:::

::: paragraph
Don't worry if you don't understand what's going on just yet. We will
cover assembly in greater detail in later sections. For now, we will
study the structure of these individual instructions.
:::

::: paragraph
Each line in the preceding example contains an instruction's address in
program memory, the bytes corresponding to the instruction, and the
plaintext representation of the instruction itself. For example, `55` is
the machine code representation of the instruction `push %ebp`, and the
instruction occurs at address `0x804840b` in program memory.
:::

::: paragraph
It is important to note that a single line of C code often translates to
multiple instructions in assembly. The operation `a + 2` is represented
by the two instructions `mov 0x8(%ebp), %eax` and `add $0x2, %eax`.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Your assembly may look different! |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | If you are compiling your code    |
|                                   | along with us, you may notice     |
|                                   | that some of your assembly        |
|                                   | examples look different from what |
|                                   | is shown in this book. The        |
|                                   | precise assembly instructions     |
|                                   | that are output by any compiler   |
|                                   | depend on that compiler's version |
|                                   | and the underlying operating      |
|                                   | system. Most of the assembly      |
|                                   | examples in this book were        |
|                                   | generated on systems running      |
|                                   | Ubuntu or Red Hat Enterprise      |
|                                   | Linux (RHEL).                     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In the examples that follow, we   |
|                                   | do not use any optimization       |
|                                   | flags. For example, we compile    |
|                                   | any example file (`example.c`)    |
|                                   | using the command                 |
|                                   | `gcc -m32 -o example example.c`.  |
|                                   | Consequently, there are many      |
|                                   | seemingly redundant instructions  |
|                                   | in the examples that follow.      |
|                                   | Remember that the compiler is not |
|                                   | \"smart\" --- it simply follows a |
|                                   | series of rules to translate      |
|                                   | human-readable code into machine  |
|                                   | language. During this translation |
|                                   | process, it is not uncommon for   |
|                                   | some redundancy to occur.         |
|                                   | Optimizing compilers remove many  |
|                                   | of these redundancies during      |
|                                   | optimization, which is covered in |
|                                   | a [later                          |
|                                   | chapter](../C12-CodeOpt/index     |
|                                   | .html#_code_optimization){.page}. |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: sect2
### [](#_registers){.anchor}8.1.1. Registers {#_registers}

::: paragraph
Recall that a **register** is a word-sized storage unit located directly
on the CPU. There may be separate registers for data, instructions, and
addresses. For example, the Intel CPU has a total of eight registers for
storing 32-bit data:
:::

::: paragraph
`%eax`, `%ebx`, `%ecx`, `%edx`, `%edi`, `%esi`, `%esp`, and `%ebp`.
:::

::: paragraph
Programs can read from or write to all eight of these registers. The
first six registers all hold general-purpose data, whereas the last two
are typically reserved by the compiler to hold address data. While a
program may interpret a general-purpose register's contents as integers
or as addresses, the register itself makes no distinction. The last two
registers (`%esp` and `%ebp`) are known as the **stack pointer** and the
**frame pointer**, respectively. The compiler reserves these registers
for operations that maintain the layout of the program stack. Typically,
`%esp` points to the top of the program stack, whereas `%ebp` points to
the base of the current stack frame. We discuss stack frames and these
two registers in greater detail in our discussion on
[functions](functions.html#_functions_in_assembly){.page}.
:::

::: paragraph
The last register worth mentioning is `%eip` or the **instruction
pointer**, sometimes called the **program counter** (PC). It points to
the next instruction to be executed by the CPU. Unlike the eight
registers mentioned previously, programs cannot write directly to
register `%eip`.
:::
:::

::: sect2
### [](#_advanced_register_notation){.anchor}8.1.2. Advanced Register Notation {#_advanced_register_notation}

::: paragraph
For the first six registers mentioned, the ISA provides a mechanism to
access the lower 16 bits of each register. The ISA also provides a
separate mechanism to access the 8-bit components of the lower 16 bits
of the first four of these registers. [Table 1](#RegisterList32) lists
each of the six registers and the ISA mechanisms (if available) to
access their component bytes.
:::

+-----------------+-----------------+-----------------+-----------------+
| 32-bit register | Lower 16 bits   | Bits 15-8       | Bits 7-0        |
| (bits 31-0)     | (bits 15-0)     |                 |                 |
+=================+=================+=================+=================+
| `%eax`          | `%ax`           | `%ah`           | `%al`           |
+-----------------+-----------------+-----------------+-----------------+
| `%ebx`          | `%bx`           | `%bh`           | `%bl`           |
+-----------------+-----------------+-----------------+-----------------+
| `%ecx`          | `%cx`           | `%ch`           | `%cl`           |
+-----------------+-----------------+-----------------+-----------------+
| `%edx`          | `%dx`           | `%dh`           | `%dl`           |
+-----------------+-----------------+-----------------+-----------------+
| `%edi`          | `%di`           |                 |                 |
+-----------------+-----------------+-----------------+-----------------+
| `%esi`          | `%si`           |                 |                 |
+-----------------+-----------------+-----------------+-----------------+

: Table 1. x86 Registers and Mechanisms for Accessing Lower Bytes.

::: paragraph
The lower 16 bits for any of the aforementioned registers can be
accessed by referencing the last two letters in the register's name. For
example, use `%ax` to access the lower 16 bits of `%eax`.
:::

::: paragraph
The *higher* and *lower* bytes within the lower 16 bits of the first
four listed registers can be accessed by taking the last two letters of
the register name and replacing the last letter with either an `h` (for
*higher*) or an `l` (for *lower*) depending on which byte is desired.
For example, `%al` references the lower eight bits of register `%ax`,
whereas `%ah` references the higher eight bits of register `%ax`. These
eight bit registers are commonly used by the compiler for storing
single-byte values for certain operations, such as bitwise shifts (a
32-bit register cannot be shifted more than 32 places and the number 32
requires only a single byte of storage). In general, the compiler will
use the smallest component register needed to complete an operation.
:::
:::

::: sect2
### [](#_instruction_structure){.anchor}8.1.3. Instruction Structure {#_instruction_structure}

::: paragraph
Each instruction consists of an operation code (or **opcode**) that
specifies what it does, and one or more **operands** that tell the
instruction how to do it. For example, the instruction `add $0x2, %eax`
has the opcode `add` and the operands `$0x2` and `%eax`.
:::

::: paragraph
Each operand corresponds to a source or destination location for a
specific operation. There are multiple types of operands:
:::

::: ulist
-   **Constant (literal)** values are preceded by the `$` sign. For
    example in the instruction `add $0x2, %eax`, `$0x2` is a literal
    value that corresponds to the hexadecimal value 0x2.

-   **Register** forms refer to individual registers. The instruction
    `add  $0x2, %eax` specifies register `%eax` as the destination
    location where the result %of the `add` operation will be stored.

-   **Memory** forms correspond to some value inside main memory (RAM)
    and are commonly used for address lookups. Memory address forms can
    contain a combination of registers and constant values. For example,
    in the instruction `mov 0x8(%ebp),%eax`, the operand `0x8(%ebp)` is
    an example of a memory form. It loosely translates to \"add 0x8 to
    the value in register `%ebp`, and then perform a memory lookup.\" If
    this sounds like a pointer dereference, that's because it is!
:::
:::

::: sect2
### [](#_an_example_with_operands){.anchor}8.1.4. An Example with Operands {#_an_example_with_operands}

::: paragraph
The best way to explain operands in detail is to present a quick
example. Suppose that memory contains the following values:
:::

+-----------------------------------+-----------------------------------+
| Address                           | Value                             |
+===================================+===================================+
| 0x804                             | 0xCA                              |
+-----------------------------------+-----------------------------------+
| 0x808                             | 0xFD                              |
+-----------------------------------+-----------------------------------+
| 0x80c                             | 0x12                              |
+-----------------------------------+-----------------------------------+
| 0x810                             | 0x1E                              |
+-----------------------------------+-----------------------------------+

::: paragraph
Let's also assume that the following registers contain values:
:::

+-----------------------------------+-----------------------------------+
| Register                          | Value                             |
+===================================+===================================+
| %eax                              | 0x804                             |
+-----------------------------------+-----------------------------------+
| %ebx                              | 0x10                              |
+-----------------------------------+-----------------------------------+
| %ecx                              | 0x4                               |
+-----------------------------------+-----------------------------------+
| %edx                              | 0x1                               |
+-----------------------------------+-----------------------------------+

::: paragraph
Then the operands in [Table 2](#Operands32) evaluate to the values
shown. Each row of the table matches an operand with its form (e.g.
constant, register, memory), how it is translated, and its value. Note
that the notation M\[x\] in this context denotes the value at the memory
location specified by address x.
:::

+-----------------+-----------------+-----------------+-----------------+
| Operand         | Form            | Translation     | Value           |
+=================+=================+=================+=================+
| %ecx            | Register        | %ecx            | 0x4             |
+-----------------+-----------------+-----------------+-----------------+
| (%eax)          | Memory          | M\[%eax\] or    | 0xCA            |
|                 |                 | M\[0x804\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| \$0x808         | Constant        | 0x808           | 0x808           |
+-----------------+-----------------+-----------------+-----------------+
| 0x808           | Memory          | M\[0x808\]      | 0xFD            |
+-----------------+-----------------+-----------------+-----------------+
| 0x8(%eax)       | Memory          | M\[%eax + 8\]   | 0x12            |
|                 |                 | or M\[0x80c\]   |                 |
+-----------------+-----------------+-----------------+-----------------+
| (%eax, %ecx)    | Memory          | M\[%eax +       | 0xFD            |
|                 |                 | %ecx\] or       |                 |
|                 |                 | M\[0x808\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| 0x4(%eax, %ecx) | Memory          | M\[%eax +       | 0x12            |
|                 |                 | %ecx + 4\] or   |                 |
|                 |                 | M\[0x80c\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| 0x800(,%edx,4)  | Memory          | M\[0x800 +      | 0xCA            |
|                 |                 | %edx\*4\] or    |                 |
|                 |                 | M\[0x804\]      |                 |
+-----------------+-----------------+-----------------+-----------------+
| (%eax, %edx, 8) | Memory          | M\[%eax +       | 0x12            |
|                 |                 | %edx\*8\] or    |                 |
|                 |                 | M\[0x80c\]      |                 |
+-----------------+-----------------+-----------------+-----------------+

: Table 2. Example operands

::: paragraph
In [Table 2](#Operands32), the notation `%ecx` indicates the value
stored in register `%ecx`. In contrast, M\[`%eax`\] indicates that the
value inside `%eax` should be treated as an address, and to dereference
(look up) the value at that address. Therefore, the operand `(%eax)`
corresponds to M\[0x804\], which corresponds to the value 0xCA.
:::

::: paragraph
A few important notes before continuing. While [Table 2](#Operands32)
shows many valid operand forms, not all forms can be used
interchangeably in all circumstances.
:::

::: paragraph
Specifically:
:::

::: ulist
-   Constant forms cannot serve as destination operands.

-   Memory forms cannot serve *both* as the source and destination
    operand in a single instruction.

-   In cases of scaling operations (see the last two operands in [Table
    2](#Operands32)), the scaling factor must be one of 1, 2, 4, or 8.
:::

::: paragraph
[Table 2](#Operands32) is provided as a reference; however,
understanding key operand forms will help improve the reader's speed in
parsing assembly language.
:::
:::

::: sect2
### [](#_instruction_suffixes){.anchor}8.1.5. Instruction Suffixes {#_instruction_suffixes}

::: paragraph
In several cases in upcoming examples, common and arithmetic
instructions have a suffix that indicates the *size* (associated with
the *type*) of the data being operated on at the code level. The
compiler automatically translates code to instructions with the
appropriate suffix. [Table 3](#Suffixes32) shows the common suffixes for
x86 instructions.
:::

+----------------------+----------------------+-----------------------+
| Suffix               | C Type               | Size (bytes)          |
+======================+======================+=======================+
| b                    | `char`               | 1                     |
+----------------------+----------------------+-----------------------+
| w                    | `short`              | 2                     |
+----------------------+----------------------+-----------------------+
| l                    | `int`, `long`,       | 4                     |
|                      | `unsigned`           |                       |
+----------------------+----------------------+-----------------------+

: Table 3. Example Instruction Suffixes

::: paragraph
Note that instructions involved with conditional execution have
different suffixes based on the evaluated condition. We cover
instructions associated with conditional instructions in a [later
section](conditional_control_loops.html#_conditional_control_and_loops){.page}.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
