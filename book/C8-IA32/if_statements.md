
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](index.html){.nav-link}
        -   [8.1. Assembly Basics](basics.html){.nav-link}
        -   [8.2. Common Instructions](common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [8.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [8.4.2. If Statements](if_statements.html){.nav-link}
            -   [8.4.3. Loops](loops.html){.nav-link}
        -   [8.5. Functions in Assembly](functions.html){.nav-link}
        -   [8.6. Recursion](recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [8.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [8.9. Structs in Assembly](structs.html){.nav-link}
        -   [8.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [8. 32-bit x86 Assembly](index.html)
-   [8.4. Conditional Control and Loops](conditional_control_loops.html)
-   [8.4.2. If Statements](if_statements.html)
:::

::: content
::: sect2
### [](#_if_statements_in_assembly){.anchor}8.4.2. if Statements in Assembly {#_if_statements_in_assembly}

::: paragraph
Let's take a look at the `getSmallest` function in assembly. For
convenience, the function is reproduced here.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest(int x, int y) {
    int smallest;
    if ( x > y ) {
        smallest = y;
    }
    else {
        smallest = x;
    }
    return smallest;
}
```
:::
:::

::: paragraph
The corresponding assembly code extracted from GDB looks similar to the
following:
:::

::: listingblock
::: content
    (gdb) disas getSmallest
    Dump of assembler code for function getSmallest:
      0x8048411 <+6>:   mov    0x8(%ebp),%eax
      0x8048414 <+9>:   cmp    0xc(%ebp),%eax
      0x8048417 <+12>:  jle    0x8048421 <getSmallest+22>
      0x8048419 <+14>:  mov    0xc(%ebp),%eax
      0x804841f <+20>:  jmp    0x8048427 <getSmallest+28>
      0x8048421 <+22>:  mov    0x8(%ebp),%eax
      0x8048427 <+28>:  ret
:::
:::

::: paragraph
This is a different view of the assembly code than we have seen before.
Here, we can see the *address* associated with each instruction, but not
the *bytes*. Note that this assembly segment has been lightly edited for
the sake of simplicity. The instructions that are normally part of
function creation/termination (i.e., `push %ebp` and `mov %esp, %ebp`)
and for allocating space on the stack are removed. By convention, GCC
places the first and second parameters of a function at locations
`%ebp+8` and `%ebp+0xc` (or `%ebp+12`), respectively. For the sake of
clarity, we refer to these parameters as `x` and `y` respectively.
:::

::: paragraph
Let's trace through the first few lines of the previous assembly code
snippet. Note that we will not draw out the stack explicitly in this
example. We leave this as an exercise for the reader, and encourage you
to practice your stack tracing skills by drawing it out yourself.
:::

::: ulist
-   The `mov` instruction copies the value located at address `%ebp+8`
    (the first parameter, `x`) and places it in register `%eax`. The
    instruction pointer (`%eip`) is set to the address of the next
    instruction, or 0x08048414.

-   The `cmp` instruction compares the value at location `%ebp+12` (the
    second parameter, `y`) to `x` and sets appropriate condition code
    flag registers. Register `%eip` advances to the address of the next
    instruction, or 0x08048417.

-   The `jle` instruction on the third line indicates that if `x` is
    less than or equal to `y`, the next instruction that executes is at
    location `<getSmallest+22>` (or `mov 0x8(%ebp), %eax`) and that
    `%eip` should be set to address 0x8048421. Otherwise, `%eip` is set
    to the next instruction in sequence, or 0x8048419.
:::

::: paragraph
The next instructions to execute depend on whether the program follows
the branch (i.e., executes the jump) on line 3 (`<getSmallest+12>`).
Let's first suppose that the branch was *not* followed. In this case,
`%eip` is set to 0x8048419 (i.e., `<getSmallest+14>`) and the following
sequence of instructions executes:
:::

::: ulist
-   The `mov 0xc(%ebp),%eax` instruction at `<getSmallest+14>` copies
    `y` to register `%eax`. Register `%eip` advances to 0x804841f.

-   The `jmp` instruction sets register `%eip` to address 0x8048427.

-   The last instruction to execute is the `ret` instruction, signifying
    the end of the function. In this case, `%eax` contains `y`, and
    `getSmallest` returns `y`.
:::

::: paragraph
Now, suppose that the branch was taken at `<getSmallest+12>`. In other
words, the `jle` instruction sets register `%eip` to 0x8048421 (i.e.,
`<getSmallest+22>`). Then, the next instructions to execute are:
:::

::: ulist
-   The `mov 0x8(%ebp),%eax` instruction at address 0x8048421, which
    copies the `x` to register `%eax`. Register `%eip` advances to
    0x8048427.

-   The last instruction that executes is `ret`, signifying the end of
    the function. In this case, `%eax` contains `x`, and `getSmallest`
    returns `x`.
:::

::: paragraph
We can then annotate the preceding assembly as follows:
:::

::: listingblock
::: content
    0x8048411 <+6>:  mov 0x8(%ebp),%eax             #copy x to %eax
    0x8048414 <+9>:  cmp 0xc(%ebp),%eax             #compare x with y
    0x8048417 <+12>: jle 0x8048421 <getSmallest+22> #if x<=y goto<getSmallest+22>
    0x8048419 <+14>: mov 0xc(%ebp),%eax             #copy y to %eax
    0x804841f <+20>: jmp 0x8048427 <getSmallest+28> #goto <getSmallest+28>
    0x8048421 <+22>: mov 0x8(%ebp),%eax             #copy x to %eax
    0x8048427 <+28>: ret                            #exit function (return %eax)
:::
:::

::: paragraph
Translating this back to C code yields:
:::

+-----------------------------------+-----------------------------------+
| goto Form                         | Translated C code                 |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int getSmallest(int x, int y) {   | int getSmallest(int x, int y) {   |
|     int smallest;                 |     int smallest;                 |
|     if (x <= y) {                 |     if (x <= y) {                 |
|         goto assign_x;            |         smallest = x;             |
|     }                             |     }                             |
|     smallest = y;                 |     else {                        |
|     goto done;                    |         smallest = y;             |
|                                   |     }                             |
| assign_x:                         |     return smallest;              |
|     smallest = x;                 | }                                 |
|                                   | ```                               |
| done:                             | :::                               |
|     return smallest;              | :::                               |
| }                                 | :::                               |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 1. Translating `getSmallest` into goto C form and C code.

::: paragraph
In [Table 1](#TranslateSmallest32), the variable `smallest` corresponds
to register `%eax`. If `x` is less than or equal to `y`, the code
executes the statement `smallest = x`, which is associated with the
`goto` label `assign_x` in our `goto` form of this function. Otherwise,
the statement `smallest = y` is executed. The `goto` label `done` is
used to indicate that the value in `smallest` should be returned.
:::

::: paragraph
Notice that the preceding C translation of the assembly code is a bit
different from the original `getSmallest` function. These differences
don't matter; a close inspection of both functions reveals that the two
programs are logically equivalent. However, the compiler first converts
any `if` statement into an equivalent `goto` form, which results in the
slightly different, but equivalent, version. [Table
2](#StandardGotoIf32) shows the standard `if` statement format and its
equivalent `goto` form:
:::

+-----------------------------------+-----------------------------------+
| C `if`-statement                  | Compiler's equivalent `goto` form |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| if (condition) {                  |     if (!condition) {             |
|     then_statement;               |         goto else;                |
| }                                 |     }                             |
| else {                            |     then_statement;               |
|     else_statement;               |     goto done;                    |
| }                                 | else:                             |
| ```                               |     else_statement;               |
| :::                               | done:                             |
| :::                               | ```                               |
| :::                               | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 2. Standard `if`-statement format and its equivalent `goto`
form.

::: paragraph
Compilers translating code into assembly designate a jump when a
condition is true. Contrast this behavior with the structure of an `if`
statement, where a \"jump\" (to the `else`) occurs when conditions are
*not* true. The `goto` form captures this difference in logic.
:::

::: paragraph
Considering the original `goto` translation of the `getSmallest`
function, we can see that:
:::

::: ulist
-   `x <= y` corresponds to `!condition`.

-   `smallest = x` is the `else_statement`.

-   The line `smallest = y` is the `then_statement`.

-   The last line in the function is `return smallest`.
:::

::: paragraph
Rewriting the original version of the function with the preceding
annotations yields:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest(int x, int y) {
    int smallest;
    if (x > y) {     //!(x <= y)
        smallest = y; //then_statement
    }
    else {
        smallest = x; //else_statement
    }
    return smallest;
}
```
:::
:::

::: paragraph
This version is identical to the original `getSmallest` function. Keep
in mind that a function written in different ways in the C language can
translate to the same set of assembly instructions.
:::

::: sect3
#### [](#_the_cmov_instructions){.anchor}The cmov Instructions {#_the_cmov_instructions}

::: paragraph
The last set of conditional instructions we cover are **conditional
move** (`cmov`) instructions. The `cmp`, `test`, and `jmp` instructions
implement a *conditional transfer of control* in a program. In other
words, the execution of the program branches in many directions. This
can be very problematic for optimizing code, because these branches are
very expensive.
:::

::: paragraph
In contrast, the `cmov` instruction implements a *conditional transfer
of data*. In other words, both the `then`-statement\` and
`else`-statement\` of the conditional are executed, and the data is
placed in the appropriate register based on the result of the condition.
:::

::: paragraph
The use of C's **ternary expression** often results in the compiler
generating a `cmov` instruction in place of jumps. For the standard
if-then-else statement, the ternary expression has the form:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
result = (condition) ? then_statement : else_statement;
```
:::
:::

::: paragraph
Let's use this format to rewrite the `getSmallest` function as a ternary
expression. Keep in mind that this new version of the function behaves
exactly as the original `getSmallest` function:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int getSmallest_cmov(int x, int y) {
    return x > y ? y : x;
}
```
:::
:::

::: paragraph
Although this may not seem like a big change, let's look at the
resulting assembly. Recall that the first and second parameters (`x` and
`y`) are stored at stack addresses `%ebp+0x8` and `%ebp+0xc`,
respectively.
:::

::: listingblock
::: content
    0x08048441 <+0>:   push   %ebp              #save ebp
    0x08048442 <+1>:   mov    %esp,%ebp         #update ebp
    0x08048444 <+3>:   mov    0xc(%ebp),%eax    #copy y to %eax
    0x08048447 <+6>:   cmp    %eax,0x8(%ebp)    #compare x with y
    0x0804844a <+9>:   cmovle 0x8(%ebp),%eax    #if (x <= y) copy x to %eax
    0x0804844e <+13>:  pop    %ebp              #restore %ebp
    0x0804844f <+14>:  ret                      #return %eax
:::
:::

::: paragraph
This assembly code has no jumps. After the comparison of `x` and `y`,
`x` moves into the return register only if `x` is less than or equal to
`y`. Like the jump instructions, the suffix of the `cmov` instructions
indicates the condition on which the conditional move occurs. [Table
3](#CmovInstr32) lists the set of conditional move instructions.
:::

+----------------------+----------------------+-----------------------+
| Signed               | Unsigned             | Description           |
+======================+======================+=======================+
| `cmove` (`cmovz`)    |                      | move if equal (==)    |
+----------------------+----------------------+-----------------------+
| `cmovne` (`cmovnz`)  |                      | move if not equal     |
|                      |                      | (!=)                  |
+----------------------+----------------------+-----------------------+
| `cmovs`              |                      | move if negative      |
+----------------------+----------------------+-----------------------+
| `cmovns`             |                      | move if non-negative  |
+----------------------+----------------------+-----------------------+
| `cmovg` (`cmovnle`)  | `cmova` (`cmovnbe`)  | move if greater (\>)  |
+----------------------+----------------------+-----------------------+
| `cmovge` (`cmovnl`)  | `cmovae` (`cmovnb`)  | move if greater than  |
|                      |                      | or equal (\>=)        |
+----------------------+----------------------+-----------------------+
| `cmovl` (`cmovnge`)  | `cmovb` (`cmovnae`)  | move if less (\<)     |
+----------------------+----------------------+-----------------------+
| `cmovle` (`cmovng`)  | `cmovbe` (`cmovna`)  | move if less than or  |
|                      |                      | equal (\<=)           |
+----------------------+----------------------+-----------------------+

: Table 3. The cmov Instructions.

::: paragraph
The compiler is very cautious about converting jump instructions into
`cmov` instructions, especially in cases where side effects and pointer
values are involved. [Table 4](#incrementX32) shows two equivalent ways
of writing a function, `incrementX`:
:::

+-----------------------------------+-----------------------------------+
| C code                            | C ternary form                    |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| int incrementX(int * x) {         | int incrementX2(int * x){         |
|     if                            |     return x ? (*x)++ : 1;        |
|  (x != NULL) { //if x is not NULL | }                                 |
|                                   | ```                               |
|      return (*x)++; //increment x | :::                               |
|     }                             | :::                               |
|     else { //if x is NULL         | :::                               |
|         return 1; //return 1      |                                   |
|     }                             |                                   |
| }                                 |                                   |
| ```                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
| :::                               |                                   |
+-----------------------------------+-----------------------------------+

: Table 4. Two functions that attempt to increment the value of integer
`x`.

::: paragraph
Each function takes a pointer to an integer as input and checks whether
it is `NULL`. If `x` is not `NULL`, the function increments and returns
the dereferenced value of `x`. Otherwise, the function returns the value
1.
:::

::: paragraph
It is tempting to think that `incrementX2` uses a `cmov` instruction
because it uses a ternary expression. However, both functions yield the
exact same assembly code:
:::

::: listingblock
::: content
    0x80484cf <+0>:   push   %ebp
    0x80484d0 <+1>:   mov    %esp,%ebp
    0x80484d2 <+3>:   cmpl   $0x0,0x8(%ebp)
    0x80484d6 <+7>:   je     0x80484e7 <incrementX2+24>
    0x80484d8 <+9>:   mov    0x8(%ebp),%eax
    0x80484db <+12>:  mov    (%eax),%eax
    0x80484dd <+14>:  lea    0x1(%eax),%ecx
    0x80484e0 <+17>:  mov    0x8(%ebp),%edx
    0x80484e3 <+20>:  mov    %ecx,(%edx)
    0x80484e5 <+22>:  jmp    0x80484ec <incrementX2+29>
    0x80484e7 <+24>:  mov    $0x1,%eax
    0x80484ec <+29>:  pop    %ebp
    0x80484ed <+30>:  ret
:::
:::

::: paragraph
Recall that the `cmov` instruction *executes both branches of the
conditional*. In other words, `x` gets dereferenced no matter what.
Consider the case where `x` is a null pointer. Recall that dereferencing
a null pointer leads to a null pointer exception in the code, causing a
segmentation fault. To prevent any chance of this happening, the
compiler takes the safe road and uses jumps.
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
