
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](index.html){.nav-link}
        -   [8.1. Assembly Basics](basics.html){.nav-link}
        -   [8.2. Common Instructions](common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](conditional_control_loops.html){.nav-link}
            -   [8.4.1. Preliminaries](preliminaries.html){.nav-link}
            -   [8.4.2. If Statements](if_statements.html){.nav-link}
            -   [8.4.3. Loops](loops.html){.nav-link}
        -   [8.5. Functions in Assembly](functions.html){.nav-link}
        -   [8.6. Recursion](recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](arrays.html){.nav-link}
        -   [8.8. Matrices in Assembly](matrices.html){.nav-link}
        -   [8.9. Structs in Assembly](structs.html){.nav-link}
        -   [8.10. Buffer Overflows](buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [8. 32-bit x86 Assembly](index.html)
-   [8.5. Functions in Assembly](functions.html)
:::

::: content
::: sect1
## [](#_functions_in_assembly){.anchor}8.5. Functions in Assembly {#_functions_in_assembly}

::: sectionbody
::: paragraph
In the previous section, we traced through simple functions in assembly.
In this section, we discuss the interaction between multiple functions
in assembly in the context of a larger program. We also introduce some
new instructions involved with function management.
:::

::: paragraph
Let's begin with a refresher on how the call stack is managed. Recall
that `%esp` is the **stack pointer** and always points to the top of the
stack. The register `%ebp` represents the base pointer (also known as
the **frame pointer**) and points to the base of the current stack
frame. The **stack frame** (also known as the **activation frame** or
the **activation record**) refers to the portion of the stack allocated
to a single function call. The currently executing function is always at
the top of the stack, and its stack frame is referred to as the **active
frame**. The active frame is bounded by the stack pointer (at the top of
stack) and the frame pointer (at the bottom of the frame). The
activation record typically holds local variables and parameters for a
function.
:::

::: paragraph
[Figure 1](#StackFrame32) shows the stack frames for `main` and a
function it calls named `fname`. We will refer to the `main` function as
the *caller* function and `fname` as the *callee* function.
:::

::: {#StackFrame32 .imageblock .text-center}
::: content
![an illustration of stack frames](_images/stackFrame.png){width="700"}
:::

::: title
Figure 1. Stack frame management
:::
:::

::: paragraph
In [Figure 1](#StackFrame32), the current active frame belongs to the
callee function (`fname`). The memory between the stack pointer and the
frame pointer is used for local variables. The stack pointer moves as
local values are pushed and popped from the stack. In contrast, the
frame pointer remains relatively constant, pointing to the beginning
(the bottom) of the current stack frame. As a result, compilers like GCC
commonly reference values on the stack relative to the frame pointer. In
[Figure 1](#StackFrame32), the active frame is bounded below by the base
pointer of `fname`, which contains the stack address 0x418. The value
stored at this address is the \"saved\" `%ebp` value (0x42c), which
itself indicates the bottom of the activation frame for the `main`
function. The top of the activation frame of `main` is bounded by the
**return address**, which indicates the program address at which `main`
resumes execution once the callee function finishes executing.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | The return address points to      |
|                                   | program memory, not stack memory  |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Recall that the call stack region |
|                                   | (stack memory) of a program is    |
|                                   | different from its code region    |
|                                   | (code memory). Whereas `%ebp` and |
|                                   | `%esp` point to locations in the  |
|                                   | stack memory, `%eip` points to a  |
|                                   | location in *code* memory. In     |
|                                   | other words, the return address   |
|                                   | is an address in code memory, not |
|                                   | stack memory:                     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: {#ProgramMe                   |
|                                   | mory632 .imageblock .text-center} |
|                                   | ::: content                       |
|                                   | ![The parts of a program's        |
|                                   | address                           |
|                                   | space.](_                         |
|                                   | images/memparts.png){width="450"} |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: title                         |
|                                   | Figure 2. The parts of a          |
|                                   | program's address space           |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
[Table 1](#FunctionManagement32) contains several additional
instructions that the compiler uses for basic function management.
:::

+-----------------------------------+-----------------------------------+
| Instruction                       | Translation                       |
+===================================+===================================+
| `leave`                           | ::: content                       |
|                                   | ::: paragraph                     |
|                                   | Prepares the stack for leaving a  |
|                                   | function. Equivalent to:          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |     mov %ebp, %esp                |
|                                   |     pop %ebp                      |
|                                   | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
| `call addr <fname>`               | ::: content                       |
|                                   | ::: paragraph                     |
|                                   | Switches active frame to callee   |
|                                   | function. Equivalent to:          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |     push %eip                     |
|                                   |     mov addr, %eip                |
|                                   | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
| `ret`                             | ::: content                       |
|                                   | ::: paragraph                     |
|                                   | Restores active frame to caller   |
|                                   | function. Equivalent to:          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |     pop %eip                      |
|                                   | :::                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+

: Table 1. Common Function Management Instructions

::: paragraph
For example, the `leave` instruction is a shorthand that the compiler
uses to restore the stack and frame pointers as it prepares to leave a
function. When the callee function finishes execution, `leave` ensures
that the frame pointer is *restored* to its previous value.
:::

::: paragraph
The `call` and `ret` instructions play a prominent role in the process
where one function calls another. Both instructions modify the
instruction pointer (register `%eip`). When the caller function executes
the `call` instruction, the current value of `%eip` is saved on the
stack to represent the return address, or the program address at which
the caller resumes executing once the callee function finishes. The
`call` instruction also replaces the value of `%eip` with the address of
the callee function.
:::

::: paragraph
The `ret` instruction restores the value of `%eip` to the value saved on
the stack, ensuring that the program resumes execution at the program
address specified in the caller function. Any value returned by the
callee is stored in `%eax`. The `ret` instruction is usually the last
instruction that executes in any function.
:::

::: sect2
### [](#_tracing_through_an_example){.anchor}8.5.1. Tracing Through an Example {#_tracing_through_an_example}

::: paragraph
Using our knowledge of function management, let's trace through the code
example first introduced at the beginning of this chapter.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

int assign(void) {
    int y = 40;
    return y;
}

int adder(void) {
    int a;
    return a + 2;
}

int main(void) {
    int x;
    assign();
    x = adder();
    printf("x is: %d\n", x);
    return 0;
}
```
:::
:::

::: paragraph
We compile the code with the `-m32` flag and use `objdump -d` to view
the underlying assembly. The latter command outputs a pretty big file
that contains a lot of information that we don't need. Use `less` and
the search functionality to extract the `adder`, `assign`, and `main`
functions:
:::

::: listingblock
::: content
    804840d <assign>:
     804840d:       55                      push   %ebp
     804840e:       89 e5                   mov    %esp,%ebp
     8048410:       83 ec 10                sub    $0x10,%esp
     8048413:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%ebp)
     804841a:       8b 45 fc                mov    -0x4(%ebp),%eax
     804841d:       c9                      leave
     804841e:       c3                      ret

    0804841f <adder>:
     804841f:       55                      push   %ebp
     8048420:       89 e5                   mov    %esp,%ebp
     8048422:       83 ec 10                sub    $0x10,%esp
     8048425:       8b 45 fc                mov    -0x4(%ebp),%eax
     8048428:       83 c0 02                add    $0x2,%eax
     804842b:       c9                      leave
     804842c:       c3                      ret

    0804842d <main>:
     804842d:       55                      push   %ebp
     804842e:       89 e5                   mov    %esp,%ebp
     8048433:       83 ec 20                sub    $0x14,%esp
     8048436:       e8 d2 ff ff ff          call   804840d <assign>
     804843b:       e8 df ff ff ff          call   804841f <adder>
     8048440:       89 44 24 1c             mov    %eax,0xc(%esp)
     8048444:       8b 44 24 1c             mov    0xc(%esp),%eax
     8048448:       89 44 24 04             mov    %eax,0x4(%esp)
     804844c:       c7 04 24 f4 84 04 08    movl   $0x80484f4,(%esp)
     8048453:       e8 88 fe ff ff          call   80482e0 <printf@plt>
     8048458:       b8 00 00 00 00          mov    $0x0,%eax
     804845d:       c9                      leave
     804845e:       c3                      ret
:::
:::

::: paragraph
Each function begins with a symbolic label that corresponds to its
declared name in the program. For example, `<main>:` is the symbolic
label for the `main` function. The address of a function label is also
the address of the first instruction in that function. To save space in
the figures that follow, we truncate addresses to the lower 12 bits. So,
program address 0x804842d is shown as 0x42d.
:::
:::

::: sect2
### [](#_tracing_through_main){.anchor}8.5.2. Tracing Through main {#_tracing_through_main}

::: paragraph
[Figure 3](#initialMain32) shows the execution stack immediately prior
to the execution of `main`.
:::

::: {#initialMain32 .imageblock}
::: content
![slide1](_images/procedures/Slide1.png)
:::

::: title
Figure 3. The initial state of the CPU registers and call stack prior to
executing the main function
:::
:::

::: paragraph
Recall that the stack grows toward lower addresses. In this example,
`%ebp` is address 0x140, and `%esp` is address 0x130 (both of these
values are made up for this example). Registers `%eax` and `%edx`
initially contain junk values. The red (upper-left) arrow indicates the
currently executing instruction. Initially, `%eip` contains address
0x42d, which is the program memory address of the first line in the
`main` function. Let's trace through the program's execution together.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide2](_images/procedures/Slide2.png)
:::
:::

::: paragraph
The first instruction pushes the value of `ebp` onto the stack, saving
address 0x140. Since the stack grows toward lower addresses, the stack
pointer `%esp` updates to 0x12c, which is 4 bytes less than 0x130.
Register `%eip` advances to the next instruction in sequence.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide3](_images/procedures/Slide3.png)
:::
:::

::: paragraph
The next instruction (`mov %esp, %ebp`) updates the value of `%ebp` to
be the same as `%esp`. The frame pointer (`%ebp`) now points to the
start of the stack frame for the `main` function. `%eip` advances to the
next instruction in sequence.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide4](_images/procedures/Slide4.png)
:::
:::

::: paragraph
The `sub` instruction subtracts 0x14 from the address of our stack
pointer, \"growing\" the stack by 20 bytes. Register `%eip` advances to
the next instruction, which is the first `call` instruction.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide5](_images/procedures/Slide5.png)
:::
:::

::: paragraph
The `call <assign>` instruction pushes the value inside register `%eip`
(which denotes the address of the *next* instruction to execute) onto
the stack. Since the next instruction after `call <assign>` has the
address 0x43b, that value is pushed onto the stack as the return
address. Recall that the return address indicates the program address
where execution should resume when program execution returns to `main`.
:::

::: paragraph
Next, the `call` instruction moves the address of the `assign` function
(0x40d) into register `%eip`, signifying that program execution should
continue into the callee function `assign` and not the next instruction
in `main`.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide6](_images/procedures/Slide6.png)
:::
:::

::: paragraph
The first two instructions that execute in the `assign` function are the
usual book-keeping that every function performs. The first instruction
pushes the value stored in `%ebp` (memory address 0x12c) onto the stack.
Recall that this address points to the beginning of the stack frame for
`main`. `%eip` advances to the second instruction in `assign`.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide7](_images/procedures/Slide7.png)
:::
:::

::: paragraph
The next instruction (`mov %esp, %ebp`) updates `%ebp` to point to the
top of the stack, marking the beginning of the stack frame for `assign`.
The instruction pointer (`%eip`) advances to the next instruction in the
`assign` function.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide8](_images/procedures/Slide8.png)
:::
:::

::: paragraph
The `sub` instruction at address 0x410 grows the stack by 16 bytes,
creating extra space on the stack frame to store local values and
updating `%esp`. The instruction pointer again advances to the next
instruction in the `assign` function.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide9](_images/procedures/Slide9.png)
:::
:::

::: paragraph
The `mov` instruction at address 0x413 moves the value `$0x28` (or 40)
onto the stack at address `-0x4(%ebp)`, which is four bytes above the
frame pointer. Recall that the frame pointer is commonly used to
reference locations on the stack. `%eip` advances to the next
instruction in the `assign` function.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide10](_images/procedures/Slide10.png)
:::
:::

::: paragraph
The `mov` instruction at address 0x41a places the value `$0x28` into
register `%eax`, which holds the return value of the function. `%eip`
advances to the `leave` instruction in the `assign` function.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide11](_images/procedures/Slide11.png)
:::
:::

::: paragraph
At this point, the `assign` function has almost completed execution. The
next instruction that executes is the `leave` instruction, which
prepares the stack for returning from the function call. Recall that
`leave` is analogous to the following pair of instructions:
:::

::: listingblock
::: content
    mov %ebp, %esp
    pop %ebp
:::
:::

::: paragraph
In other words, the CPU overwrites the stack pointer with the frame
pointer. In our example, the stack pointer is initially updated from
0x100 to 0x110. Next, the CPU executes `pop %ebp`, which takes the value
located at 0x110 (in our example, the address 0x12c) and places it in
`%ebp`. Recall that 0x12c is the start of the stack frame for `main`.
`%esp` becomes 0x114 and `%eip` points to the `ret` instruction in the
`assign` function.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide12](_images/procedures/Slide12.png)
:::
:::

::: paragraph
The last instruction in `assign` is a `ret` instruction. When `ret`
executes, the return address is popped off the stack into register
`%eip`. In our example, `%eip` now advances to the call to the `adder`
function.
:::

::: paragraph
Some important things to notice at this juncture:
:::

::: ulist
-   The stack pointer and frame pointer have been restored to their
    values prior to the call to `assign`, reflecting that the stack
    frame for `main` is once again the active frame.

-   The old values on the stack from the prior active stack frame are
    *not* removed. They still exist on the call stack.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide13](_images/procedures/Slide13.png)
:::
:::

::: paragraph
The call to `adder` *overwrites* the old return address on the stack
with a new return address (0x440). This return address points to the
next instruction to be executed after `adder` returns, or
`mov %eax, 0xc(%ebp)`. `%eip` reflects the first instruction to execute
in `adder`, which is at address 0x41f.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide14](_images/procedures/Slide14.png)
:::
:::

::: paragraph
The first instruction in the `adder` function saves the caller's frame
pointer (`%ebp` of `main`) on the stack.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide15](_images/procedures/Slide15.png)
:::
:::

::: paragraph
The next instruction updates `%ebp` with the current value of `%esp`, or
address 0x110. Together, these last two instructions establish the
beginning of the stack frame for `adder`.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide16](_images/procedures/Slide16.png)
:::
:::

::: paragraph
The `sub` instruction at address 0x422 \"grows\" the stack by 16 bytes.
Notice again that growing the stack does not affect any previously
created values on the stack. Again, old values will litter the stack
until they are overwritten.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide20](_images/procedures/Slide17.png)
:::
:::

::: paragraph
Pay close attention to the next instruction that executes:
`mov $-0x4(%ebp), %eax`. This instruction moves an *old* value that is
on the stack into register `%eax`! This is a direct result of the fact
that the programmer forgot to initialize `a` in the function `adder`.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide18](_images/procedures/Slide18.png)
:::
:::

::: paragraph
The `add` instruction at address 0x428 adds 2 to register `%eax`. Recall
that IA32 passes the return value through register `%eax`. Together, the
last two instructions are equivalent to the following code in `adder`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int a;
return a + 2;
```
:::
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide19](_images/procedures/Slide19.png)
:::
:::

::: paragraph
After `leave` executes, the frame pointer again points to the beginning
of the stack frame for `main`, or address 0x12c. The stack pointer now
stores the address 0x114.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide20](_images/procedures/Slide20.png)
:::
:::

::: paragraph
The execution of `ret` pops the return address off the stack, restoring
the instruction pointer back to 0x440, or the address of the next
instruction to execute in `main`. The address of `%esp` is now 0x118.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide21](_images/procedures/Slide21.png)
:::
:::

::: paragraph
The `mov %eax, 0xc(%esp)` instruction places the value in `%eax` in a
location 12 bytes (three spaces) below `%esp`.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide23](_images/procedures/Slide23.png)
:::
:::

::: paragraph
Skipping ahead a little, the `mov` instructions at addresses 0x444 and
0x448 set `%eax` to the value saved at location `%esp+12` (or 0x2A) and
places 0x2A one spot below the top of the stack (address `%esp + 4`, or
0x11c).
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide24](_images/procedures/Slide24.png)
:::
:::

::: paragraph
The next instruction (`mov $0x80484f4, (%esp)`) copies a constant value
that is a memory address to the top of the stack. This particular memory
address, 0x80484f4, contains the string `"x is %d\n"`. The instruction
pointer advances to the call to the `printf` function (which is denoted
with the label `<printf@plt>`).
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide25](_images/procedures/Slide25.png)
:::
:::

::: paragraph
For the sake of brevity, we will not trace the `printf` function, which
is part of `stdio.h`. However, we know from the manual page
(`man -s3 printf`) that `printf` has the following format:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int printf(const char * format, ...)
```
:::
:::

::: paragraph
In other words, the first argument is a pointer to a string specifying
the format, and the second argument onward specify the values that are
used in that format. The instructions specified by addresses 0x444 -
0x45c correspond to the following line in the `main` function:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("x is %d\n", x);
```
:::
:::

::: paragraph
When the `printf` function is called:
:::

::: ulist
-   A return address specifying the instruction that executes after the
    call to `printf` is pushed onto the stack.

-   The value of `%ebp` is pushed onto the stack, and `%ebp` is updated
    to point to the top of the stack, indicating the beginning of the
    stack frame for `printf`.
:::

::: paragraph
At some point, `printf` references its arguments, which are the string
`"x is %d\n"` and the value 0x2A. Recall that the return address is
located directly below `%ebp` at location `%ebp+4`. The first argument
is thus located at `%ebp+8` (i.e., right *below* the return address),
and the second argument is located at `%ebp+12`.
:::

::: paragraph
For any function with *n* arguments, GCC places the first argument at
location `%ebp+8`, the second at `%ebp+12`, and the *n*^th^ argument at
location `(%ebp+8) + (4*(n-1))`.
:::

::: paragraph
After the call to `printf`, the value 0x2A is output to the user in
integer format. Thus, the value 42 is printed to the screen!
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide26](_images/procedures/Slide26.png)
:::
:::

::: paragraph
After the call to `printf`, the last few instructions clean up the stack
and prepare a clean exit from the `main` function. First, the value 0x0
is placed in register `%eax`, signifying that the value 0 is returned
from `main`. Recall that a program returns 0 to indicate correct
termination.
:::

------------------------------------------------------------------------

::: imageblock
::: content
![slide27](_images/procedures/Slide27.png)
:::
:::

::: paragraph
After `leave` and `ret` are executed, the stack and frame pointers
revert to their original values prior to the execution of `main`. With
0x0 in the return register `%eax`, the program returns 0.
:::

::: paragraph
If you have carefully read through this section, you should understand
why our program prints out the value 42. In essence, the program
inadvertently uses old values on the stack to cause it to behave in a
way that we didn't expect. While this example was pretty harmless, we
discuss in future sections how hackers have misused function calls to
make programs misbehave in truly malicious ways.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
