
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix Manual](man.html){.nav-link}
        -   [17.3. Remote Access](ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](editors.html){.nav-link}
        -   [17.5. make and Makefiles](makefiles.html){.nav-link}
        -   [17.6 Searching: grep and find](grep.html){.nav-link}
        -   [17.7 File Permissions](chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing Files](tar.html){.nav-link}
        -   [17.9 Process Control](pskill.html){.nav-link}
        -   [17.10 Timing](timing.html){.nav-link}
        -   [17.11 Command History](history.html){.nav-link}
        -   [17.12 I/0 Redirection](ioredirect.html){.nav-link}
        -   [17.13 Pipes](pipe.html){.nav-link}
        -   [17.14 Dot Files and .bashrc](dotfiles.html){.nav-link}
        -   [17.15 Shell Programming](shellprog.html){.nav-link}
        -   [17.16 Getting System Information](sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [17. Appendix 2: Using Unix](index.html)
-   [17.5. make and Makefiles](makefiles.html)
:::

::: content
::: sect1
## [](#_make_and_makefiles){.anchor}17.5. make and Makefiles {#_make_and_makefiles}

::: sectionbody
::: paragraph
In this section we discuss the `make` command and Makefiles. We present
some examples starting from simple Makefile and building up to a more
complex and more generic Makefile ([Section 17.5.10](#SampleMakefile))
that is a good starting point for most uses. For more information about
writing Makefiles see [the GNU Make
Manual](https://www.gnu.org/software/make/manual/).
:::

::: sect2
### [](#_about_make){.anchor}17.5.1. About make {#_about_make}

::: paragraph
The Unix `make` utility simplifies compiling programs. A user (or a
program) writes the Makefile with the rules to execute. A user just runs
`make` and the `make` program reads in rules from the `Makefile` that
tell it how to compile a program.
:::

::: paragraph
One benefit of `make` is that it can execute complex commands to build
executable files simply by typing `make` versus the user having to type
in long `gcc` commands to build each time. Larger programs are often
split into separate modules consisting of multiple `.c` and `.h` files.
They may also link in multiple libraries, or store header and library
files in non-standard locations. All of these make compiling more
complicated, and `gcc` command lines longer and more complex. In these
cases, manually typing the full `gcc` command line at the shell prompt
is both time consuming and error prone. For example, here is a long
`gcc` command line that would be tedious to type by hand:
:::

::: listingblock
::: content
    gcc -Wall -g  -I../includes -I. -o mycc emitter.c init.c lexer.c symbol.c parser.c ast.c error.c symbol_table.c codegen.c emitcode.c main.c -L../libs -lmylib -lpthread
:::
:::

::: paragraph
With `make` the user simply types `make` to execute the commands listed
in the Makefile.
:::

::: paragraph
Another benefit of `make` is that it only rebuilds those things that
need to be rebuilt \-\-- just the object and executable files that
depend on files that have been modified since the last time they were
built. For large programs, compiling everything from scratch can be very
time consuming, and thus `make` can save a lot of compilation time by
only rebuilding those things that need to be rebuilt.
:::

::: paragraph
A user typically writes the Makefile with the rules for `make` to
execute. There are also programs, like CMake and GNU Autotools, that
generate Makefiles. These are typically used for building large software
and for easily supporting compilation across different systems that
includes finding needed compilers and other software, libraries, and
header files on a particular system.
:::
:::

::: sect2
### [](#_using_make){.anchor}17.5.2. Using make {#_using_make}

::: paragraph
The steps for using `make` are:
:::

::: {.olist .arabic}
1.  Create a Makefile listing the rules for building the executable. By
    default the file should be named \'Makefile\'. This only has to be
    done once, except when new modules (.c or .h files) are added to the
    program, then the Makefile needs to be updated to add new module
    dependencies to existing rules or to add new rules to include them
    in compilation.

2.  After editing program file(s), rebuild the executable by typing
    make:

    ::: listingblock
    ::: content
        $ make
    :::
    :::

    ::: paragraph
    A specific rule in the Makefile can be executed by typing:
    :::

    ::: listingblock
    ::: content
        $ make target_label
    :::
    :::

    ::: paragraph
    For example, to execute the `rm` command to remove all built files
    in the example Makefile listed below, type:
    :::

    ::: listingblock
    ::: content
        $ make clean
    :::
    :::
:::
:::

::: sect2
### [](#_creating_a_makefile){.anchor}17.5.3. Creating a Makefile {#_creating_a_makefile}

::: paragraph
A Makefile typically starts with some variable definitions which are
then followed by a set of rules (or target entries) for building
specific targets (typically for building .o and executable files). Each
rule consists of a target label and a set of associated commands
(sometimes called recipes) that are run for the target. The following is
the general format of a rule:
:::

::: listingblock
::: content
    # comment
    # (note: the <tab> in the command line is necessary for make to work)
    target:  dependency1 dependency2 ...
          <tab> command
:::
:::

::: paragraph
Here is an example:
:::

::: listingblock
::: content
    # target entry to build program executable from program.o
    # and util.o object files
    #
    program: program.o util.o
        gcc -o program program.o util.o
:::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Make and whitespace characters    |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | `make` is very picky about        |
|                                   | whitespace characters. For        |
|                                   | example, the \<tab\> on the line  |
|                                   | before the command part of a      |
|                                   | Makefile target entry is very     |
|                                   | important for `make` to correctly |
|                                   | parse the target entry and        |
|                                   | execute the command part. If, for |
|                                   | example, you use space characters |
|                                   | in place of the \<tab\>, then     |
|                                   | `make` will not correctly parse   |
|                                   | the target entry and will not run |
|                                   | its associated command.           |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect2
### [](#simplemakefile){.anchor}17.5.4. A Simple Makefile {#simplemakefile}

::: paragraph
Here is an example simple Makefile that builds an executable from a
single .c file named `myprog.c`:
:::

::: listingblock
::: content
    # build an executable named myprog from myprog.c
    all: myprog.c
        gcc -g -Wall -o myprog myprog.c

    clean:
        rm myprog
:::
:::

::: paragraph
Typing `make` triggers the command associated with the `all` target
label to run `gcc -g -Wall -o myprog myprog.c` if the modification date
on the file `myprog.c` is newer than the modification date on the file
`myprog` or if `myprog` doesn't exist. Note that the name `all` isn't
special, by default `make` picks the first target label in the Makefile
to execute. To execute a specific rule other than the first one listed
in the makefile, list the target name on the `make` command line. For
example, `make clean` runs the `rm myprog` command to remove the
previously built executable file `myprog`.
:::

::: paragraph
In [Section 17.5.8](#genericsimple) we show how to use Makefile
variables to write more generic versions of this Makefile---​one that can
be copied and minimally edited to create a new Makefile for building a
different program.
:::
:::

::: sect2
### [](#simplemulti){.anchor}17.5.5. A Makefile for multiple source files {#simplemulti}

::: paragraph
Below is an example Makefile for building an executable from multiple
`.c` and `.h` files. It first compiles each `.c` into a `.o` file, and
then links the `.o` and libraries together to build the executable.
Because it lists dependencies for each `.o` file, if one `.c` file is
modified only one `.o` needs to be rebuilt (the one that is dependent on
the modified `.c`) and it does not rebuild all `.o` files. This is a
particularly nice feature that speeds up compile time for larger
programs consisting of many `.c` files.
:::

::: listingblock
::: content
    # Example Makefile for a program with many .c modules
    # make: build count executable program
    # make clean: clean-up all built files

    all: count

    # To create the executable file count we need the object files
    # countwords.o, counter.o, and scanner.o:
    count: countwords.o counter.o scanner.o
        gcc -g -Wall -o count countwords.o counter.o scanner.o

    # To create the object file countwords.o, we need the source
    # files countwords.c, scanner.h, and counter.h:
    countwords.o: countwords.c scanner.h counter.h
        gcc -g -Wall -c countwords.c

    # To create the object file counter.o, we need the source files
    # counter.c and counter.h:
    counter.o: counter.c counter.h
        gcc -g -Wall -c counter.c

    # To create the object file scanner.o, we need the source files
    # scanner.c and scanner.h:
    scanner.o: scanner.c scanner.h
        gcc -g -Wall -c scanner.c

    # To start over from scratch, type 'make clean'.  This
    # removes the executable file, as well as old .o object
    # files and *~ backup files:
    clean:
        rm -f count *.o *~
:::
:::

::: paragraph
After running `make` the first time, if the `counter.c` file is
modified, then on the next run of `make`, only these two rules are
executed (due to their dependency on `counter.c` or `counter.o`):
:::

::: listingblock
::: content
    counter.o: counter.c counter.h
        gcc -g -Wall -c counter.c

    count: countwords.o counter.o scanner.o
        gcc -g -Wall -o count countwords.o counter.o scanner.o
:::
:::

::: paragraph
In [Section 17.5.9](#genericmulti) and [Section
17.5.10](#SampleMakefile) we show how to use Makefile variables,
implicit Makefile rules, and automatic dependency generation, to write
more generic versions of a Makefile. The Makefile in [Section
17.5.10](#SampleMakefile) is a good generic Makefile for applications
built from many `.c` and `.h` files, and that may build with header
files or libraries stored in non-standard locations.
:::
:::

::: sect2
### [](#_make_errors){.anchor}17.5.6. make Errors {#_make_errors}

::: paragraph
Errors in `make` generally stem from one of two causes. The first are
errors in the syntax of the Makefile itself, and the second are
compilation errors either due to missing rules in the Makefile, or due
to errors in the program itself. When using `make` it can sometimes be
difficult to determine if you need to fix the Makefile or your program.
:::

::: paragraph
Errors in Makefile syntax will be reported with the line number in the
Makefile of the error to help you track down the syntax problem.
However, there are some common errors that are difficult to see because
they are related to errors with use of whitespace characters. Two
example of this type are:
:::

::: ulist
-   Using space characters instead of a `<tab>` at the start of the
    command part of a target entry. For example, if there are space
    characters at the beginning of this target entry's second line
    instead of a `<tab>` character, `make` cannot correctly parse this
    rule:

    ::: listingblock
    ::: content
        all: myprog.c
             $(CC) $(CFLAGS) $(INCLUDES) -o myprog myprog.c
    :::
    :::

-   Having extra spaces at the end of the prefix of a file name that the
    Makefile expands in other places by adding different suffixes to.
    For example:

    ::: listingblock
    ::: content
        TARGET = myprog
        SRC = $(TARGET).c
    :::
    :::

    ::: paragraph
    If there is trailing whitespace after `myprog`, then instead of
    `SRC` being `myprog.c` it will be something like `myprog  .c`, which
    is not a valid file name.
    :::
:::

::: paragraph
If the error is with compiling or linking, it could be due to errors in
your Makefile or due to an error in your program. Some examples Makefile
errors that cause compilation or linking errors include: a missing rule
to compile a `.o`; missing dependencies not forcing re-compilation;
missing explicitly linking in a needed library; or missing including
paths (`-I` or `-L`) to header file and library locations needed to
compile the program. Many of these errors will show up as `gcc` errors,
but require fixes to the Makefile instead of the program source.
:::

::: paragraph
Some tips to help you determine if the Makefile, the source code, or
both need to be fixed include:
:::

::: ulist
-   As a first step to see if you are missing a dependency, run
    `make clean` and then `make` to rebuild everything from scratch. If
    it is successful, a dependency is missing in the Makefile.

-   If you don't see a `.o` file that you need to link in, the problem
    is that you need to add a rule to build it (perhaps updating your
    `SRCS` definition to include this new file).

-   If there is an error with the compiler not being able to find a `.h`
    file, then this indicates that you need to update your `INCLUDES`
    variable to add a of the form `-I[path to include directory]` to
    tell make where to find them.

-   Similarly, if there are errors with the compiler not being able to
    find libraries (these show up as undefined errors during the final
    compilation stage, linking), you need to update your `LIBDIR` or
    `LIBS` definitions to include paths to libraries (`-L`) or to add to
    the command line any missing libraries that need to be linked in
    (`-l`).

-   In some cases when the error is in a C source file, such as missing
    `#include`, both the C source file and the Makefile may need to be
    updated to fix the error. For example, adding an `#include` to a C
    source file, may also result in updating the include (`-I`) path,
    and in some cases also a library path (`-L`) and explicitly linking
    in a library (`-l`) in the Makefile.
:::
:::

::: sect2
### [](#_parallel_make){.anchor}17.5.7. Parallel make {#_parallel_make}

::: paragraph
For large programs consisting of many `.c` and `.h` files, compiling can
take a long time. Much of the time can be due to compiling a `.o` file
from each `.c` file. Compiling each `.o` is independent of compiling
other `.o` files, and thus this is a good target for parallelization
where multiple threads or processes can simultaneously compile a
different `.c` file in parallel. Using the `-j[num]` command line option
to `make` tells it to run up to `num` jobs at a time, or to in parallel
simultaneously execute `num` different recipes.
:::

::: paragraph
For example, to parallelize `make` to perform 12 recipes at a time type:
:::

::: listingblock
::: content
    make -j12
:::
:::

::: paragraph
On a machine with 12 or more cores, this will run about twelve times
faster than `make`.
:::
:::

::: sect2
### [](#genericsimple){.anchor}17.5.8. Advanced: A Generic Simple Makefile {#genericsimple}

::: paragraph
We can rewrite the simple Makefile from [Section
17.5.4](#simplemakefile) to make it more generic. A generic Makefile is
one that is easier to edit for use for another program (typically users
start a new Makefile with a copy of an existing one that they then
modify versus writing one from scratch each time). This more generic
Makefile replaces the specific application file names in rules with
Makefile variables resulting in the rule being generic for any program.
The syntax for defining Makefile variables is
`<variable_name> = <value>`. For example:
:::

::: listingblock
::: content
    # define CC to be the name of the compiler
    CC = gcc
:::
:::

::: paragraph
Once defined, the Makefile variable can be used later in the Makefile
using `$(variable_name)` syntax. For example:
:::

::: listingblock
::: content
    # use the value of CC in a target entry:
    all:
        $(CC) -o myprog myprog.c
:::
:::

::: paragraph
Below is an example of a slightly more generic version of the simple
Makefile above to build an executable from a single .c file. This more
generic version of the simple Makefile specifies variables to indicate
which compiler to use (`CC`), the compiler flags to pass (`CFLAGS`, the
name of the `.c` source file (`SRCS`), and the name of the program
executable to build (`TARGET`). The `RM` variable is a builtin Makefile
variable that is defined to be the `rm` command. You can change the
value of any builtin variables by redefining them to be something else
in the Makefile.
:::

::: paragraph
By using Makefile variables, the result is that everything in the
Makefile starting with `all:` is generic and will work for any program.
Only the `SRCS` and `TARGET` variables need to be changed to build a
different program.
:::

::: listingblock
::: content
    # define the compiler: gcc for C programs
    CC = gcc

    # define the compiler flags:
    #  -g    adds debugging information to the executable file
    #  -Wall turns on most, but not all, compiler warnings
    CFLAGS  = -g -Wall

    # source file (could actually list multiple .c files here)
    SRCS = myprog.c

    # define the executable file (assume source is same name):
    TARGET = myprog

    # this is generic:
    all: $(TARGET)

    $(TARGET): $(SRCS)
        $(CC) $(CFLAGS) -o $(TARGET) $(SRCS)

    clean:
        $(RM) $(TARGET)
:::
:::

::: paragraph
This Makefile can also be used for building an executable from more than
one `.c` source file by just defining `SRCS` to list each `c` file. For
example, if the executable is built from two source files `myprog.c` and
`util.c`, define `SRCS` to be:
:::

::: listingblock
::: content
    SRCS = myprog.c util.c
:::
:::

::: paragraph
One thing to note about this Makefile is that it always recompiles the
executable from all source files listed in `SRCS` if any one of them
have been modified (because of this dependency: `$(TARGET): $(SRCS)`).
For small programs, that may consist of just one or a few `.c` files,
this may be fine. However, we can adjust the Makefile to have it only
rebuild parts that need to be rebuilt when a source file is modified. We
do this by adding rules to compile object files (`.o`) from each `.c`
file, and then to build the executable file from linking the `.o` files
(and any libraries) into the executable.
:::
:::

::: sect2
### [](#genericmulti){.anchor}17.5.9. Advanced: A Generic Makefile for Multiple Files {#genericmulti}

::: paragraph
We can rewrite the Makefile from [Section 17.5.5](#simplemulti) that
compiled an executable from multiple source files as a more generic
Makefile by making use of Makefile variables and pattern replacement
rules.
:::

::: paragraph
Note that the rules for building the `.o` files from the `.c` in the
orginal Makefile (in [Section 17.5.5](#simplemulti)) are all similar
except for the specific file names. It would be nice if we could
simplify this with a more generic rule for building `.o` from `.c`
files.
:::

::: paragraph
One way to do this is to use a pattern-replacement rule that is
triggered for any `.o` file built from a `.c` file. Below is an example
of such a rule. It uses makefile automatic variables `$<` for the name
of the dependency of the rule (a `.c` source file) and `$@` for the
target file (the `.o` object file). See the gnu make manual for more
information about automatic variables.
:::

::: listingblock
::: content
    # This is a pattern replacement rule for building .o files from their
    # associated .c files.  It uses automatic variables:
    #   $<  the name of the first dependency of the rule (a .c file)
    #   $@  the name of the target of the rule (a .o file)
    %.o : %.c
            $(CC) $(CFLAGS) -c $< -o $@
:::
:::

::: paragraph
This is a much shorter rule, and a generic rule, that will work for any
C Makefile.
:::

::: paragraph
However, we can do even better than this! Because compiling a `.o` from
a `.c` file is such a common build pattern, make has an implicit rule
for building `.o` files from `.c` files. If we want to use this implicit
rule, we don't add any rule for building .o files from .c files to our
makefile. The implicit rule is the following:
:::

::: listingblock
::: content
    # make's implicit rule for building .o files from .c:
    %.o : %.c
        $(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
:::
:::

::: paragraph
The implicit rule uses some makefile variables that have default values,
but that can also be redefined in the Makefile (and usually are):
:::

::: ulist
-   `CC`: defines the compiler (our Makefile defines `CC` to be `gcc`)

-   `CFLAGS`: defines compiler flags (our Makefile defines these to be
    `-g -Wall` which includes debugging information and turns on all
    warnings).

-   `CPPFLAGS`: defines preprocessor flags (our Makefile doesn't define
    any). The preprocessor is the first part of the compiler that runs.
    It expands anything starting with a `#`, like `#include`. Here is
    some more information about the [the phases of
    compilation](../C2-C_depth/advanced_libraries.html#_compilation_steps_){.page}.
:::

::: paragraph
Because we have a rule for building `$(TARGET)` that has a dependency
`$(OBJS)`, `make` will look for a rule for building object files (`.o`)
from source files (`.c` files), and it if doesn't find one in the
Makefile, it uses its implicit rule. If the implicit rule suffices, we
don't have to include any rule for building object files in our
Makefile! Instead we just define the makefile variables it uses (or use
its default definitions). If we don't like the implicit rule, then we
need to override it using our own rule.
:::

::: paragraph
The following is a version of the Makefile that uses the implicit rule
for building `.o` files (and note that everything in the Makefile
starting with `OBJS =` is generic!):
:::

::: listingblock
::: content
    # Example Makefile using make's implicit .c:.o rule
    #   make: build count executable program
    #   make clean: clean-up all built files

    # define the compiler
    CC = gcc

    # define compiler flags
    CFLAGS  = -g -Wall

    # define the executable file
    TARGET = count

    # define source files
    SRCS = countwords.c counter.c scanner.c

    # define the object files
    # This uses Suffix Replacement within a macro:
    #   $(name:str1=str2): for each word in 'name' replace 'str1' with 'str2'
    # Here replace the suffix .c of all words in the macro SRCS with .o suffix
    #
    OBJS = $(SRCS:.c=.o)

    # typing 'make' will invoke the first target entry in the file
    all: $(TARGET)

    # To create the executable file count we need the object files
    # countwords.o, counter.o, and scanner.o:
    #
    $(TARGET): $(OBJS)
        $(CC) $(CFLAGS) -o $(TARGET) $(OBJS)

    # using implicit rule to build .o files from .c!

    # clean up built files
    clean:
        $(RM) -f $(TARGET) *.o *~
:::
:::

::: paragraph
This is a short and generic Makefile. However, there is one subtle
problem with this that we don't have with the longer less generic
version: we have lost the dependencies of the header files on the object
files, meaning that if the user updates a header file and types `make`
the executable and .o files will not be rebuilt, but we want them to be.
To fix this problem, we can add additional dependencies to the Makefile
for `TARGET` and `OBJS` or for individual object files:
:::

::: listingblock
::: content
    # define a variable to be the set of header files
    HDRS = scanner.h counter.h

    # add a dependency to this rule:
    $(TARGET): $(OBJS)  $(HDRS)

    # add a generic dependency on all $(OBJS)
    # (note: no command part to this rule, it is just defining a dependency):
    $(OBJS): $(HDRS) $(SRCS)
:::
:::

::: paragraph
The resulting makefile looks like:
:::

::: listingblock
::: content
    # Example Makefile with implicit .c:.o rule and header file dependencies
    # make: build count executable program
    # make clean: clean-up all built files

    # define the compiler
    CC = gcc

    # define compiler flags
    CFLAGS  = -g -Wall

    # define source files
    SRCS = countwords.c counter.c scanner.c

    # define the object files
    # This uses Suffix Replacement within a macro:
    #   $(name:str1=str2): for each word in 'name' replace 'str1' with 'str2'
    # Here replace the suffix .c of all words in the macro SRCS with .o suffix
    #
    OBJS = $(SRCS:.c=.o)

    # define the header files
    HDRS = scanner.h counter.h

    # define the executable file
    TARGET = count

    # typing 'make' will invoke the first target entry in the file
    all: $(TARGET)

    # To create the executable file count we need the object files
    # countwords.o, counter.o, and scanner.o:
    #
    $(TARGET): $(OBJS) $(HDRS)
        $(CC) $(CFLAGS) -o $(TARGET) $(OBJS)

    $(OBJS): $(HDRS) $(SRCS)

    # clean up built files
    clean:
        $(RM) -f $(TARGET) *.o *~
:::
:::

::: paragraph
With added dependencies of .h files added, changes to either a .c or a
.h file will trigger rebuilding of .o and executable files. There is,
however, one subtle inefficiency with this solution. The problem is with
the generic dependency of objects on all sources and headers, which
means that some .o files will be unnecessarily rebuilt when a specific
.h or .c file is updated. For example, `scanner.o` will be rebuilt if
`counter.h` is updated, but it does not need to be. The solution to this
is to more explicitly enumerate the specific dependencies on each .o
file in the Makefile, making the dependencies less generic and more
specific for each `.o` file. For example, replace
`$(OBJS): $(HDRS) $(SRCS)` in the above Makefile with:
:::

::: listingblock
::: content
    count.o: count.c count.h
    scanner.o: scanner.c scanner.h
    countwords.o: countwords.c scanner.h counter.h
:::
:::

::: paragraph
Adding these specific dependencies makes the Makefile less generic, but
it avoids unnecessary compilation with the more generic
`$(OBJS): $(HDRS) $(SRCS)`. For small programs the more generic solution
might be fine, but for larger programs carefully enumerating the
dependencies for each .o file is important to avoid a lot of unnecessary
re-compilation, and also to ensure that a .o file is rebuilt when a file
it depends on is modified.
:::

::: paragraph
Because of this, there are ways to automatically generate a full set of
dependencies for each .o file (and for each executable). Using automatic
dependency generating tools is almost necessary for Makefiles for
building programs from many source and header files in order to ensure
correct compilation when a file is modified. One such tool is
`makedepend`, which examines .c and .h files and adds dependencies to
the end of a Makefile. Another is to use the gcc `-MD` (make
dependencies) precompiler flag to generate dependency files (`.d`) and
to include these files in the Makefile.
:::
:::

::: sect2
### [](#SampleMakefile){.anchor}17.5.10. Advanced: A Generic Featureful Makefile {#SampleMakefile}

::: paragraph
Our last makefile example is a generic general-purpose makefile that
includes a more complete set of commonly used Makefile variables for
compiling C programs, and it also demonstrates some more advanced syntax
and features, specifically:
:::

::: ulist
-   linking in libraries (`-l`)

-   defining link and include paths (`-L` and `-I`) for finding library
    and header files that are not in default locations.

-   auto generating file dependency rules (`-MD`) and including them in
    a makefile (`include`).
:::

::: paragraph
This is also a good example [Makefile](_attachments/Makefile.txt) to
copy and edit for your own use
:::

::: paragraph
In general, C programs have many libraries implicitly linked into them,
but sometimes other libraries need to be explicitly linked in using the
`-l` compiler flag. The `gcc` compiler looks in default locations for
library code, but for libraries that are not in those locations, a link
path needs to be explicitly included in the `gcc` command line. These
are added to the makefile using `-L`. Similarly, header files also may
be located in non-standard locations, and then the Makefile needs to
specify an include file path definition to the location containing them.
Include paths are given using `-I`.
:::

::: paragraph
Finally, for a program with multiple `.c` and `.h` files, it is useful
to automatically generate dependencies. In this example we use the `gcc`
`-MD` (make dependencies) precompiler flag (added to the `CPPFLAGS`
definition). It creates dependency files (`.d`) associated with each
`.o` file during the preprocessing phase of compilation (the first
phase). These dependency files are then included in the Makefile
(`include`). There is an implicit dependency of `.d` files on `.c`
files, so if a `.c` file is modified both its `.o` and `.d` are
regenerated. Also, the `-MP` flag is typically used with the `-MD` flag,
which suppresses errors if header files are renamed.
:::

::: paragraph
Here is the resulting Makefile, which is a good generic makefile to copy
and modify for your own use:
:::

::: listingblock
::: content
    # Example Makefile to copy and edit for your own use
    #   make: build .d, .o, and executable target
    #   make clean: remove built files

    # define compiler
    CC = gcc

    # define compiler flags
    CFLAGS = -Wall -g

    # define include paths:
    #  define any non-default paths to header files (.h) used by this program
    #  (default location, /usr/include/, is searched by gcc last)
    INCLUDES =  -I../includes -I.

    # define preprocessor flags
    # -MD and -MP flags create dependency files (.d) for all SRCS
    CPPFLAGS = -MD -MP $(INCLUDES)

    # library paths
    #  define any non-default paths to where libraries used by the program may be
    #  (default location, /usr/lib/, is searched by gcc last)
    LFLAGS = -L../lib -L/home/newhall/lib

    # define libraries to link into executable
    #    -lm: std math library in /usr/lib (named libm.so or libm.a)
    #    -lmylib: is a library not in standard location, so -L paths
    #             are used to find it (named libmylib.so or libmylib.a)
    LIBS = -lm -lmylib

    # set of source files
    #  (\ is the line continuation character)
    SRCS =  emitter.c init.c lexer.c  symbol.c parser.c ast.c  \
            error.c symbol_table.c codegen.c emitcode.c main.c

    # set of object files
    #  obtained from SRCS using suffix replacement rule
    OBJS = $(SRCS:.c=.o)

    # executable file name
    TARGET = mycc

    # .PHONY tells make that these targets are not file names but
    #   the target labels for a set of commands to run when `make [target label]`
    #   is invoked (e.g., `make clean` executes a `rm` command)
    #
    .PHONY: clean

    # the rest of this is generic and should not need to be edited:
    all:    $(TARGET)

    $(TARGET):  $(OBJS)
        $(CC) $(CPPFLAGS) $(CFLAGS) $(INCLUDES) -o $(TARGET) $(OBJS) $(LFLAGS) $(LIBS)

    # just use make's built-in rule (.c.o:) to build .o from .c files!

    clean:
            $(RM) *.o *~ $(TARGET) *.d

    # include the dependency files here
    #   this uses a suffix replacement within a macro $(name:string1=string2):
    #     (for each word in 'name' replace 'string1' with 'string2')
    #     here we replace the suffix .c with .d for every name in SRCS
    #
    #   the '-' before 'include' suppresses error messages when a .d file
    #     doesn't already exist
    -include $(SRCS:%.c=%.d)
:::
:::

::: paragraph
The **`INCLUDES`** variable defines paths to search to find `.h` files
that are needed to compile `.c` files to `.o` for any `.h`. The path
only needs to be specified if `.h` files are not in the current working
directory or in locations that `gcc` checks by default.
:::

::: paragraph
During the linking phase of compilation, the compiler links the math
library `-lm` and a local library `-lmylib` defined by the **`LIBS`**
variable that it finds given the library path definitions in the
**`LFLAGS`** variable specifying paths to search. The path only needs to
be specified in cases where the library file is not in locations that
`gcc` automatically searches by default.
:::

::: paragraph
Running `make` using this makefile will first generate `.d` files for
each `.c` file because we define `CPPFLAGS` to have **`-MD`**, which
means make dependency files. If you run `ls` you will see these `.d`
files:
:::

::: listingblock
::: content
    $ make
    $ ls
    Makefile ast.c ast.d ast.o codegen.c codegen.d codegen.o ...
:::
:::

::: paragraph
The dependency files are included in the Makefile in the last line:
:::

::: listingblock
::: content
    -include $(SRCS:%.c=%d)
:::
:::

::: paragraph
This uses a suffix replacement rule (`SRC:%.c=%d`) to specify including
every `.d` file, and the `-` before `include` suppresses error messages
if the `.d` file doesn't already exist. For more details, see
[automatically generate makefile
dependencies](http://www.microhowto.info/howto/automatically_generate_makefile_dependencies.html)
from microHOWTO.
:::

::: paragraph
This Makefile also uses make's built-in rule to build `.o` files from
`.c` files:
:::

::: listingblock
::: content
    .c.o:
        $(CC) $(CPPFLAGS) $(CFLAGS) $(INCLUDES) -c $<  -o $@
:::
:::

::: paragraph
Because we set `CPPFLAGS` to include the `INCLUDES` as well as the
command options to create the `.d` dependency files, we can use the
built-in rule.
:::

::: paragraph
If we didn't add `INCLUDES` to `CPPFLAGS`, then we could override the
built-in rule in the Makefile with our own (sometimes it is necessary to
override a built-in command like this, but this is not an example where
it is):
:::

::: listingblock
::: content
    ...
    INCLUDES = -I../includes/ -I.
    CPPFLAGS = -MD -MP
    ...
    # override built-in command with our version:
    .c.o:
            $(CC) $(CPPFLAGS) $(CFLAGS) $(INCLUDES) -c $<  -o $@
:::
:::
:::

::: sect2
### [](#_advanced_makefile_generators){.anchor}17.5.11. Advanced: Makefile Generators {#_advanced_makefile_generators}

::: paragraph
For very large programs, and particularly for software that may be
installed on different systems, using a program that generates a
Makefile for a particular system makes managing different build targets
considerably easier. GNU Automake (part of GNU Autotools library) and
CMake are two examples of makefile generating programs. Both take
user-specifications in a config file to find libraries and create
dependencies on specific systems and auto generate Makefiles for that
system. We don't discuss either here, but our references section has
links to more information about both.
:::
:::

::: sect2
### [](#_references){.anchor}17.5.12. References {#_references}

::: paragraph
Here are a few references for using make and writing makefiles:
:::

::: ulist
-   [the GNU Make Manual](https://www.gnu.org/software/make/manual/)
    from gnu.org.

-   [automatically generate makefile
    dependencies](http://www.microhowto.info/howto/automatically_generate_makefile_dependencies.html)
    from microHOWTO

-   [Understanding and Using Makefile
    flags](https://earthly.dev/blog/make-flags/) by Aniket Bhattacharyea
:::

::: ulist
-   [GNU Automake](https://www.gnu.org/software/automake/) from gnu.org.

-   [CMake](https://cmake.org/) from cmake.org.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
