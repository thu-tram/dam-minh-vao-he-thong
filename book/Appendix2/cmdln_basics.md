
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix Manual](man.html){.nav-link}
        -   [17.3. Remote Access](ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](editors.html){.nav-link}
        -   [17.5. make and Makefiles](makefiles.html){.nav-link}
        -   [17.6 Searching: grep and find](grep.html){.nav-link}
        -   [17.7 File Permissions](chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing Files](tar.html){.nav-link}
        -   [17.9 Process Control](pskill.html){.nav-link}
        -   [17.10 Timing](timing.html){.nav-link}
        -   [17.11 Command History](history.html){.nav-link}
        -   [17.12 I/0 Redirection](ioredirect.html){.nav-link}
        -   [17.13 Pipes](pipe.html){.nav-link}
        -   [17.14 Dot Files and .bashrc](dotfiles.html){.nav-link}
        -   [17.15 Shell Programming](shellprog.html){.nav-link}
        -   [17.16 Getting System Information](sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [17. Appendix 2: Using Unix](index.html)
-   [17.1. Unix Command Line and the Unix File
    System](cmdln_basics.html)
:::

::: content
::: sect1
## [](#_unix_command_line_and_the_unix_file_system){.anchor}17.1. Unix Command Line and the Unix File System {#_unix_command_line_and_the_unix_file_system}

::: sectionbody
::: paragraph
Unix systems provide a **command line interface** for users to interact
with the system. When a user logs into a Unix system, they interact with
a Unix **shell program** that runs in a terminal window. The shell reads
in commands entered by the user and performs the requested action.
Example shell programs are `bash` and `zsh`. The shell displays a shell
prompt (e.g., `$`) and the user types in a command that the shell
program executes. Readers (especially those who know Python) may be
familiar with a read-eval-print loop (or REPL), which is a shell-like
environment that is implemented in the context of a programming
language. Like a REPL, the shell's command line interface reads a
command, evaluates it, prints out the results, and then returns to the
shell prompt, in a loop. Unlike a REPL, the shell's command line
interface allows users to access the operating system interface and to
run a variety of different programs. For example, the `whoami` command
will tell you your user name:
:::

::: listingblock
::: content
    $ whoami
    myusername
:::
:::

::: paragraph
The Unix file system stores programs and other files. Users type
commands at the shell prompt to run programs, navigate the Unix file
system, and manipulate files.
:::

::: paragraph
Many commands have **command line options**, that specify different
options or specific behaviors of a command. Many commands also take
**command line arguments** that are used to specify the target of the
operation. For example, `cp` is the copy command that copies one file to
another. It takes two command line arguments, the name of the file
source to copy and the name of the destination file that will contain
the copy.
:::

::: sect2
### [](#_unix_file_system){.anchor}17.1.1. Unix File System {#_unix_file_system}

::: paragraph
The Unix file system consists of files and directories. A file stores
data such as program source code, program input data, class notes, and
binary executable code. Directories store files and subdirectories and
are used to organize the set of files stored in the file system.
:::

::: paragraph
The Unix file system is organized in a hierarchical tree structure, with
a single directory at the top (`/`) called the root directory. Under it
are some main directories holding system content. Some examples are
`bin` that stores system programs that can be run from the Unix command
line, `lib` that stores system library code, and `home` that stores
every user's home directory into which they can store their own files.
[Figure 1](#FigUnixFS) shows an example Unix file system directory
structure, with two `home` directories for users `sam` and `sarita`.
:::

::: {#FigUnixFS .imageblock .text-center}
::: content
![The unix file system with root directory at top, with example child
directories bin, home, lib, and two example subdirectories under home
sam and sarita.](_images/unixfs1.png){width="900"}
:::

::: title
Figure 1. The Unix File System is organized as a hierarchy with the root
directory at the top, and subdirectories and files arranged underneath.
:::
:::

::: paragraph
Note that `/` is the top-level directory, it has several **child**
subdirectories, including `bin`, `lib`, and `home`. Every directory
except the root directory has a unique **parent** directory; the root
directory is the only one without a parent directory.
:::

::: paragraph
Every user in the system has their own home directory, which is a
subdirectory in `/home`. Each user's home directory is the the same name
as their username. In Figure we show a few example home directories.
Every directory except `/` has exactly one parent directory. For
example, `home` is the parent directory of `sarita`, and `/` is the
parent directory of `home`. Every directory is identified by a unique
**pathname** starting from the root directory. For example,
`/home/sarita` is the pathname of the `sarita` user's home directory:
the pathname starts at the root directory, `/`, then follows the `home`
sub-directory of `/`, and finally the `sarita` sub-directory of `home`.
:::

::: paragraph
When you first log into a Unix system or start a new shell program, you
start out in your home directory. The `pwd` (print working directory)
command prints the directory you are currently in, showing its full
pathname starting from the root directory `/`. For example, here is the
output when the user `sarita` logs in and types, `pwd`:
:::

::: listingblock
::: content
    $ pwd
    /home/sarita
:::
:::

::: paragraph
When the user `sam` logs in and types `pwd`, here is the output:
:::

::: listingblock
::: content
    $ pwd
    /home/sam
:::
:::
:::

::: sect2
### [](#_file_system_commands){.anchor}17.1.2. File System Commands {#_file_system_commands}

::: paragraph
Unix commands allow users to move around its directory structure, create
and delete files and directories, list the contents of a directory, and
to see which directory they are currently in. All actions are relative
to the current working directory. For example, if a user creates a new
file, the file is created in the user's current working directory.
:::

::: paragraph
The `cd` (change directory) command changes the current working
directory (or to moves into a different directory). The `ls` (list)
command lists the contents of the current directory. The `mkdir` command
is used to create a new directory.
:::

::: paragraph
For example, to create a subdirectory named `unix_notes` in her home
directory, and to move into that directory, `sarita` would enter the
following:
:::

::: listingblock
::: content
    $ mkdir unix_notes  # make a new directory named unix_notes
    $ ls                # list contents of current directory
     unix_notes/
    $ cd unix_notes     # move into the new directory
    $ pwd               # print current working directory
    /home/sarita/unix_notes
:::
:::

::: paragraph
There are many ways to create new files. Often users create new files
through using an editor program. A less common way to create an empty
new file is using the `touch` command:
:::

::: listingblock
::: content
    $ touch basics
    $ ls
     basics
:::
:::

::: paragraph
Since we don't yet know an editor program, we can add some content to
the file using the `echo` command and appending its output to the
`basics` file (`>>` appends echo's output to the specified file,
`basics` in this example). For example:
:::

::: listingblock
::: content
    $ echo "ls: list directory contents" >> basics
    $ echo "cd: change directory" >> basics
    $ echo "pwd: print working directory" >> basics
:::
:::

::: paragraph
The `cat` command dumps the contents of a file to the terminal. To see
the contents of `basic` after running the `echo` commands above:
:::

::: listingblock
::: content
    $ cat basics
    ls: list directory contents
    cd: change directory
    pwd: print working directory
:::
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | File names in Unix                |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Note that file and directory      |
|                                   | names in Unix are case sensitive, |
|                                   | `basics` and `Basics` are two     |
|                                   | different file names, for         |
|                                   | example.                          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Also, although file names can     |
|                                   | contain space characters, they    |
|                                   | have to be specified using the    |
|                                   | escape character before the space |
|                                   | character (e.g., `hello\ there`   |
|                                   | is the way to name the file       |
|                                   | \"hello there\"). As a result,    |
|                                   | Unix user's typically do not      |
|                                   | create files with space           |
|                                   | characters in their names.        |
|                                   | Instead, users use `_` or `-` in  |
|                                   | places where they would want a    |
|                                   | space in a name (e.g.,            |
|                                   | `hello_there`).                   |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
The `wc` command counts the number of words, lines, and bytes in a file.
For example, to see this information for the file we just created, run:
:::

::: listingblock
::: content
    $ wc basics
     3      11      78 basics
:::
:::

::: paragraph
Unix users typically organize their their home directory as a set of
directories under which related subdirectories and files are stored. For
example, user `sam` would use the `mkdir` command to create three
subdirectories in his home directory, one for class work, one for
projects, and one for personal correspondence:
:::

::: listingblock
::: content
    $ mkdir classes
    $ mkdir projects
    $ mkdir letters

    $ ls
    classes/    letters/   projects/
:::
:::

::: paragraph
Because this user is taking CS31, they want to create a subdirectory
under their `classes` subdirectory for all their work in this class. To
do this they would do the following:
:::

::: listingblock
::: content
    $ cd classes
    $ pwd
    /home/sam/classes
    $ mkdir CS31
    $ ls
    CS31/
    $ cd CS31
    $ pwd
    /home/sam/classes/CS31
:::
:::

::: paragraph
[Figure 2](#FigUnixFSSam) shows what the filesystem looks like after
`sam` runs all of the `mkdir` commands.
:::

::: {#FigUnixFSSam .imageblock .text-center}
::: content
![The unix file system after sam creates subdirectories classes,
letters, projects, and creates a subdirectory under classes named
CS31.](_images/unixfs2.png){width="900"}
:::

::: title
Figure 2. The Unix File System Organization after user sam creates some
subdirectories.
:::
:::

::: paragraph
Now the `sam` can move into his CS31 directory when he is working on
CS31 course work, and create more subdirectories and files in this
directory:
:::

::: listingblock
::: content
    $ cd CS31
    $ pwd
    /home/sam/classes/CS31
:::
:::

::: sect3
#### [](#_file_pathnames_and_navigating_the_file_system){.anchor}File Pathnames and Navigating the File System {#_file_pathnames_and_navigating_the_file_system}

::: paragraph
As we have seen, the `cd` command is used to navigate in the file
system, and `ls` lists the contents of a directory.
:::

::: paragraph
Both `cd` and `ls` take one command line argument that specifies which
directory to change into or list the contents of, respectively. There
are two ways to name to a directory location for `cd` to change to. One
is to list the directory as its **absolute path name**, its name
starting from the root directory (`/`), and the other is to list it as a
**relative path name**, its name from the current working directory.
:::

::: paragraph
You can also run both `cd` and `ls` with no path name argument. Running
`cd` alone will take you home (to your home directory), and running `ls`
alone lists the contents of the current working directory. Here are a
some examples that the user `sam` tried:
:::

::: listingblock
::: content
    $ cd /home/sam/courses/CS31   # cd with absolute path name
    $ pwd
    /home/sam/courses/CS31

    $ cd                          # cd with no path name  (go home)
    $ pwd
    /home/sam/

    $ ls                          # ls with no path name (list in current directory)
    classes/    letters/   projects/

    $ cd courses/CS31        # cd with relative path name
    $ pwd
    /home/sam/courses/CS31

    $ ls courses/            # ls with relative path name
    CS31/

    $ cd /                   # cd with absolute path name (go to root directory)
    $ pwd
    /
:::
:::

::: paragraph
Often users use relative path because they are typically shorter to type
(they often are just moving near where they currently are).
:::

::: paragraph
Every directory contains two hidden entries that help to navigate
directories with the cd command: `.` is another name for the current
directory, and `..` is another name for the parent directory of the
current directory. You can see these files listed if you use the `-a`
command line option to `ls`:
:::

::: listingblock
::: content
    $ pwd
    /home/sam/classes/CS31
    $ ls -a
    .   ..
:::
:::

::: paragraph
These can be used in both relative and absolute path names, to specify
the current directory or the parent's. Using `..` in a path name means
go up one directory.
:::

::: listingblock
::: content
    $ pwd
    /home/sam/classes/CS31

    $ cd ..                 # move up one directory to parent directory
    $ pwd
    /home/sam/classes

    $ cd /bin/../home/sam   # go to sam's home directory in an unusual way
    $ pwd
    /home/sam

    $ cd ./classes/./..     # a wacky example of not going anywhere
    $ pwd
    /home/sam
:::
:::

::: paragraph
Finally, `~` is shorthand for directories in `/home`. When used alone,
`~` is shorthand for the user's home directory. When when combined with
another's user name `~` refers to the other user's home directory. Here
are some examples run by user `sam`:
:::

::: listingblock
::: content
    $ cd ~/       # cd into home directory
    $ pwd
    /home/sam/

    $ ls ~/
    classes/    letters/   projects/

    $ ls ~sarita/
    unix_notes/

    $ cd ~sartita/
    $ pwd
    /home/sarita
:::
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | About the previous example        |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Often times the system            |
|                                   | administrator sets up default     |
|                                   | file and directory permissions on |
|                                   | `home/` that prevent users from   |
|                                   | viewing each others home          |
|                                   | directories and files. On such a  |
|                                   | system, it may not be possible    |
|                                   | for Sam to `cd` into Sarita's     |
|                                   | home directory, or list her files |
|                                   | with `ls` as he does in this      |
|                                   | example.                          |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect3
#### [](#_copying_and_moving_files){.anchor}Copying and Moving Files {#_copying_and_moving_files}

::: paragraph
The `cp` command copies one file (or directory) to another, and the `mv`
command moves a file (or directory) from one directory into another one,
or it renames a file. Both of these commands take two command line
arguments, the source and the destination.
:::

::: paragraph
Here are some examples;
:::

::: listingblock
::: content
    $ cd unix_notes
    $ cp basics test   # copy the basics file to a new file named test
    $ ls
    basics test

    $ mv test ../blah  # move the test file one directory up and renames it to blah
    $ ls
    basics

    $ cd ../
    $ ls
    blah   unix_notes/

    $ cp -r unix_notes notes_copy  # recursively copy all contents of
                                   # of unix_notes directory to new directory
                                   # named notes_copy
    $ cd notes_copy
    $ pwd
    /home/sarita/notes_copy
    $ls
    basics

    $ cp basics ../.    # copy basics up a directory to file with same name (/.)
    $ cd
    $ pwd
    /home/sarita/
    $ ls
    basics unix_notes
:::
:::
:::

::: sect3
#### [](#_removing_files_and_directories){.anchor}Removing Files and Directories {#_removing_files_and_directories}

::: paragraph
Sometimes you want to remove files and directories. The `rm` command is
used to remove a file, and the `rmdir` is used to remove a directory.
Both take the name of the file or directory to remove. Both have command
line options to specific behavior of removing.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Removing files without the `-i`   |
|                                   | command line option               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | By default, the `rm` command      |
|                                   | permanently deletes a file. It    |
|                                   | does not move it to a recycle bin |
|                                   | like deleting files on some other |
|                                   | operating systems may do.         |
|                                   | Therefore, `rm` should be used    |
|                                   | with caution. Sometimes a system  |
|                                   | administrator configures `rm` to  |
|                                   | automatically use its `-i`        |
|                                   | command option by default, so     |
|                                   | that `rm` first prints a prompt   |
|                                   | to give the user a chance to      |
|                                   | enter `n` before removing the     |
|                                   | file (if the user enters `y` or   |
|                                   | `Y` to the prompt the file will   |
|                                   | be removed, and any other         |
|                                   | response it will not).            |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | On systems where `rm` isn't set   |
|                                   | up to by default run `rm -i`,     |
|                                   | users often add this feature to   |
|                                   | their shell configuration file.   |
|                                   | We discuss Bash configuration     |
|                                   | files more in Section 17.6.       |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
For example (note that if your system isn't set up with `rm` using `-i`
by default, you would type `rm -i` to see this same behavior).
:::

::: listingblock
::: content
    $ ls
     basics unix_notes
    $ rm basics
      rm: remove regular file basics? y
    $ ls
     unix_notes

    $ rm unix_notes
      rm: remove regular file basics? n
    $ ls
     unix_notes
:::
:::

::: paragraph
By default, `rmdir` only removes empty directories, a feature that
prevents the user from accidentally removing content that they did not
intend, by forcing them to explicitly remove all directory contents
before removing the directory. Here are some example calls from user
`sam`:
:::

::: listingblock
::: content
    $ cd
    $ pwd
    /home/sam
    $ ls
    classes/    letters/   projects/
    $ rmdir letters
    $ ls
    classes/    projects/

    $ rmdir classes
    rmdir: failed to remove classes: Directory not empty
    $ ls
    classes/    projects/
:::
:::

::: paragraph
A user can recursively remove the contents of a directory using `rm -r`,
and can also forcefully remove files (git rid of all prompting before
removing files) by adding the `-f` option too: `rm -rf`.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Be very careful with the `-f` and |
|                                   | `-r` command line options         |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Great care should be taken when   |
|                                   | using `-f` with `rm`, as the      |
|                                   | prompting behavior of `rm -i`     |
|                                   | often prevents accidental removal |
|                                   | of files; if you run `rm -rf` you |
|                                   | can accidentally recursively      |
|                                   | remove a full directory of files. |
|                                   | Because of this, it is best to    |
|                                   | avoid using these command line    |
|                                   | options. However, when deleting a |
|                                   | large number of files and         |
|                                   | subdirectories, they are useful.  |
|                                   | In cases when you do want to use  |
|                                   | these options, it is good         |
|                                   | practice to first ensure that you |
|                                   | are in the right directory (by    |
|                                   | running `ls` and `pwd`) before    |
|                                   | running `rm -rf`.                 |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::
:::

::: sect2
### [](#_basic_commands_summary){.anchor}17.1.3. Basic Commands Summary {#_basic_commands_summary}

::: paragraph
Here is a summary of some of the UNIX commands discussed in this
section, with examples:
:::

::: ulist
-   `pwd` --- Print working directory: prints out the full pathname of
    the current directory (cwd).

-   `cd <pathname>` --- Change directory: changes the current directory
    to be the directory specified by `<pathname>`. The pathname can be
    relative to the cwd or an absolute pathname from `/`.

    ::: ulist
    -   Move into the `sub1` directory from the current directory:

        ::: listingblock
        ::: content
            cd sub1
        :::
        :::

    -   Move into the `/home/sam` directory, regardless of the current
        directory:

        ::: listingblock
        ::: content
            cd /home/
        :::
        :::

    -   Change to the parent directory of the current directory (i.e.,
        move up one level in the filesystem hierarchy):

        ::: listingblock
        ::: content
            cd ..
        :::
        :::

    -   Change to your \"home\" directory:

        ::: listingblock
        ::: content
            cd
        :::
        :::
    :::

-   `ls` --- List: list files and directories in the current directory.

-   `ls <pathname` --- List: list files and directories in the directory
    specified by `<pathname>`.

    ::: ulist
    -   List the contents of user `sam`\'s home directory:

        ::: listingblock
        ::: content
            ls /home/sam
        :::
        :::
    :::

-   `mv <p1> <p2>` --- Move: move/rename file specified by pathname
    `<p1>` to `<p2>`.

    ::: ulist
    -   Rename `oldfile` to be `newfile`

        ::: listingblock
        ::: content
            mv oldfile newfile
        :::
        :::

    -   Move `newfile` into subdirectory `sub1`:

        ::: listingblock
        ::: content
            mv newfile sub1/
        :::
        :::

    -   Rename `sub1` directory to `sub2`:

        ::: listingblock
        ::: content
            mv sub1 sub2
        :::
        :::
    :::

-   `cp <p1> <p2>` --- Copy: make a new copy of the file specified by
    pathname `<p1>` and name the new copy `<p2>`.

    ::: ulist
    -   Copy `oldfile` to `newfile` (`oldfile` still exists):

        ::: listingblock
        ::: content
            cp oldfile newfile
        :::
        :::

    -   Copy `oldfile` up one directory to a file also named `oldfile`
        (current directory and parent directory both have a file named
        `oldfile`, whose contents are identical until one of the files
        is modified):

        ::: listingblock
        ::: content
            cp oldfile ../.
        :::
        :::
    :::

-   `rm <pathname>` --- Remove: delete the file specified by
    `<pathname>`.

    ::: ulist
    -   Delete file named `temp` in my home directory:

        ::: listingblock
        ::: content
            rm ~/temp
        :::
        :::
    :::

-   `mkdir <dir>` --- Make directory: create a new directory named
    `<dir>`.

    ::: ulist
    -   Create a new directory named `test` in the current directory:

        ::: listingblock
        ::: content
            mkdir test
        :::
        :::

    -   Create a new directory named `private` in my home directory:

        ::: listingblock
        ::: content
            mkdir ~/private
        :::
        :::
    :::

-   `rmdir <dir>` --- Remove directory: delete the directory specified
    by pathname `<dir>` (must be empty).

    ::: ulist
    -   Remove directory named `private` in my home directory:

        ::: listingblock
        ::: content
            rmdir ~/private
        :::
        :::
    :::

-   `wc <file>` --- Word count: list the number of bytes, words, and
    lines in a file.

-   `touch <file>` --- Create a new empty file with name `<file>`.

    ::: ulist
    -   Create a new empty file named `my_notes` in the current
        directory:

        ::: listingblock
        ::: content
            touch my_notes
        :::
        :::
    :::

-   `cat <file>` --- Print out contents of `<file>` to the terminal.

    ::: ulist
    -   Print the contents of the `basics` file:

        ::: listingblock
        ::: content
            cat basics
        :::
        :::
    :::

-   `less <file>` --- Print out the contents of `<file>` to the
    terminal, one page at a time, pausing at each page. The space bar
    key advances to the next page.

    ::: ulist
    -   Print the contents of the `basics` file one page at a time:

        ::: listingblock
        ::: content
            less basics
        :::
        :::
    :::

-   `more <file>` --- Another pager (like `less`) for viewing files one
    page at at time.
:::
:::

::: sect2
### [](#_references){.anchor}17.1.4. References {#_references}

::: paragraph
For more information see:
:::

::: ulist
-   [most used Unix
    commands](https://www.cheat-sheets.org/project/tldr/command/special-most-used-linux-commands/)
    from cheat-sheets.org

-   [Bash Reference
    Manual](https://www.gnu.org/software/bash/manual/html_node/index.html)
    from gnu.org.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
