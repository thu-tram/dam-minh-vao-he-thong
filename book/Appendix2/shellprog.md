
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix Manual](man.html){.nav-link}
        -   [17.3. Remote Access](ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](editors.html){.nav-link}
        -   [17.5. make and Makefiles](makefiles.html){.nav-link}
        -   [17.6 Searching: grep and find](grep.html){.nav-link}
        -   [17.7 File Permissions](chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing Files](tar.html){.nav-link}
        -   [17.9 Process Control](pskill.html){.nav-link}
        -   [17.10 Timing](timing.html){.nav-link}
        -   [17.11 Command History](history.html){.nav-link}
        -   [17.12 I/0 Redirection](ioredirect.html){.nav-link}
        -   [17.13 Pipes](pipe.html){.nav-link}
        -   [17.14 Dot Files and .bashrc](dotfiles.html){.nav-link}
        -   [17.15 Shell Programming](shellprog.html){.nav-link}
        -   [17.16 Getting System Information](sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [17. Appendix 2: Using Unix](index.html)
-   [17.15 Shell Programming](shellprog.html)
:::

::: content
::: sect1
## [](#shellprog){.anchor}17.15. Shell Programming {#shellprog}

::: sectionbody
::: paragraph
Shell scripts are often used to group a set of commands that should
execute together. A **shell script** is an executable text file that
consists of a sequence of shell commands that, when run, execute those
commands in order. Shells also have language constructs such as loops
and conditionals, which can be used to create complex featureful
scripts. These shell programming constructs can also be used at the
command line and in shell scripts. Below, we present a few examples of
Bash shell programming. Other shells (e.g. `zsh`, `sh`, `tcsh`) have
their own shell programming language syntax, but they all provide
similar functionality.
:::

::: paragraph
The first line of a Bash script starts with a special comment `#`
followed by a bang `!` and the path to the program that executes the
contents of the script file. Below is an example of a simple Bash
script, [simplescript.sh](_attachments/simplescript.sh) (note that by
convention shell scripts are named with a `.sh` suffix).
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#!/bin/bash
pwd
whoami
date
```
:::
:::

::: paragraph
Before it can be run, the `simplescript.sh` file needs to be given the
executable permission. A user can check its permissions by running
`ls -l` and set the executable permission using `chmod` if it is not
set. For example:
:::

::: listingblock
::: content
    $ ls -l simplescript.sh
    -rw------- 1 sam users 31 Mar 28 18:26 simplescript.sh

    $ chmod u+x simplescirpt.sh

    $ ls -l simplescript.sh
    -rwx------ 1 sam users 31 Mar 28 18:26 simplescript.sh
:::
:::

::: paragraph
Once it is marked as executable, the script can be run on the command
line like any executable file, and the sequence of commands listed in
the script will execute in order:
:::

::: listingblock
::: content
    $ ./simplescript.sh
    /home/sam/
    sam
    Tue 28 Mar 2023 06:27:38 PM EDT
:::
:::

::: paragraph
Unix shell programs support language constructs such as iteration (i.e.,
for and while loops) and conditionals (i.e., if-else). Although these
constructs can be used at the command line, they are more commonly used
in shell scripts to specify more complicated execution structure. Shell
scripts can also make use of command line arguments and variables, which
help the script work with different input values.
:::

::: paragraph
Below are a couple examples of Bash shell scripts using some of these
more advanced features. The first, [runsh.sh](_attachments/run.sh), is a
script that repeats some timed executions of a program. In this example,
the executable file name and the number of executions to repeat are
given as command line arguments to the script. This example also shows
how to test for some constraints on command line arguments. Here the
program executable command line argument is required to run the script,
but the number of executions to repeat is an optional command line
argument (the script uses a default value of 5 when a user runs the
script without specifying this command line option). The script uses the
`if-elif` construct to test for command line options. It also shows an
example of a `for` loop used to repeat the number of runs specified by
the caller.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#!/bin/bash

# this script performs a number of timed runs of a
# program given as a required command line argument
# the number of runs is an optional cmdln arg

# script variable N for the number of runs
# assigning N default value of 5
N=5

# get command line arguments
#  1: name of program is required
#  2: number of runs is optional
# $@ is the array of command line args (like argv)
# $# is the number of command line args (like argc)

# get the program executable name
# note: space between "[ $" and between "0 ]" is important!
if [[ $# -eq 0 ]]
then
  echo "Error, usage: ./run.sh ./a.out [num times]"
  exit 1
else
  PROG=$1
fi

# if they gave the optional cmdln arg, set N to it
if [[ $# -gt 1 ]]
then
  N=$2
fi

# it's useful to output some info about what is run:
echo "running $PROG $N times: "
date
echo "======================= "

# do N timed runs of PROG:
for((n=1; n <= $N; n++))
do
echo " "
echo "run $n:"
time $PROG
done
```
:::
:::

::: paragraph
There are a few things to note in this script. First, there are no types
in Bash scripts, so it is up to the user to use values appropriately
based on their implied types.
:::

::: paragraph
Second, note that Bash shell variables are set using `=` operator and
their values are referenced using `$var_name`:
:::

::: listingblock
::: content
    N=5      # set N to 5
    n <= $N  # use value of N
:::
:::

::: paragraph
Third, note the syntax for accessing command line arguments in the Bash
script:
:::

::: ulist
-   `$@` is the array of command line arguments, which is similar to
    `argv` in C.

-   `$#` is the number of command line arguments, which is similar to
    `argc` in C except that the name of the Bash script file does not
    count as one of the arguments (i.e., a Bash script run with no
    command line arguments has a value of `0` for `$#`, whereas a C
    program run with no command line arguments has a value of 1 for
    `argc`).
:::

::: paragraph
Fourth, note the `if-else` syntax, and its general form:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
if [[ cond ]]
then
   # if true stmts
else
   # if false stmts
fi
```
:::
:::

::: paragraph
Bash uses `then`, `else`, and `fi` to denote the start of the if block,
the start of the else block, and the end of the if-else statement. The
`[[` and `]]` symbols are used to denote the conditional statement, and
the space chars between them and the condition are very important
(without these Bash will not correctly parse this statement). The
conditional operator syntax is `-gt` represents greater than, `-lt`
represents less than, `-eq` represents equal to, and others use similar
notation.
:::

::: paragraph
Finally, note the syntax of the `for` loop is similar to `for` loops in
C, where the body of the for loop is denoted by `do` and `done` and the
`` and `` contain the `init; cond; step` parts. Here is the general form
of this type of Bash `for` loop (Bash actually has more than one form of
`for` loop):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
for((init; cond; step))
do
  # for loop body statements
done
```
:::
:::

::: paragraph
Below are some sample runs of the `run.sh` script:
:::

::: listingblock
::: content
    $ ./run.sh
    Error, usage: ./run.sh ./a.out [num times]

    $ ./run.sh ./myprog 2
    running ./myprog 2 times:
    Wed Mar 29 11:34:34 AM EDT 2023
    =======================

    run 1:
    myprog result = 300000

    real    0m0.060s
    user    0m0.003s
    sys 0m0.006s

    run 2:
    myprog result = 300000

    real    0m0.059s
    user    0m0.003s
    sys 0m0.006s


    $ ./run.sh ./myprog
    running ./myprog 5 times:
    Wed Mar 29 11:34:37 AM EDT 2023
    =======================

    run 1:
    myprog result = 300000

    real    0m0.057s
    user    0m0.008s
    sys 0m0.000s

    run 2:
    myprog result = 300000

    real    0m0.057s
    user    0m0.004s
    sys 0m0.004s

    run 3:
    myprog result = 300000

    real    0m0.057s
    user    0m0.010s
    sys 0m0.000s

    run 4:
    myprog result = 300000

    real    0m0.056s
    user    0m0.009s
    sys 0m0.000s

    run 5:
    myprog result = 300000

    real    0m0.055s
    user    0m0.004s
    sys 0m0.004s
:::
:::

::: paragraph
Often when using scripts like `run.sh` that produce a lot of output, it
is helpful to save the output to a file that can be examined after
completion. One way to do this is to use [I/O
redirection](ioredirect.html#ioredirect){.page} to redirect the script's
output to a file. Below is an example run of the `run.sh` script with
the command line options `./myprog` and `10` that redirects its stderr
and stdout ouput to a file named `results`:
:::

::: listingblock
::: content
    $ ./run.sh ./myprog 10 &> results
:::
:::

::: paragraph
In addition to supporting syntax similar to a C `for` loop, Bash
supports `for` loop syntax for iterating over a set of elements. The
[forloops.sh](_attachments/forloops.sh) Bash script (listed below), has
a few examples of this type of `for` loop, showing different ways in
which the set of elements iterated over is obtained.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#!/bin/bash

echo "for loop over set of values"
# iterate over a set of given values
# repeats once for each element in the list
for i in cat dog bunny
  do
    echo "next animal is: $i"
  done

echo

echo "for loop over sequence"
# {1..5} is the set of values in the sequence: 1,2,3,4,5
# this iterates over "infilei" where i: 1,2,3,4,5
for i in infile{1..5}
  do
    echo "next file is: $i"
  done

echo

echo "for loop over set created with ls"
# this iterates over all the files in a subdirectory named input
# $(ls input/): creates a set of value that are all the file
# and directory names in the input/ subdirectory
for i in $(ls input/)
  do
    echo "next input/ file is: $i"
  done
```
:::
:::

::: paragraph
When run, the output is:
:::

::: listingblock
::: content
    $ ./forloops.sh

    for loop over set of values
    next animal is: cat
    next animal is: dog
    next animal is: bunny

    for loop over sequence
    next file is: infile1
    next file is: infile2
    next file is: infile3
    next file is: infile4
    next file is: infile5

    for loop over set created with ls
    next input/ file is: albums
    next input/ file is: artists
    next input/ file is: bands
    next input/ file is: songs
:::
:::

::: paragraph
In general, combining Unix commands with Bash shell language constructs
like loops, conditionals, command lines, and variables, allow a user to
write powerful shell scripts to perform complex actions. We have shown
just a few examples in this section. See a Bash shell programming guide
for more information.
:::

::: sect2
### [](#_references){.anchor}17.15.1. References {#_references}

::: paragraph
For more information see:
:::

::: ulist
-   [Bash Reference
    Manual](https://www.gnu.org/software/bash/manual/html_node/index.html)
    from gnu.org.

-   [Bash Guide for
    Beginners](https://tldp.org/LDP/Bash-Beginners-Guide/html/) by
    Machtelt Garrels

-   [Advanced Bash-Scripting Guide](https://tldp.org/LDP/abs/html/) by
    Mendel Cooper

-   [most used Unix
    commands](https://www.cheat-sheets.org/project/tldr/command/special-most-used-linux-commands/)
    from cheat-sheets.org
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
