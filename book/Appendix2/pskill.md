
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix Manual](man.html){.nav-link}
        -   [17.3. Remote Access](ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](editors.html){.nav-link}
        -   [17.5. make and Makefiles](makefiles.html){.nav-link}
        -   [17.6 Searching: grep and find](grep.html){.nav-link}
        -   [17.7 File Permissions](chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing Files](tar.html){.nav-link}
        -   [17.9 Process Control](pskill.html){.nav-link}
        -   [17.10 Timing](timing.html){.nav-link}
        -   [17.11 Command History](history.html){.nav-link}
        -   [17.12 I/0 Redirection](ioredirect.html){.nav-link}
        -   [17.13 Pipes](pipe.html){.nav-link}
        -   [17.14 Dot Files and .bashrc](dotfiles.html){.nav-link}
        -   [17.15 Shell Programming](shellprog.html){.nav-link}
        -   [17.16 Getting System Information](sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [17. Appendix 2: Using Unix](index.html)
-   [17.9 Process Control](pskill.html)
:::

::: content
::: sect1
## [](#processcntrl){.anchor}17.9. Process Control {#processcntrl}

::: sectionbody
::: paragraph
When you run a program or command at the shell prompt, the shell usually
creates a new process that will run the program or command (a process is
the operating systems abstraction of a running program). There are a few
**built-in shell commands** that the shell process executes itself
(e.g., `cd`), but most are run as separate processes. See [Chapter 13:
The Operating System](../C13-OS/index.html#_the_operating_system){.page}
for more information about processes.
:::

::: paragraph
The unix shell supports **process control** features, which are ways to
specify how a program is run by the shell, and ways to interact with the
process as it runs.
:::

::: sect2
### [](#_running_in_the_foreground_and_background){.anchor}17.9.1. Running in the foreground and background {#_running_in_the_foreground_and_background}

::: paragraph
When a program is run at the shell prompt, it **runs in the foreground**
by default, meaning that the program runs to completion before the shell
program runs again and prints out the next prompt. However, programs can
also be **run in the background**, meaning that the shell starts the
program running but does not wait until it completes before printing out
the next prompt; this allows a user to enter another command while the
program is still running. To tell the shell to run a program in the
background, the user adds an `&` at the end of the command line. For
example, here is how to tell the shell to run an `a.out` program in the
background:
:::

::: listingblock
::: content
    $ ./a.out &
    $
:::
:::

::: paragraph
The `ps` command can be used to list all the programs running in the
shell. For example, here we start two `a.out` programs running in the
background, and then type `ps`:
:::

::: listingblock
::: content
    $ ./a.out &
    $ ./a.out &
    $ ps
        PID TTY          TIME CMD
     2729   pts/72    0:03.91 bash
     3582   pts/72    0:00.00 ./a.out
     3583   pts/72    0:00.00 ./a.out
     3584   pts/72    0:00.00 ps
:::
:::

::: paragraph
In the example output, you can see two `a.out` processes are running in
addition to the Bash shell process and the `ps` process. With each
process is listed its `process id`, a unique identifier the the
operating system keeps for each process (i.e., the `bash` process id is
`2729` and the two processes running the `a.out` program have process
ids `3582` and `3583`).
:::

::: paragraph
A process running in the background can be moved to the foreground using
the `fg` command:
:::

::: listingblock
::: content
    $ ./a.out &     # run a.out in the background
    $ ps
        PID TTY          TIME CMD
     2729   pts/72    0:03.91 bash
     3584   pts/72    0:00.00 ./a.out

    $ fg           # move a.out to the foreground (the shell waits for it to exit)

    $ ps           # run ps at the shell prompt (a.out has exited)
        PID TTY          TIME CMD
     2729   pts/72    0:03.91 bash
:::
:::

::: paragraph
By typing `CTRL-Z` a process running in the foreground can be
interrupted and suspended meaning that its execution is paused (it is
not running). This causes the shell to run again and print out a shell
prompt. If the user types `bg`, the suspended process will continue
running, but now run in the background. If the user types `fg` the
suspended process will continue running in the foreground again. Here
are some examples:
:::

::: listingblock
::: content
    $ ./a.out     # run a.out in the foreground
                  # type CTRL-Z to suspend a.out
    [1]  Stopped                 ./a.out

    $ ps
        PID TTY          TIME CMD
     2729   pts/72    0:03.91 bash
     3588   pts/72    0:00.00 ./a.out

    $ bg         # unsuspend a.out and run in background

    $ ps
        PID TTY          TIME CMD
     2729   pts/72    0:03.91 bash
     3588   pts/72    0:00.00 ./a.out

    $ fg        # run backgrounded process in the foreground
:::
:::
:::

::: sect2
### [](#_killing_a_running_processes){.anchor}17.9.2. Killing a running processes {#_killing_a_running_processes}

::: paragraph
The `kill` and `pkill` commands are used to send a signal from the shell
process to another processes. Signals are a way in which one process can
notify another process to do something. Every signal triggers a default
behavior, exiting or ignoring are two common default options (see
[Chapter 13: The Operating
System](../C13-OS/index.html#_the_operating_system){.page} for more
information about signals).
:::

::: paragraph
The `kill` command takes the process id (PID) of the process to send the
signal, and the `pkill` command takes the name of the command or
executable file to which to send the signal (`pkill` sends the signal to
all running processes with the specified name that are owned by the user
running `pkill`). Both `kill` and `pkill` take an optional command line
argument that species the specific signal to send to the process.
Without specifying the specific signal, both default to sending a
termination signal (`SIGTERM`) to the specified process(s).
:::

::: paragraph
A common use of these commands is to send a process a signal to tell it
to exit (this is where `kill` gets its unfortunate name). Note that a
process running in the foreground also can be killed by typing `CTRL-C`,
which sends the process running in the foreground a `SIGINT` signal that
by default tells the process to exit.
:::

::: paragraph
Here is an example call to `pkill` to kill all `a.out` processes:
:::

::: listingblock
::: content
    $ ps
        PID TTY          TIME CMD
    3032597 pts/72   00:00:00 bash
    3033074 pts/72   00:00:04 a.out
    3033076 pts/72   00:00:03 a.out
    3033089 pts/72   00:00:02 a.out
    3033105 pts/72   00:00:00 ps

    $ pkill a.out
    [1]   Terminated              ./a.out
    [2]-  Terminated              ./a.out
    [3]+  Terminated              ./a.out

    $ ps
        PID TTY          TIME CMD
    3032597 pts/72   00:00:00 bash
    3033128 pts/72   00:00:00 ps
:::
:::

::: paragraph
Here is an example call to `kill` to kill a specific `a.out` processes
given its PID (the second process in the first `ps` listing):
:::

::: listingblock
::: content
    $ ps
        PID TTY          TIME CMD
    3032597 pts/72   00:00:00 bash
    3033870 pts/72   00:00:03 a.out
    3033883 pts/72   00:00:02 a.out
    3033886 pts/72   00:00:01 a.out
    3033897 pts/72   00:00:00 ps

    $ kill 3033883
    [2]-  Terminated              ./a.out

    $ ps
        PID TTY          TIME CMD
    3032597 pts/72   00:00:00 bash
    3033870 pts/72   00:00:18 a.out
    3033886 pts/72   00:00:16 a.out
    3033974 pts/72   00:00:00 ps
:::
:::

::: paragraph
Note that `kill` only killed the specific process with a matching pid
value and not every process running the same program (`a.out`).
:::

::: paragraph
In both of these examples, we are not specifying the signal to send.
Without any optional command line options, `kill` and `pkill` send the
process the terminate signal (`SIGTERM` or signal number `15`). By
default, `SIGTERM` tells the signaled process to exit. Sometimes you
will see calls to `kill` and `pkill` that include a different signal
number. In this case the signal number is specified as a command line
argument
(`` -<signal number>').  For example, we could have included the signal number `-9 ``
to send them the `SIGKILL` signal (yet another way to tell a process to
exit):
:::

::: listingblock
::: content
    $ pkill -9 a.out
    $ kill -9 3033883
:::
:::

::: paragraph
In general, these commands can be used to send any signal to a process.
For example, to send a process a `SIGALRM` signal (which is signal
number `14`), you could do this:
:::

::: listingblock
::: content
    $ kill -14 3033883
:::
:::

::: paragraph
If the process doesn't have a signal handler for the `SIGALRM` signal,
the default behavior is that the `SIGALRM` signal is just ignored.
:::

::: paragraph
The man page for `signal` lists the minimal set of signals (and their
signal numbers) that are defined in the system: `man 7 signal`.
:::
:::

::: sect2
### [](#_references){.anchor}17.9.3. References {#_references}

::: paragraph
For more information see:
:::

::: ulist
-   The man pages for these commands (e.g., `man ps`, `man pkill`,
    `man 7 signal`)

-   [most used Unix
    commands](https://www.cheat-sheets.org/project/tldr/command/special-most-used-linux-commands/)
    from cheat-sheets.org

-   [Bash Reference
    Manual](https://www.gnu.org/software/bash/manual/html_node/index.html)
    from gnu.org.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
