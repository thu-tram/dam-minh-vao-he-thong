
-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix Manual](man.html){.nav-link}
        -   [17.3. Remote Access](ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](editors.html){.nav-link}
        -   [17.5. make and Makefiles](makefiles.html){.nav-link}
        -   [17.6 Searching: grep and find](grep.html){.nav-link}
        -   [17.7 File Permissions](chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing Files](tar.html){.nav-link}
        -   [17.9 Process Control](pskill.html){.nav-link}
        -   [17.10 Timing](timing.html){.nav-link}
        -   [17.11 Command History](history.html){.nav-link}
        -   [17.12 I/0 Redirection](ioredirect.html){.nav-link}
        -   [17.13 Pipes](pipe.html){.nav-link}
        -   [17.14 Dot Files and .bashrc](dotfiles.html){.nav-link}
        -   [17.15 Shell Programming](shellprog.html){.nav-link}
        -   [17.16 Getting System Information](sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [17. Appendix 2: Using Unix](index.html)
-   [17.16 Getting System Information](sysinfo.html)
:::

::: content
::: sect1
## [](#sysinfo){.anchor}17.16. Getting System Information {#sysinfo}

::: sectionbody
::: paragraph
There are many tools available for obtaining information about the
system's state: `top` and `htop` provide dynamic summary information
about system resources and resource use, such as CPU and memory use; and
the `/proc` and `/sys` pseudo file systems contain detailed information
about the current state of the system (there are also commands like
`lscpu`, `lsmem`, and `lsgpu` that display some information from `/proc`
and `/sys` in an easier to read form).
:::

::: sect2
### [](#_top_and_htop){.anchor}17.16.1. top and htop {#_top_and_htop}

::: paragraph
Running `top` or `htop` at the command line provides dynamic summary
information about the state of the system. Typing `q` quits `top` and
`htop`. Both show memory and CPU usage information, but `htop` displays
some of the usage statistics more graphically than `top` does,
particularly showing memory usage and each core's CPU utilization as a
graph. Both also, by default, list information about the tasks currently
using the most CPU time. A task is the Linux generic term for either a
process or a thread, These tools update every second as they run,
showing changes in summary system use data. Note that as the display
updates every second, the ordering of processes will change as they
execute according to how much CPU time they are using. Both are also
very configurable to display different information about processes and
system state.
:::

::: paragraph
[Figure 1](#FigHOP) shows an example screenshot from `htop`.
:::

::: {#FigHOP .imageblock .text-center}
::: content
![Example output form htop showing the current cpu usage of the 12
cores, of memory, and information about the top cpu-using
processes.](_images/htop.png){width="600"}
:::

::: title
Figure 1. Example htop screenshot).
:::
:::

::: paragraph
At the very top, `htop` displays the current CPU usage of each of the 12
cores on this system as a usage graph annotated with percentages,
followed the current memory usage (`Mem`), summary information about the
average CPU load (`Load average`), the total number of tasks (`Tasks`)
and threads (`thr`) running in the system, and information about swap
partition usage (`Swp`). Under these is a listing of the tasks using the
most CPU time in the systems. Note that in [Figure 1](#FigHOP) the top
five tasks listed are processes running the `a.out` infinite loop
program, and thus they are unsurprisingly using up a lot of CPU time. At
the bottom of the display are function keys for changing the data
presented in different ways.
:::

::: paragraph
The `top` program displays very similar data to `htop` (but without the
graphical displays at the top), and it similarly provides an interface
to change the data presented in different ways as it runs. For example,
users can view the CPU usage per core in `top` by hitting the "1" key.
:::

::: paragraph
In addition to being very configurable when running, both `top` and
`htop` have a large number of command line options to configure what
they show and how they show it. For example, by default `top` does not
show per-thread statistics (only per-process), but by running with the
`-H` command line option it will.
:::
:::

::: sect2
### [](#_proc_and_sys){.anchor}17.16.2. /proc and /sys {#_proc_and_sys}

::: paragraph
`/proc` and `/sys` are pseudo file systems that provide access to
operating system information about process running in the system and to
information about system state and resources (e.g., devices, buses,
memory, cpu). A **pseudo file system** looks like a file system and can
be interacted with via the filesystem interface, but it doesn't actually
store file data. Instead, through pseudo files in `/proc` and `/sys` a
user can interact with the operating system; reading from pseudo files
in `/proc` and `/sys` (e.g., `cat /proc/filename`) is a way to obtain
information about system state from the OS. Some files in `/proc` and
`/sys` can also be written to, which can trigger the OS to change a
policy or change the state associated with a particular process or
resource in the system. For example, a debugger like GDB may write into
a `/proc` file associated with the process it is debugging to set a
breakpoint, or it may read from a `/proc` file to examine the current
contents of its stack memory.
:::

::: paragraph
Below are a few examples of the type of information that can be obtained
from reading files in `/proc`. In our section on [caching on multicore
processors](../C11-MemHierarchy/coherency.html#_looking_ahead_caching_on_multicore_processors){.page}
we show some examples of how to get information about CPU caches from
files in `/sys`.
:::

::: paragraph
Each process running in the system has a subdirectory in `/proc` named
with its process ID that contains many pseudo files that are interfaces
to the process's state and status. For example, suppose we want to get
some information from `/proc` about the `a.out` process running in the
background like this:
:::

::: listingblock
::: content
    $ ./a.out &
:::
:::

::: paragraph
We first get its process ID by running the `ps` command:
:::

::: listingblock
::: content
    $ ps
        PID TTY          TIME CMD
     246477 pts/0    00:00:00 bash
     246541 pts/0    00:01:59 a.out
     246879 pts/0    00:00:00 ps
:::
:::

::: paragraph
We can then use file system commands to get information about the
running `a.out` program using its process ID `246541` (and note that you
can only access subdirectories in `/proc` associated with processes that
you own). For example:
:::

::: listingblock
::: content
    $ ls /proc/246541/         # list all pseudo files for this process

    $ cat /proc/246541/comm    # list its executable file name
    $ cat /proc/246541/status  # list its status information
:::
:::

::: paragraph
The `status` pseudo file lists a lot of information, including the
following:
:::

::: listingblock
::: content
    State: R (running)  # its state: running, blocked, exited, ...
    VmStk: 132 kB       # size of its stack (in its virtual memory (Vm))
    nonvoluntary_ctxt_switches:  59593   # context switches due to OS CPU scheduling
:::
:::

::: paragraph
This example `a.out` program contains an infinite loop; as it continues
to run, the number of context switches increases, and its state will
always be `R` (for running), until it is killed with `CTRL-C`.
:::

::: paragraph
Pseudo files in `/proc` (and in `/sys`) can also be used to get
information from the OS about system-wide resources. Here are some
examples of getting information from `/proc` (in the Memory Hierarchy
chapter we show an example of getting [caching on multicore
processors](../C11-MemHierarchy/coherency.html#_looking_ahead_caching_on_multicore_processors){.page}
from `/sys`):
:::

::: listingblock
::: content
    cat /proc/meminfo    # info about system memory and its current use
    cat /proc/cpuinfo    # info about each hyperthreaded core
    cat /proc/swaps      # info about swap partitions and their use
    cat /proc/stat       # lots of system statistics
:::
:::

::: paragraph
Linux provides utilities that summarize some information in `/proc` and
`/sys` in a form that is often easier to read than the output from
directly reading files in `/proc` and `/sys`. The `lshw`, `lscpu`, and
`lsgpu` are example commands that list information about the system
hardware, the CPU, and GPU devices on a machine.
:::

::: paragraph
For example, to find the number of physical cores on a machine a user
cat run `lscpu`:
:::

::: listingblock
::: content
    CPU(s):                          32
    On-line CPU(s) list:             0-31
    Thread(s) per core:              2
    Core(s) per socket:              8
    Socket(s):                       2
:::
:::

::: paragraph
The output shows that there are a total of 16 physical cores on the
machine (2 Sockets/chips, and 8 cores per socket/chip). It also shows
that each core is dual-hyperthreaded (2 `Thread(s) per core`), to make
the 16-core machine appear to the operating system a 32-core machine.
Please note that newer Intel architectures introduce P-cores and
E-cores. For these architectures, the total listed CPU(s) may be higher
than the number of physical cores multiplied by the number of sockets
and hardware threads. See [Chapter
14](../C14-SharedMemory/index.html#_leveraging_shared_memory_in_the_multicore_era){.page}
for more information.
:::
:::

::: sect2
### [](#_references){.anchor}17.16.3. References {#_references}

::: paragraph
For more information see:
:::

::: ulist
-   The man pages: `man 5 proc`, `man 5 sysfs`, `man lscpu`, man `lsmem`

-   [tools for examining system
    state](https://www.cs.swarthmore.edu/~newhall/unixhelp/os_stats.php)

-   [some information about
    /proc](https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html)
    from The Linux Documentation Project

-   [/proc/stat
    explained](https://www.linuxhowtos.org/System/procstat.htm) from
    linuxhowtos.org
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
