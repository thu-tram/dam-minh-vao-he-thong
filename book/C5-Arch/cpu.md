
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](index.html){.nav-link}
        -   [5.1. The Origins of Modern Computing](hist.html){.nav-link}
        -   [5.2. The von Neumann Architecture](von.html){.nav-link}
        -   [5.3. Logic Gates](gates.html){.nav-link}
        -   [5.4. Circuits](circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control Circuits](controlcircs.html){.nav-link}
            -   [5.4.3. Storage Circuits](storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs Today](modern.html){.nav-link}
        -   [5.10. Summary](summary.html){.nav-link}
        -   [5.11. Exercises](exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [5. What von Neumann Knew: Computer Architecture](index.html)
-   [5.5. Building a Processor](cpu.html)
:::

::: content
::: sect1
## [](#_building_a_processor_putting_it_all_together){.anchor}5.5. Building a Processor: Putting It All Together {#_building_a_processor_putting_it_all_together}

::: sectionbody
::: paragraph
The **central processing unit** (CPU) implements the processing and
control units of the von Neumann architecture, the parts that drive the
execution of program instructions on program data (see [Figure
1](#FigCPUVonNeumann)).
:::

::: {#FigCPUVonNeumann .imageblock .text-center}
::: content
![von Neumann architecture is the 5 units connected by
buses](_images/vonneumann.png)
:::

::: title
Figure 1. The CPU implements the processing and control unit parts of
the von Neumann architecture.
:::
:::

::: paragraph
The CPU is constructed from basic arithmetic/logic, storage, and control
circuit building blocks. Its main functional components are the
**arithmetic logic unit** (ALU), which performs arithmetic and logic
operations; a set of general-purpose **registers** for storing program
data; some control circuitry and special-purpose registers that are used
in the implementation of instruction execution; and a **clock** that
drives the circuitry of the CPU to execute program instructions.
:::

::: paragraph
In this section, we present the main parts of the CPU, including the ALU
and register file, and show how they are combined to implement a CPU. In
the next section, we discuss how the CPU executes program instructions
and how the clock is used to drive the execution of program
instructions.
:::

::: sect2
### [](#_the_alu){.anchor}5.5.1. The ALU {#_the_alu}

::: paragraph
The ALU is a complex circuit that implements all arithmetic and logic
operations on signed and unsigned integers. A separate floating-point
unit performs arithmetic operations on floating-point values. The ALU
takes integer operand values and an **opcode** value that specifies the
operation to perform (e.g. addition). The ALU outputs the resulting
value of performing the specified operation on the operand inputs and
**condition code** values that encode information about the result of
the operation. Common condition codes specify whether the ALU result is
negative, zero, or if there is a carry-out bit from the operation. For
example, given the C statement
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
x = 6 + 8;
```
:::
:::

::: paragraph
the CPU begins executing the addition by feeding the operand values (6
and 8) and the bits that encode an ADD operation to the ALU circuit. The
ALU computes the result and outputs it along with condition codes to
indicate that the result is nonnegative, is nonzero, and causes no
carry-out. Each condition code is encoded in a single bit. A bit value
of 1 indicates that the condition holds, and a bit value of 0 indicates
that it does not hold for the ALU result. In our example, the bit
pattern 000 specifies the set of three conditions associated with
executing 6+8: the result is not negative (0), is not zero (0), and the
carry-out value is zero (0).
:::

::: paragraph
Condition codes, set by the ALU as part of its execution of an
operation, are sometimes used by subsequent instructions that choose an
action based on a particular condition. For example, an ADD instruction
can compute the (x + 8) part of the following `if` statement:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
if( (x + 8) != 0 ) {
    x++;
}
```
:::
:::

::: paragraph
The ALU's execution of the ADD instruction sets condition codes based on
the result of adding `(x + 8)`. A conditional jump instruction executed
after the ADD instruction tests the condition code bits set by the ADD
instruction and either jumps (skips over executing the instructions in
the `if` body) or not based on their value. For example, if the ADD
instruction sets the zero condition code to 0, the conditional jump
instruction will not jump past the instructions associated with the `if`
body (0 for the zero condition code means that the result of the ADD was
not zero). If the zero condition code is 1, it will jump past the `if`
body instructions. To implement a jump past a set of instructions, the
CPU writes the memory address of the first instruction after the `if`
body instructions into the **program counter** (PC), which contains the
address of the next instruction to execute.
:::

::: paragraph
An ALU circuit combines several arithmetic and logic circuits (for
implementing its set of operations) with a multiplexer circuit to pick
the ALU's output. Rather than trying to selectively activate only the
arithmetic circuit associated with the specific operation, a simple ALU
sends its operand input values to all of its internal arithmetic and
logic circuits. The output from all of the ALU's internal arithmetic and
logic circuits are input to its multiplexer circuit, which chooses the
ALU's output. The opcode input to the ALU is used as the signal input to
the multiplexer to select which arithmetic/logic operation to select as
the ALU's output. Condition code output is based on the MUX output
combined with circuitry to test the output's value to determine each
condition code bit.
:::

::: paragraph
[Figure 2](#Fig4opALU) shows an example ALU circuit that performs four
different operations (ADD, OR, AND, and EQUALS) on two 32-bit operands.
It also produces a single condition code output that indicates whether
the result of the operation is zero. Notice that the ALU directs the
opcode to a multiplexer that selects which of the ALU's four arithmetic
results it outputs.
:::

::: {#Fig4opALU .imageblock .text-center}
::: content
![the 4 operations alu with single condition code for
zero](_images/alu.png)
:::

::: title
Figure 2. A four-function ALU that performs ADD, OR, AND, and EQUALS on
two 32-bit operands. It has one condition code output bit that specifies
whether the result is 0.
:::
:::

::: paragraph
The opcode input to the ALU comes from bits in the instruction that the
CPU is executing. For example, the binary encoding for an ADD
instruction might consist of four parts:
:::

::: listingblock
::: content
      | OPCODE BITS | OPERAND A SOURCE | OPERAND B SOURCE | RESULT DESTINATION |
:::
:::

::: paragraph
Depending on the CPU architecture, operand source bits might encode a
CPU register, the memory address storing the operand value, or literal
operand values. For example, in an instruction to perform 6 + 8, the
literal values 6 and 8 could be encoded directly into the operand
specifier bits of the instruction.
:::

::: paragraph
For our ALU, the opcode requires two bits because the ALU supports four
operations, and two bits can encode four distinct values (00, 01, 10,
11), one for each operation. In general, an ALU that performs *N*
distinct operations, needs log~2~(*N*) opcode bits to specify which
operation result to output from the ALU.
:::

::: paragraph
[Figure 3](#Fig4opcodebits) shows an example of how the opcode and
operand bits of an ADD instruction are used as input into our ALU.
:::

::: {#Fig4opcodebits .imageblock .text-center}
::: content
![instruction and opcode bits sent as three input values into
ALU](_images/aluadd.png){width="600"}
:::

::: title
Figure 3. Opcode bits from an instruction are used by the ALU to choose
which operation to output. In this example, different bits from an ADD
instruction are fed into the ALU operand and opcode inputs to perform
addition of 6 and 8.
:::
:::
:::

::: sect2
### [](#_the_register_file){.anchor}5.5.2. The Register File {#_the_register_file}

::: paragraph
At the top of the memory hierarchy, the CPU's set of general-purpose
registers store temporary values. CPUs provide a very small number of
registers, commonly 8-32 (e.g., the IA32 architecture provides 8, MIPS
provides 16, and ARM provides 13). Instructions often get their operand
values from, or store their results to, general-purpose registers. For
example, an ADD instruction may be encoded as *\"add the value from
Register 1 to the value from Register 2 and store the result in Register
3\"*.
:::

::: paragraph
The CPU's set of general-purpose registers is organized into a
**register file** circuit. A register file consists of a set of
[register circuits](storagecircs.html#_cpu_register){.page} for storing
data values and some [control
circuits](controlcircs.html#_control_circuits){.page} for controlling
reads and writes to its registers. The circuit typically has a single
data input line for the value to write into one of its registers, and
two data output lines for simultaneously reading two values from its
registers.
:::

::: paragraph
[Figure 4](#Figregfile) shows an example of a register file circuit with
four registers. Its two output values (Data out~0~ and Data out~1~) are
controlled by two multiplexer circuits. Each of its read selection
inputs (Sr~0~ and Sr~1~) is fed into one of the MUXs to pick the
register value for the corresponding output. The data input to the
register file (the Data in line) is sent to every register circuit, and
its write enable (WE) input is fed through a demultiplexer (DMUX)
circuit first before being sent to each register circuit. A DMUX circuit
takes one input value and chooses which of *N* outputs to send the value
to, sending the remaining *N-1* outputs 0. The write selection input
(S~w~) to the register file is sent to the DMUX circuit to choose the WE
value's destination register. When the register file's WE input value is
0, no value is written into a register because each register's WE bit
also gets 0 (thus, Data in has no effect on the values stored in the
registers). When the WE bit is 1, the DMUX outputs a WE bit value of 1
to only the register specified by the write selection input (S~w~),
resulting in the Data in value being written to the selected register
only.
:::

::: {#Figregfile .imageblock .text-center}
::: content
![register file](_images/regfile.png){width="800"}
:::

::: title
Figure 4. The register file: the set of CPU general-purpose registers
used to store instruction operand and result values.
:::
:::

::: sect3
#### [](#_special_purpose_registers){.anchor}Special-Purpose Registers {#_special_purpose_registers}

::: paragraph
In addition to the set of general-purpose registers in the register
file, a CPU contains special-purpose registers that store the address
and content of instructions. The **program counter** (PC) stores the
memory address of the next instruction to execute, and the **instruction
register** (IR) stores the bits of the current instruction being
executed by the CPU. The bits of the instruction stored in the IR are
used as input into different parts of the CPU during the instruction's
execution. We discuss these registers in more detail in the next section
on [instruction
execution](instrexec.html#_the_processors_execution_of_program_instructions){.page}.
:::
:::
:::

::: sect2
### [](#_the_cpu){.anchor}5.5.3. The CPU {#_the_cpu}

::: paragraph
With the ALU and register file circuits, we can build the main parts of
the CPU, as shown in [Figure 5](#Figcpu). Because instruction operands
often come from values stored in general-purpose registers, the register
file's outputs send data to the ALU's inputs. Similarly, because
instruction results are often stored in registers, the ALU's result
output is sent as input to the register file. The CPU has additional
circuitry to move data between the ALU, register file, and other
components (e.g., main memory).
:::

::: {#Figcpu .imageblock .text-center}
::: content
![the cpu is built from register file and ALU circuits](_images/cpu.png)
:::

::: title
Figure 5. The ALU and register file make up the main parts of the CPU.
The ALU performs operations, and the register file stores operand and
result values. Additional special-purpose registers store instruction
addresses (PC) and contents (IR). Note that instructions might retrieve
operands from or store results to locations other than the register file
(e.g., main memory).
:::
:::

::: paragraph
These main parts of the CPU make up its **data path**. The data path
consists of the parts of the CPU that perform arithmetic and logic
operations (the ALU) and store data (registers), and the buses that
connect these parts. The CPU also implements a **control path** that
drives the execution of program instructions by the ALU on operands
stored in the register file. Additionally, the control path issues
commands to I/O devices and coordinates memory accesses as needed by
instructions. For example, some instructions may get their operand
values directly from (or store their results directly to) memory
locations rather than general-purpose registers. In the next section, we
focus our discussion of CPU instruction execution on instructions that
get operand values and store results to the register file. The CPU
requires additional control circuitry to read operand values or to write
instruction results to other locations, but the main instruction
execution steps behave the same regardless of the source and destination
locations.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
