
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](index.html){.nav-link}
        -   [5.1. The Origins of Modern Computing](hist.html){.nav-link}
        -   [5.2. The von Neumann Architecture](von.html){.nav-link}
        -   [5.3. Logic Gates](gates.html){.nav-link}
        -   [5.4. Circuits](circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control Circuits](controlcircs.html){.nav-link}
            -   [5.4.3. Storage Circuits](storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs Today](modern.html){.nav-link}
        -   [5.10. Summary](summary.html){.nav-link}
        -   [5.11. Exercises](exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [5. What von Neumann Knew: Computer Architecture](index.html)
-   [5.1. The Origins of Modern Computing](hist.html)
:::

::: content
::: sect1
## [](#_the_origin_of_modern_computing_architectures){.anchor}5.1. The Origin of Modern Computing Architectures {#_the_origin_of_modern_computing_architectures}

::: sectionbody
::: paragraph
When tracing the ancestry of modern computing architecture, it is
tempting to consider that modern computers are part of a linear chain of
successive transmutations, with each machine simply an improvement of
the one that previously existed. While this view of inherited
improvements in computer design may hold true for certain classes of
architecture (consider the iterative improvements of the iPhone X from
the original iPhone), the root of the architectural tree is much less
defined.
:::

::: paragraph
From the 1700s until the early 1900s, mathematicians served as the first
*human* computers for calculations related to applications of science
and engineering^1^. The word \"computer\" originally referred to \"one
who computes\". Women mathematicians often served in the role of
computer. In fact, the use of women as human computers was so pervasive
that computational complexity was measured in \"kilo-girls\", or the
amount of work a thousand human computers could complete in one hour^2^.
Women were widely considered to be better at doing mathematical
calculations than men, as they tended to be more methodical. Women were
not allowed to hold the position of engineer. As such, they were
relegated to more \"menial\" work, such as computing complex
calculations.
:::

::: paragraph
The first general-purpose digital computer, the *Analytical Engine*, was
designed by British mathematician Charles Babbage, who is credited by
some as the father of the computer. The Analytical Engine was an
extension of his original invention, the Difference Engine, a mechanical
calculator that was capable of calculating polynomial functions. Ada
Lovelace, who perhaps should be known as the mother of computing, was
the very first person to develop a computer program and the first to
publish an algorithm that could be computed using Charles Babbage's
Analytical Engine. In her notes is included her recognition of the
general-purpose nature of the Analytical Engine: \"\[t\]he Analytical
Engine has no pretensions whatever to originate anything. It can do
whatever we know how to order it to perform.^3^\" However, unlike modern
computers, the Analytical Engine was a mechanical device and was only
partially built. Most of the designers of what became the direct
forerunners to the modern computer were unaware of the work of Babbage
and Lovelace when they developed their own machines.
:::

::: paragraph
Thus, it is perhaps more accurate to think about modern computer
architecture rising out of a primordial soup of ideas and innovations
that arose in the 1930s and 1940s. For example, in 1937, Claude Shannon,
a student at MIT, wrote what would go on to be perhaps the most
influential masters thesis of all time. Drawing upon the work of George
Boole (the mathematician who developed Boolean algebra), Shannon showed
that Boolean logic could be applied to circuits and could be used to
develop electrical switches. This would lead to the development of the
binary computing system, and much of future digital circuit design.
While men would design many early electronic computers, women (who were
not allowed to be engineers) became programming pioneers, leading the
design and development of many early software innovations, such as
programming languages, compilers, algorithms, and operating systems.
:::

::: paragraph
A comprehensive discussion of the rise of computer architecture is not
possible in this book (see *Turing's Cathedral*^4^ by George Dyson and
*The Innovators*^6^ by Walter Isaacson for more detailed coverage);
however, we briefly enumerate several significant innovations that
occurred in the 1930s and 1940s that were instrumental in the rise of
modern computer architecture.
:::

::: sect2
### [](#_the_turing_machine){.anchor}5.1.1. The Turing Machine {#_the_turing_machine}

::: paragraph
In 1937, British mathematician Alan Turing proposed^7^ the \"Logical
Computing Machine\", a theoretical computer. Turing used this machine to
prove that there exists no solution to the decision problem (in German,
the *Entscheidungsproblem*), posed by the mathematicians David Hilbert
and Wilhelm Ackermann in 1928. The decision problem is an algorithm that
takes a statement as input and determines whether the statement is
universally valid. Turing proved that no such algorithm exists by
showing that the *halting problem* (will machine *X* halt on input *y*?)
was undecidable for Turing's machine. As part of this proof, Turing
described a universal machine that is capable of performing the tasks of
any other computing machine. Alonzo Church, Turing's dissertation
advisor at Princeton University, was the first to refer to the *logical
computing machine* as the *Turing machine*, and its universal form as
the *universal Turing machine*.
:::

::: paragraph
Turing later returned to England and served his country as part of the
code breaking unit in Bletchley Park during World War II. He was
instrumental in the design and construction of the *Bombe*, an
electromechanical device that helped break the cipher produced by the
Enigma machine, which was commonly used by Nazi Germany to protect
sensitive communication during World War II.
:::

::: paragraph
After the war, Turing designed the *automatic computing engine* (ACE).
The ACE was a stored-program computer, meaning that both the program
instructions and its data are loaded into the computer memory and run by
the general-purpose computer. His paper, published in 1946, is perhaps
the most detailed description of such a computer^8^.
:::
:::

::: sect2
### [](#_early_electronic_computers){.anchor}5.1.2. Early Electronic Computers {#_early_electronic_computers}

::: paragraph
World War II accelerated much of the development of early computers.
However, due to the classified nature of military operations in World
War II, many of the details of innovations that occurred as a result of
the frenetic activity during the war was not publicly acknowledged until
years later. A good example of this is Colossus, a machine designed by
British engineer Tommy Flowers to help break the Lorenz cipher, which
was used by Nazi Germany to encode high-level intelligence
communication. Some of Alan Turing's work aided in its design. Built in
1943, Colossus is arguably the first programmable, digital, and fully
electronic computer. However, it was a special-purpose computer,
designed specifically for code breaking. The Women's Royal Naval Service
(WRNS, known as the \"Wrens\") served as operators of Colossus. In spite
of the *General Report of the Tunny*^14^ noting that several of the
Wrens showed ability in cryptographic work, none of them were given the
position of cryptographer, and instead were delegated more menial
Colossus operation tasks^5^,^15^.
:::

::: paragraph
On the other side of the Atlantic, American scientists and engineers
were hard at work creating computers of their own. Harvard professor
Howard Aiken (who was also a Naval Commander in the U.S. Navy Reserves)
designed the Mark I, an electromechanical, general-purpose programmable
computer. Built in 1944, it aided in the design of the atomic bomb.
Aiken built his computer largely unaware of Turing's work and was
motivated by the goal of bringing Charles Babbage's analytical engine to
life^6^. A key feature of the Mark I was that it was fully automatic and
able to run for days without human intervention^6^. This would be a
foundational feature in future computer design.
:::

::: paragraph
Meanwhile, American engineers John Mauchly and Presper Eckert of the
University of Pennsylvania designed and built the *Electronic Numerical
Integrator and Computer* (ENIAC) in 1945. ENIAC is arguably the
forerunner of modern computers. It was digital (though it used decimal
rather than binary), fully electronic, programmable, and general
purpose. While the original version of ENIAC did not have stored-program
capabilities, this feature was built into it before the end of the
decade. ENIAC was financed and built for the U.S. Army's Ballistic
Research Laboratory and was designed primarily to calculate ballistic
trajectories. Later, it would be used to aid in the design of the
hydrogen bomb.
:::

::: paragraph
As men were drafted into the armed forces during World War II, women
were hired to help in the war effort as human computers. With the
arrival of the first electronic computers, women became the first
programmers, as programming was considered secretarial work. It should
come as no surprise that many of the early innovations in programming,
such as the first compiler, the notion of modularizing programs,
debugging, and assembly language, are credited to women inventors. Grace
Hopper, for example, developed the first high-level and
machine-independent programming language (COBOL) and its compiler.
Hopper was also a programmer for the Mark I and wrote the book that
described its operation.
:::

::: paragraph
The ENIAC programmers were six women: Jean Jennings Bartik, Betty Snyder
Holberton, Kay McNulty Mauchly, Frances Bilas Spence, Marlyn Wescoff
Meltzer, and Ruth Lichterman Teitelbaum. Unlike the Wrens, the ENIAC
women were given a great deal of autonomy in their task; given just the
wiring diagrams of ENIAC, they were told to figure out how it worked and
how to program it. In addition to their innovation in solving how to
program (and debug) one of the world's first electronic general-purpose
computers, the ENIAC programmers also developed the idea of algorithmic
flow charts, and developed important programming concepts such as
subroutines and nesting. Like Grace Hopper, Jean Jennings Bartik and
Betty Snyder Holberton would go on to have long careers in computing,
and are some of the early computing pioneers. Unfortunately, the full
extent of women's contributions in early computing is not known. Unable
to advance, many women left the field after World War II. To learn more
about early women programmers, we encourage readers to check out
*Recoding Gender* ^11^ by Janet Abbate, *Top Secret Rosies*, a PBS
documentary^12^ directed by LeAnn Erickson, and *\"The Computers\"* by
Kathy Kleiman^13^.
:::

::: paragraph
The British and the Americans were not the only ones interested in the
potential of computers. In Germany, Konrad Zuse developed the first
electromechanical general-purpose digital programmable computer, the Z3,
which was completed in 1941. Zuse came up with his design independently
of the work of Turing and others. Notably, Zuse's design used binary
(rather than decimal), the first computer of its kind to use the binary
system. However, the Z3 was destroyed during aerial bombing of Berlin,
and Zuse was unable to continue his work until 1950. His work largely
went unrecognized until years later. He is widely considered the father
of computing in Germany.
:::
:::

::: sect2
### [](#_so_what_did_von_neumann_know){.anchor}5.1.3. So What Did von Neumann Know? {#_so_what_did_von_neumann_know}

::: paragraph
From our discussion of the origin of modern computer architecture, it is
apparent that in the 1930s and 1940s there were several innovations that
led to the rise of the computer as we know it today. In 1945, John von
Neumann published a paper, \"First draft of a report on the EDVAC\"^9^,
which describes an architecture on which modern computers are based.
EDVAC was the successor of ENIAC. It differed from ENIAC in that it was
a binary computer instead of decimal, and it was a stored-program
computer. Today, this description of EDVAC's architectural design is
known as the *von Neumann architecture*.
:::

::: paragraph
The **von Neumann architecture** describes a general-purpose computer,
one that is designed to run any program. It also uses a stored-program
model, meaning that program instructions and data are both loaded onto
the computer to run. In the von Neumann model there is no distinction
between instructions and data; both are loaded into the computer's
internal memory, and program instructions are fetched from memory and
executed by the computer's functional units that execute program
instructions on program data.
:::

::: paragraph
John von Neumann's contributions weave in and out of several of the
previous stories in computing. A Hungarian mathematician, he was a
professor at both the Institute of Advanced Study and Princeton
University, and he served as an early mentor to Alan Turing. Later, von
Neumann became a research scientist on the Manhattan Project, which led
him to Howard Aiken and the Mark I; he would later serve as a consultant
on the ENIAC project, and correspond regularly with Eckert and Mauchly.
His famous paper describing EDVAC came from his work on the Electronic
Discrete Variable Automatic Computer (EDVAC), proposed to the U.S. Army
by Eckert and Mauchly, and built at the University of Pennsylvania.
EDVAC included several architectural design innovations that form the
foundation of almost all modern computers: it was general purpose, used
the binary numeric system, had internal memory, and was fully electric.
In large part because von Neumann was the sole author of the paper^9^,
the architectural design the paper describes is primarily credited to
von Neumann and has become known as the von Neumann architecture. It
should be noted that Turing described in great detail the design of a
similar machine in 1946. However, since von Neumann's paper was
published before Turing's, von Neumann received the chief credit for
these innovations.
:::

::: paragraph
Regardless of who \"really\" invented the von Neumann architecture, von
Neumann's own contributions should not be diminished. He was a brilliant
mathematician and scientist. His contributions to mathematics range from
set theory to quantum mechanics and game theory. In computing, he is
also regarded as the inventor of the *merge sort* algorithm. Walter
Isaacson, in his book *The Innovators*, argued that one of von Neumann's
greatest strengths lay in his ability to collaborate widely and to
intuitively see the importance of novel concepts^6^. A lot of the early
designers of the computer worked in isolation from one another. Isaacson
argues that by witnessing the slowness of the Mark I computer, von
Neumann was able to intuitively realize the value of a truly electronic
computer, and the need to store and modify programs in memory. It could
therefore be argued that von Neumann, even more than Eckert and Mauchly,
grasped and fully appreciated the power of a fully electronic
stored-program computer^6^.
:::
:::

::: sect2
### [](#_references){.anchor}5.1.4. References {#_references}

::: {.olist .arabic}
1.  David Alan Grier, *\"When Computers Were Human\"*, Princeton
    University Press, 2005.

2.  Megan Garber, *\"Computing Power Used to be Measured in
    \'Kilo-Girls\'\"*. The Atlantic, October 16, 2013.
    [https://www.theatlantic.com/technology/archive/2013/10/computing-power-used-to-be-measured-in-kilo-girls/280633/](https://www.theatlantic.com/technology/archive/2013/10/computing-power-used-to-be-measured-in-kilo-girls/280633/){.bare}

3.  Betty Alexandra Toole, *\"Ada, The Enchantress of Numbers\"*.
    Strawberry Press, 1998.

4.  George Dyson, *Turing's Cathedral: the origins of the digital
    universe*. Pantheon. 2012.

5.  Jack Copeland, *\"Colossus: The Secrets of Bletchley Park's
    Code-breaking Computers\"*.

6.  Walter Isaacson. *\"The Innovators: How a group of inventors,
    hackers, genius and geeks created the digital revolution\"*. Simon
    and Schuster. 2014.

7.  Alan M. Turing. *\"On computable numbers, with an application to the
    Entscheidungsproblem\"*. *Proceedings of the London mathematical
    society* 2(1). pp. 230---​265. 1937.

8.  Brian Carpenter and Robert Doran. *\"The other Turing Machine\"*.
    *The Computer Journal* 20(3) pp. 269---​279. 1977.

9.  John von Neumann. *\"First Draft of a Report on the EDVAC (1945)\"*.
    Reprinted in *IEEE Annals of the history of computing* 4. pp.
    27---​75. 1993.

10. Arthur Burks, Herman Goldstine, John von Neumann. *\"Preliminary
    discussion of the logical design of an electronic computing
    instrument (1946)\"*. Reprinted by *The Origins of Digital
    Computers* (Springer), pp. 399---​413. 1982.

11. Janet Abbate. *\"Recoding gender: Women's changing participation in
    computing\"*. MIT Press. 2012.

12. LeAnn Erickson. *\"Top Secret Rosies: The Female Computers of World
    War II\"*. Public Broadcasting System. 2010.

13. Kathy Kleiman, *\"The Computers\"*.
    [http://eniacprogrammers.org/](http://eniacprogrammers.org/){.bare}

14. *\"Breaking Teleprinter Ciphers at Bletchley Park: An edition of
    I.J. Good, D. Michie and G. Timms: General Report on Tunny with
    Emphasis on Statistical Methods (1945)\"*. Editors: Reeds, Diffie,
    Fields. Wiley, 2015.

15. Janet Abbate, *\"Recoding Gender\"*, MIT Press, 2012.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
