
-   -   [4. Binary and Data
        Representation](../C4-Binary/index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](../C4-Binary/bases.html){.nav-link}
        -   [4.2. Converting Between
            Bases](../C4-Binary/conversion.html){.nav-link}
        -   [4.3. Signed Binary
            Integers](../C4-Binary/signed.html){.nav-link}
        -   [4.4. Binary Integer
            Arithmetic](../C4-Binary/arithmetic.html){.nav-link}
            -   [4.4.1.
                Addition](../C4-Binary/arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](../C4-Binary/arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](../C4-Binary/arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](../C4-Binary/overflow.html){.nav-link}
        -   [4.6. Bitwise
            Operators](../C4-Binary/bitwise.html){.nav-link}
        -   [4.7. Integer Byte
            Order](../C4-Binary/byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](../C4-Binary/floating_point.html){.nav-link}
        -   [4.9. Summary](../C4-Binary/summary.html){.nav-link}
        -   [4.10. Exercises](../C4-Binary/exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](index.html){.nav-link}
        -   [5.1. The Origins of Modern Computing](hist.html){.nav-link}
        -   [5.2. The von Neumann Architecture](von.html){.nav-link}
        -   [5.3. Logic Gates](gates.html){.nav-link}
        -   [5.4. Circuits](circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control Circuits](controlcircs.html){.nav-link}
            -   [5.4.3. Storage Circuits](storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs Today](modern.html){.nav-link}
        -   [5.10. Summary](summary.html){.nav-link}
        -   [5.11. Exercises](exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [5. What von Neumann Knew: Computer Architecture](index.html)
-   [5.2. The von Neumann Architecture](von.html)
:::

::: content
::: sect1
## [](#_the_von_neumann_architecture){.anchor}5.2. The von Neumann Architecture {#_the_von_neumann_architecture}

::: sectionbody
::: paragraph
The von Neumann architecture serves as the foundation for most modern
computers. In this section, we briefly characterize the architecture's
major components.
:::

::: paragraph
The von Neumann architecture (depicted in [Figure 1](#FIGvonNeumann))
consists of five main components:
:::

::: {.olist .arabic}
1.  The **processing unit** executes program instructions.

2.  The **control unit** drives program instruction execution on the
    processing unit. Together, the processing and control units make up
    the CPU.

3.  The **memory unit** stores program data and instructions.

4.  The **input unit(s)** load program data and instructions on the
    computer and initiate program execution.

5.  The **output unit(s)** store or receive program results.
:::

::: paragraph
Buses connect the units, and are used by the units to send control and
data information to one another. A **bus** is a communication channel
that transfers binary values between communication endpoints (the
senders and receivers of the values). For example, a data bus that
connects the memory unit and the CPU could be implemented as 32 parallel
wires that together transfer a 4-byte value, 1-bit transferred on each
wire. Typically, architectures have separate buses for sending data,
memory addresses, and control between units. The units use the control
bus to send control signals that request or notify other units of
actions, the address bus to send the memory address of a read or write
request to the memory unit, and the data bus to transfer data between
units.
:::

::: {#FIGvonNeumann .imageblock .text-center}
::: content
![the 5 units of the von Neumann architecture are shown as boxes, the
units are connected by buses shown as lines running below the boxes to
which each box is connected.](_images/vonNArch.png){width="700"}
:::

::: title
Figure 1. The von Neumann architecture consists of the processing,
control, memory, input, and output units. The control and processing
units make up the CPU, which contains the ALU, the general-purpose CPU
registers, and some special-purpose registers (IR and PC). The units are
connected by buses used for data transfer and communication between the
units.
:::
:::

::: sect2
### [](#_the_cpu){.anchor}5.2.1. The CPU {#_the_cpu}

::: paragraph
The control and processing units together implement the CPU, which is
the part of the computer that executes program instructions on program
data.
:::
:::

::: sect2
### [](#_the_processing_unit){.anchor}5.2.2. The Processing Unit {#_the_processing_unit}

::: paragraph
The **processing unit** of the von Neumann machine consists of two
parts. The first is the **arithmetic/logic unit** (ALU), which performs
mathematical operations such as addition, subtraction, and logical or,
to name a few. Modern ALUs typically perform a large set of arithmetic
operations. The second part of the processing unit is a set of
registers. A **register** is a small, fast unit of storage used to hold
program data and the instructions that are being executed by the ALU.
Crucially, there is no distinction between instructions and data in the
von Neumann architecture. For all intents and purposes, instructions
*are* data. Each register is therefore capable of holding one data word.
:::
:::

::: sect2
### [](#_the_control_unit){.anchor}5.2.3. The Control Unit {#_the_control_unit}

::: paragraph
The **control unit** drives the execution of program instructions by
loading them from memory and feeding instruction operands and operations
through the processing unit. The control unit also includes some storage
to keep track of execution state and to determine its next action to
take: the **program counter** (PC) keeps the memory address of the next
instruction to execute, and the **instruction register** (IR) stores the
instruction, loaded from memory, that is currently being executed.
:::
:::

::: sect2
### [](#_the_memory_unit){.anchor}5.2.4. The Memory Unit {#_the_memory_unit}

::: paragraph
Internal memory is a key innovation of the von Neumann architecture. It
provides program data storage that is close to the processing unit,
significantly reducing the amount of time to perform calculations. The
**memory unit** stores both program data and program
instructions --- storing program instructions is a key part of the
stored-program model of the von Neumann architecture.
:::

::: paragraph
The size of memory varies from system to system. However, a system's ISA
limits the range of addresses that it can express. In modern systems,
the smallest addressable unit of memory is one byte (8 bits), and thus
each address corresponds to a unique memory location for one byte of
storage. As a result, 32-bit architectures typically support a maximum
address space size of 2^32^, which corresponds to 4 gigabytes (GiB) of
addressable memory.
:::

::: paragraph
The term **memory** sometimes refers to an entire hierarchy of storage
in the system. It can include registers in the processing unit as well
as secondary storage devices like hard disk drives (HDD) or solid-state
drives (SSD). In the [Storage and Memory Hierarchy
Chapter](../C11-MemHierarchy/index.html#_storage_and_the_memory_hierarchy){.page},
we discuss the memory hierarchy in detail. For now, we use the term
\"memory\" interchangeably with internal **random access memory**
(RAM) --- memory that can be accessed by the central processing unit.
RAM storage is random access because all RAM storage locations
(addresses) can be accessed directly. It is useful to think of RAM as a
linear array of addresses, where each address corresponds to one byte of
memory.
:::

::: sidebarblock
::: content
::: title
Word sizes through history
:::

::: paragraph
**Word size**, which is defined by an ISA, is the number of bits of the
standard data size that a processor handles as a single unit. The
standard word size has fluctuated over the years. For EDVAC, the word
size was proposed at 30 bits. In the 1950s, 36-bit word sizes were
common. With the innovation of the IBM 360 in the 1960s, word sizes
became more or less standardized, and started to expand from 16 bits, to
32 bits, to today's 64 bits. If you examine the Intel architecture in
more detail, you may notice the remnants of some of these old decisions,
as 32-bit and 64-bit architectures were added as extensions of the
original 16-bit architecture.
:::
:::
:::
:::

::: sect2
### [](#_the_input_and_output_io_units){.anchor}5.2.5. The Input and Output (I/O) Units {#_the_input_and_output_io_units}

::: paragraph
While the control, processing, and memory units form the foundation of
the computer, the input and output units enable it to interact with the
outside world. In particular, they provide mechanisms for loading a
program's instructions and data into memory, storing its data outside of
memory, and displaying its results to users.
:::

::: paragraph
The **input unit** consists of the set of devices that enable a user or
program to get data from the outside world into the computer. The most
common forms of input devices today are the keyboard and mouse. Cameras
and microphones are other examples.
:::

::: paragraph
The **output unit** consists of the set of devices that relay results of
computation from the computer back to the outside world or that store
results outside internal memory. For example, the monitor is a common
output device. Other output devices include speakers and haptics.
:::

::: paragraph
Some modern devices, such as the touchscreen, act as both input and
output, enabling users to both input and receive data from a single
unified device.
:::

::: paragraph
Solid-state and hard drives are another example of devices that act as
both input and output devices. These storage devices act as input
devices when they store program executable files that the operating
system loads into computer memory to run, and they act as output devices
when they store files to which program results are written.
:::
:::

::: sect2
### [](#_the_von_neumann_machine_in_action_executing_a_program){.anchor}5.2.6. The von Neumann Machine in Action: Executing a Program {#_the_von_neumann_machine_in_action_executing_a_program}

::: paragraph
The five units that make up the von Neumann architecture work together
to implement a **fetch-decode-execute-store** cycle of actions that
together execute program instructions. This cycle starts with a
program's first instruction, and is repeated until the program exits:
:::

::: {.olist .arabic}
1.  **The control unit *fetches* the next instruction from memory**. The
    control unit has a special register, the program counter (PC), that
    contains the address of the next instruction to fetch. It places
    that address on the *address bus* and places a *read* command on the
    *control bus* to the memory unit. The memory unit then reads the
    bytes stored at the specified address and sends them to the control
    unit on the *data bus*. The instruction register (IR) stores the
    bytes of the instruction received from the memory unit. The control
    unit also increments the PC's value to store the address of the new
    next instruction to fetch.

2.  **The control unit *decodes* the instruction stored in the IR**. It
    decodes the instruction bits that encode which operation to perform
    and the bits that encode where the operands are located. The
    instruction bits are decoded based on the ISA's definition of the
    encoding of its instructions. The control unit also fetches the data
    operand values from their locations (from CPU registers, memory, or
    encoded in the instruction bits), as input to the processing unit.

3.  **The processing unit *executes* the instruction**. The ALU performs
    the instruction operation on instruction data operands.

4.  **The control unit *stores* the result to memory**. The result of
    the processing unit's execution of the instruction is stored to
    memory. The control unit writes the result to memory by placing the
    result value on the *data bus*, placing the address of the storage
    location on the *address bus*, and placing a *write* command on the
    *control bus*. When received, the memory unit writes the value to
    memory at the specified address.
:::

::: paragraph
The input and output units are not directly involved in the execution of
program instructions. Instead, they participate in the program's
execution by loading a program's instructions and data and by storing or
displaying the results of the program's computation.
:::

::: paragraph
[Figure 2](#FIGvonFD) and [Figure 3](#FIGvonES) show the four phases of
instruction execution by the von Neumann architecture for an example
addition instruction whose operands are stored in CPU registers. In the
*fetch* phase, the control unit reads the instruction at the memory
address stored in the PC (1234). It sends the address on the address
bus, and a READ command on the control bus. The memory unit receives the
request, reads the value at address 1234, and sends it to the control
unit on the data bus. The control unit places the instruction bytes in
the IR register and updates the PC with the address of the next
instruction (1238 in this example). In the *decode* phase, the control
unit feeds bits from the instruction that specify which operation to
perform to the processing unit's ALU, and uses instruction bits that
specify which registers store operands to read operand values from the
processing unit's registers into the ALU (the operand values are 3 and 4
in this example). In the *execute* phase, the ALU part of the processing
unit executes the operation on the operands to produce the result (3 + 4
is 7). Finally, in the *store* phase the control unit writes the result
(7) from the processing unit to the memory unit. The memory address
(5678) is sent on the address bus, a WRITE command is sent on the
control bus, and the data value to store (7) is sent on the data bus.
The memory unit receives this request and stores 7 at memory address
5678. In this example, we assume that the memory address to store the
result is encoded in the instruction bits.
:::

::: {#FIGvonFD .imageblock .text-center}
::: content
![This figure of von Neumann execution shows the processing, control and
memory units in each of the four stages of execution. Each unit is shown
as a box, with buses shown as lines running below the boxes to which
each box is connected.](_images/vonFD.png)
:::

::: title
Figure 2. The fetch and decode stages of execution of the von Neumann
architecture for an example addition instruction. Operand, result, and
memory addresses are shown as decimal values, memory contents are shown
as binary values.
:::
:::

::: {#FIGvonES .imageblock .text-center}
::: content
![This figure of von Neumann execution shows the processing, control and
memory units in each of the four stages of execution. Each unit is shown
as a box, with buses shown as lines running below the boxes to which
each box is connected.](_images/vonES.png)
:::

::: title
Figure 3. The execute and store stages of execution of the von Neumann
architecture for an example addition instruction. Operand, result, and
memory addresses are shown as decimal values, memory contents are shown
as binary values.
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
