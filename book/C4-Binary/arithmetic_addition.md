
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.4. Binary Integer Arithmetic](arithmetic.html)
-   [4.4.1. Addition](arithmetic_addition.html)
:::

::: content
::: sect2
### [](#_addition){.anchor}4.4.1. Addition {#_addition}

::: paragraph
Recall that in a binary number, each digit holds only 0 or 1.
Consequently, when adding two bits that are *both* 1, the result
*carries out* to the next digit (e.g., 1 + 1 = 0b10, which requires two
bits to represent). In practice, programs add multibit variables, where
the result of one digit's *carry out* influences the next digit by
*carrying in*.
:::

::: paragraph
In general, when summing digits from two binary numbers (*A* and *B*),
there are *eight* possible outcomes depending on the values of
*Digit~A~*, *Digit~B~*, and a *Carry~in~* from the previous digit.
[Table 1](#TabBinarySum) enumerates the eight possibilities that may
result from adding one pair of bits. The *Carry~in~* column refers to a
carry feeding into the sum from the previous digit, and the *Carry~out~*
column indicates whether adding the pair of digits will feed a carry out
to the next digit.
:::

+--------+--------+--------+-----------------+-----------------+--------+
| Inputs |        |        |                 | Outputs         |        |
+--------+--------+--------+-----------------+-----------------+--------+
| Di     | Di     | Car    |                 | Result (Sum)    | Carr   |
| git~A~ | git~B~ | ry~in~ |                 |                 | y~out~ |
+--------+--------+--------+-----------------+-----------------+--------+
| 0      | 0      | 0      |                 | 0               | 0      |
+--------+--------+--------+-----------------+-----------------+--------+
| 0      | 0      | 1      |                 | 1               | 0      |
+--------+--------+--------+-----------------+-----------------+--------+
| 0      | 1      | 0      |                 | 1               | 0      |
+--------+--------+--------+-----------------+-----------------+--------+
| 0      | 1      | 1      |                 | 0               | 1      |
+--------+--------+--------+-----------------+-----------------+--------+
| 1      | 0      | 0      |                 | 1               | 0      |
+--------+--------+--------+-----------------+-----------------+--------+
| 1      | 0      | 1      |                 | 0               | 1      |
+--------+--------+--------+-----------------+-----------------+--------+
| 1      | 1      | 0      |                 | 0               | 1      |
+--------+--------+--------+-----------------+-----------------+--------+
| 1      | 1      | 1      |                 | 1               | 1      |
+--------+--------+--------+-----------------+-----------------+--------+

: Table 1. The Eight Possible Outcomes of Adding Two Binary Digits (*A*
and *B*) with a Potential Carry In from the Previous Digit

::: paragraph
Consider the addition of two four-bit binary numbers. Start by lining up
the numbers so that their corresponding digits match vertically, and
then sum each corresponding digit in order, from the low-order digit
(d~0~) to the high-order digit (d~3~). For example, adding 0b0010 +
0b1011:
:::

+-------------+--------------------------------------------------------+
| Problem     | Worked Example                                         |
| Setup       |                                                        |
+=============+========================================================+
| ::: content | ::: content                                            |
| ::: l       | ::: listingblock                                       |
| istingblock | ::: content                                            |
| ::: content |                                                        |
|             |          1    <- Carry the 1 from digit 1 into digit 2 |
|       0010  |             0010                                       |
|     + 1011  |           + 1011                                       |
| :::         |                                                        |
| :::         |     Result: 1101                                       |
| :::         | :::                                                    |
|             | :::                                                    |
|             | :::                                                    |
+-------------+--------------------------------------------------------+

::: paragraph
The example shows a 1 carrying from d~1~ into d~2~. This situation is
analogous to adding two decimal digits that sum to a value larger than
9. For example, when adding 5 + 8 = 13, the resulting ones place
contains 3, and a 1 carries into the tens place.
:::

::: paragraph
The first operand (0b0010) has a leading 0, so it represents 2 for both
two's complement and unsigned interpretations. The second operand
(0b1011) represents -5 if interpreted as a signed two's complement
value. Otherwise, it represents 11 if interpreted as an unsigned value.
Fortunately, the interpretation of the operands doesn't affect the steps
for computing the result. That is, the computed result (0b1101)
represents either 13 (unsigned: 2 + 11) or -3 (signed: 2 + -5), both of
which are correct depending on the interpretation of the second operand.
:::

::: {#carryout .paragraph}
More generally, a four-bit sequence represents values in the range \[0,
15\] when interpreted as *unsigned*. When interpreted as *signed*, it
represents the range \[-8, 7\]. In the previous example, the result fits
within the representable range either way, but we may not always be so
lucky. For example, when adding 0b1100 (unsigned 12) + 0b0111 (7), the
answer should be 19, but four bits can't represent 19:
:::

+-------------+--------------------------------------------------------+
| Problem     | Worked Example                                         |
| Setup       |                                                        |
+=============+========================================================+
| ::: content | ::: content                                            |
| ::: l       | ::: listingblock                                       |
| istingblock | ::: content                                            |
| ::: content |                                                        |
|             |    11     <- Carry a 1 from: digit 2 into digit 3, and |
|       1100  |                   110                                  |
|     + 0111  | 0                     digit 3 out of the overall value |
| :::         |                +  0111                                 |
| :::         |                                                        |
| :::         |        Result:    0011                                 |
|             |     Carry out:   1                                     |
|             | :::                                                    |
|             | :::                                                    |
|             | :::                                                    |
+-------------+--------------------------------------------------------+

::: paragraph
Note that the addition in this example carries a 1 from the most
significant bit, a condition known as a **carry out** for the overall
arithmetic operation. In this example, the carry out suggests that the
arithmetic output needs an extra bit to store the intended result.
However, when performing four-bit arithmetic, there's nowhere to put the
carry out's extra bit, so the hardware simply drops or **truncates** it,
leaving 0b0011 as the result. Of course, if the goal was to add 12 + 7,
a result of 3 is likely to be surprising. The surprise is a consequence
of *overflow*. We'll explore how to detect overflow and why it produces
the results that it does in a [later
section](overflow.html#_integer_overflow){.page}.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: paragraph                     |
|                                   | Multibit adder circuits also      |
|                                   | support a **carry in** that       |
|                                   | behaves like a carry into the     |
|                                   | rightmost digit (that is, it      |
|                                   | serves as the *Carry~in~* input   |
|                                   | for d~0~). The carry in isn't     |
|                                   | useful when performing            |
|                                   | addition --- it's implicitly set  |
|                                   | to 0, which is why it doesn't     |
|                                   | appear in the preceding example.  |
|                                   | However, the carry in does become |
|                                   | relevant for other operations     |
|                                   | that use adder circuitry, most    |
|                                   | notably                           |
|                                   | [subtraction](arithmetic_subtr    |
|                                   | action.html#_subtraction){.page}. |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
