
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.1. Number Bases and Unsigned Integers](bases.html)
:::

::: content
::: sect1
## [](#_number_bases_and_unsigned_integers){.anchor}4.1. Number Bases and Unsigned Integers {#_number_bases_and_unsigned_integers}

::: sectionbody
::: paragraph
Having seen that [binary sequences can be interpreted in all sorts of
nonnumerical ways](index.html#_binary_and_data_representation){.page},
let's turn our attention to numbers. Specifically, we'll start with
**unsigned** numbers, which can be interpreted as zero or positive, but
they can never be negative (they have no *sign*).
:::

::: sect2
### [](#_decimal_numbers){.anchor}4.1.1. Decimal Numbers {#_decimal_numbers}

::: paragraph
Rather than starting with binary, let's first examine a number system
we're already comfortable using, the **decimal number system**, which
uses a *base* of 10. *Base 10* implies two important properties for the
interpretation and representation of decimal values.
:::

::: {.olist .arabic}
1.  Any individual digit in a base 10 number stores one of 10 unique
    values (0-9). To store a value larger than 9, the value must
    **carry** to an additional digit to the left. For example, if one
    digit starts at its maximum value (9) and we add 1 to it, the result
    requires two digits (9 + 1 = 10). The same pattern holds for any
    digit, regardless of its position within a number (e.g., 50**8**0 +
    **2**0 = 5**10**0).

2.  The position of each digit in the number determines how important
    that digit is to the overall value of the number. Labeling the
    digits from *right to left* as d~0~, d~1~, d~2~, etc., each
    successive digit contributes a factor of *ten* more than the next.
    For example, take the value 8425 ([Figure 1](#FigBaseTen)).
:::

::: {#FigBaseTen .imageblock .text-center}
::: content
![For the number 8425, digit 0 is the 5, which is in the \"ones place\".
Digit 1 is the 2, which is in the \"tens place\". Digit 2 is the 4, in
the \"hundreds place\". Finally, digit 3 is the 8, in the \"thousands
place\".](_images/BaseTen.png){width="680"}
:::

::: title
Figure 1. The importance of each digit in a base 10 number, using names
that you may have given to each digit in grade school.
:::
:::

::: paragraph
For the example value 8425, the 5 in the \"ones\" place contributes 5 (5
× 10^0^). The 2 in the \"tens\" place contributes 20 (2 × 10^1^). The 4
in the \"hundreds\" place contributes 400 (4 × 10^2^), and, finally, the
8 in the \"thousands\" place contributes 8000 (8 × 10^3^). More
formally, one could express 8425 as
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(8 × 10^3^)    +    (4 × 10^2^)    +    (2 × 10^1^)    +    (5 × 10^0^)
:::
:::
:::

::: paragraph
This pattern of increasing exponents applied to a base of 10 is the
reason why it's called a *base 10* number system. Assigning position
numbers to digits from right to left starting with d~0~ implies that
each digit d~i~ contributes 10^i^ to the overall value. Thus, the
overall value of any *N*-digit decimal number can be expressed as:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(d~N-1~ × 10^N-1^)    +    (d~N-2~ × 10^N-2^)    +    ...​    +    (d~2~
× 10^2^)    +    (d~1~ × 10^1^)    +    (d~0~ × 10^0^)
:::
:::
:::

::: paragraph
Fortunately, as we'll soon see, a very similar pattern applies to other
number systems.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Distinguishing Number Bases       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Now that we're about to introduce |
|                                   | a second number system, one       |
|                                   | potential problem is a lack of    |
|                                   | clarity regarding how to          |
|                                   | interpret a number. For example,  |
|                                   | consider the value 1000. It's not |
|                                   | immediately obvious whether you   |
|                                   | should interpret that number as a |
|                                   | decimal value (i.e., one          |
|                                   | thousand) or a binary value       |
|                                   | (i.e., eight, for reasons         |
|                                   | explained soon). To help clarify, |
|                                   | the remainder of this chapter     |
|                                   | will explicitly attach a prefix   |
|                                   | to all nondecimal numbers. We'll  |
|                                   | soon introduce binary, for which  |
|                                   | the prefix is **0b**, and         |
|                                   | hexadecimal, which uses a prefix  |
|                                   | of **0x**.                        |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Therefore, if you see 1000, you   |
|                                   | should assume it's a decimal      |
|                                   | \"one thousand\", and if you see  |
|                                   | 0b1000, you should interpret it   |
|                                   | as a binary number, in this case  |
|                                   | the value \"eight\".              |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect2
### [](#_unsigned_binary_numbers){.anchor}4.1.2. Unsigned Binary Numbers {#_unsigned_binary_numbers}

::: paragraph
While you may never have considered the specific formula describing
decimal numbers as powers of 10, the concept of { *ones*, *tens*,
*hundreds*, etc. } places should hopefully feel comfortable. Luckily,
similar terminology applies to other number systems, like binary. Of
course, the base is different in other number systems, so each digit
position contributes a different amount to its numerical value.
:::

::: paragraph
A **binary number system** uses a base of 2 instead of decimal's 10.
Analyzing it the same way that we just did for decimal reveals several
parallels (with 2 substituted for 10):
:::

::: {.olist .arabic}
1.  Any individual bit in a base 2 number stores one of two unique
    values (0 or 1). To store a value larger than 1, the binary encoding
    must **carry** to an additional bit to the left. For example, if one
    bit starts at its maximum value (1) and we add 1 to it, the result
    requires two bits (1 + 1 = 0b10). The same pattern holds for any
    bit, regardless of its position within a number (e.g.,
    0b100**1**00 + 0b**1**00 = 0b10**10**00).
:::

::: {.olist .arabic}
2.  The position of each bit in the number determines how important that
    bit is to the numerical value of the number. Labeling the digits
    from *right to left* as d~0~, d~1~, d~2~, etc., each successive bit
    contributes a factor of *two* more than the next.
:::

::: paragraph
The first point implies that counting in binary follows the same pattern
as decimal: by simply enumerating the values and adding digits (bits).
Because this section focuses on *unsigned* numbers (zero and positives
only), it's natural to start counting from zero. [Table
1](#TabBinaryCounting) shows how to count the first few natural numbers
in binary. As you can see from the table, counting in binary quickly
increases the number of digits. Intuitively, this growth makes sense,
since each binary digit (two possible values) represents less
information than a decimal digit (10 possible values).
:::

+-----------------------------------+-----------------------------------+
| Binary value                      | Decimal value                     |
+===================================+===================================+
| 0                                 | 0                                 |
+-----------------------------------+-----------------------------------+
| 1                                 | 1                                 |
+-----------------------------------+-----------------------------------+
| 10                                | 2                                 |
+-----------------------------------+-----------------------------------+
| 11                                | 3                                 |
+-----------------------------------+-----------------------------------+
| 100                               | 4                                 |
+-----------------------------------+-----------------------------------+
| 101                               | 5                                 |
+-----------------------------------+-----------------------------------+
| ...​                               | ...​                               |
+-----------------------------------+-----------------------------------+

: Table 1. A Comparison of Counting in Binary versus Decimal

::: paragraph
The second point about labeling digits looks really familiar! In fact,
it's so similar to decimal that it leads to a nearly identical formula
for interpreting a binary number. Simply replace the 10 at the base of
each exponent with a 2:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(d~N-1~ × 2^N-1^)    +    (d~N-2~ × 2^N-2^)    +    ...​    +    (d~2~ ×
2^2^)    +    (d~1~ × 2^1^)    +    (d~0~ × 2^0^)
:::
:::
:::

::: paragraph
Applying this formula yields the *unsigned* interpretation of any binary
number. For example, take 0b1000:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(1 × 2^3^)    +    (0 × 2^2^)    +    (0 × 2^1^)    +    (0 × 2^0^)
:::

::: {.paragraph .lead}
  =    8 + 0 + 0 + 0    =    8
:::
:::
:::

::: paragraph
Here's a longer one-byte example, 0b10110100:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(1 × 2^7^)    +    (0 × 2^6^)    +    (1 × 2^5^)    +    (1 × 2^4^)    +
   (0 × 2^3^)    +    (1 × 2^2^)    +    (0 × 2^1^)    +    (0 × 2^0^)
:::

::: {.paragraph .lead}
  =    128 + 0 + 32 + 16 + 0 + 4 + 0 + 0    =    180
:::
:::
:::
:::

::: sect2
### [](#_hexadecimal){.anchor}4.1.3. Hexadecimal {#_hexadecimal}

::: paragraph
Thus far, we've examined two number systems, decimal and binary. Decimal
is notable due to its comfort for humans, whereas binary matches the way
data is stored in hardware. It's important to note that they are
equivalent in their expressive power. That is, there's no number you can
represent in one system that you can't represent in the other. Given
their equivalence, it may surprise you that we're going to discuss one
more number system: the base 16 **hexadecimal** system.
:::

::: paragraph
With two perfectly good number systems, you may wonder why we need
another. The answer is primarily convenience. As shown in [Table
1](#TabBinaryCounting), binary bit sequences quickly grow to a large
number of digits. Humans tend to have a tough time making sense of long
sequences containing only 0's and 1's. And whereas decimal is more
compact, its base of 10 is a mismatch with binary's base 2.
:::

::: paragraph
Decimal doesn't easily capture the range that can be expressed using a
fixed number of bits. For example, suppose that an old computer uses
16-bit memory addresses. Its valid addresses range from
0b0000000000000000 to 0b1111111111111111. Represented in decimal, the
addresses range from 0 to 65535. Clearly, the decimal representations
are more compact than the long binary sequences, but unless you memorize
their conversions, it's more difficult to reason about the decimal
numbers. Both problems only get worse on modern devices, which use 32-
or 64-bit addresses!
:::

::: paragraph
These long bit sequences are where hexadecimal's base 16 shines. The
large base allows each digit to represent enough information for
hexadecimal numbers to be compact. Furthermore, because the base is
itself a power of two (2^4^ = 16), it's easy to map hexadecimal to
binary, and vice versa. For the sake of completeness, let's analyze
hexadecimal in the same way as decimal and binary:
:::

::: {.olist .arabic}
1.  Any individual digit in a base 16 number stores one of 16 unique
    values. Having more than 10 values presents a new challenge for
    hexadecimal --- traditional base 10 digits stop at a maximum value
    of 9. By convention, hexadecimal uses letters to represent values
    larger than 9, with A for 10, B for 11, up to F for 15. Like the
    other systems, to store a value larger than 15, the number must
    **carry** to an additional digit to the left. For example, if one
    digit starts at its maximum value (F) and we add 1 to it, the result
    requires two digits (0xF + 0x1 = 0x10; note that we use 0x to
    indicate hexadecimal numbers).

2.  The position of each digit in the number determines how important
    that digit is to the numerical value of the number. Labeling the
    digits from *right to left* as d~0~, d~1~, d~2~, etc., each
    successive digit contributes a factor of 16 more than the next.
:::

::: paragraph
Unsurprisingly, the same trusty formula for interpreting a number
applies to hexadecimal, with 16 as the base:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(d~N-1~ × 16^N-1^)    +    (d~N-2~ × 16^N-2^)    +    ...​    +    (d~2~
× 16^2^)    +    (d~1~ × 16^1^)    +    (d~0~ × 16^0^)
:::
:::
:::

::: paragraph
For example, to determine the decimal value of 0x23C8:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
        (2 × 16^3^)    +    (3 × 16^2^)    +    (C × 16^1^)    +    (8 ×
16^0^)
:::

::: {.paragraph .lead}
  =    (2 × 16^3^)    +    (3 × 16^2^)    +    (12 × 16^1^)    +    (8 ×
16^0^)
:::

::: {.paragraph .lead}
  =    (2 × 4096)    +    (3 × 256)    +    (12 × 16)    +    (8 × 1)
:::

::: {.paragraph .lead}
  =    8192 + 768 + 192 + 8    =    9160
:::
:::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Hexadecimal Misconception         |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | You may not encounter hexadecimal |
|                                   | numbers frequently as you're      |
|                                   | first learning about systems      |
|                                   | programming. In fact, the only    |
|                                   | context where you're likely to    |
|                                   | find them is in representing      |
|                                   | memory addresses. For example, if |
|                                   | you print the address of a        |
|                                   | variable using the `%p` (pointer) |
|                                   | format code for `printf`, you'll  |
|                                   | get hexadecimal output.           |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Many students often begin to      |
|                                   | equate memory addresses (e.g., C  |
|                                   | pointer variables) with           |
|                                   | hexadecimal. While you may get    |
|                                   | used to seeing addresses          |
|                                   | represented that way, keep in     |
|                                   | mind that *they are still stored  |
|                                   | using binary in the hardware*,    |
|                                   | just like all other data!         |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect2
### [](#_storage_limitations){.anchor}4.1.4. Storage Limitations {#_storage_limitations}

::: paragraph
Conceptually, there are infinitely many unsigned integers. In practice,
a programmer must choose how many bits to dedicate to a variable *prior
to storing it*, for a variety of reasons:
:::

::: ulist
-   Before storing a value, a program must allocate storage space for
    it. In C, declaring a variable tells the compiler [how much
    memory](../C1-C_intro/getting_started.html#_c_numeric_types){.page}
    it needs based on its type.

-   Hardware storage devices have finite capacity. Whereas a system's
    main memory is typically large and unlikely to be a limiting factor,
    storage locations inside the CPU that are used as temporary
    \"scratch space\" (i.e.,
    [registers](../C5-Arch/storagecircs.html#_cpu_register){.page}) are
    more constrained. A CPU uses registers that are limited to its word
    size (typically 32 or 64 bits, depending on the CPU architecture).

-   Programs often move data from one storage device to another (e.g.,
    between CPU registers and main memory). As values get larger,
    storage devices need more wires to communicate signals between them.
    Hence, expanding storage increases the complexity of the hardware
    and leaves less physical space for other components.
:::

::: paragraph
The number of bits used to store an integer dictates the range of its
representable values. [Figure 2](#FigUnsignedLine) depicts how we might
conceptualize infinite and finite unsigned integer storage spaces.
:::

::: {#FigUnsignedLine .imageblock .text-center}
::: content
![The infinite unsigned number line starts at zero and increases
infinitely. The finite unsigned number line starts at 0 and ends at a
maximum value. Attempting to move off one end wraps around to the
other.](_images/UnsignedLine.png){width="700"}
:::

::: title
Figure 2. Illustrations of (a) an infinite unsigned number line and (b)
a finite unsigned number line. The latter \"wraps around\" at either
endpoint (overflow).
:::
:::

::: paragraph
Attempting to store a larger value to a variable than the variable's
size allows is known as **integer overflow**. This chapter defers the
details of overflow to a [later
section](overflow.html#_integer_overflow){.page}. For now, think of it
like a car's odometer that \"rolls over\" back to zero if it attempts to
increase beyond its maximum value. Similarly, subtracting one from zero
yields the maximum value.
:::

::: paragraph
At this point, a natural question to ask about unsigned binary is
\"*What's the largest positive value that N bits can store?*\" In other
words, given a sequence of *N* bits that are all 1, what value does the
sequence represent? Reasoning about this question informally, the
analysis in the [previous
section](index.html#_binary_and_data_representation){.page} shows that
*N* bits yield 2^N^ unique bit sequences. Since one of those sequences
must represent the number 0, that leaves 2^N^ - 1 positive values
ranging from 1 to 2^N^ - 1. Thus, the maximum value for an unsigned
binary number of *N* bits must be 2^N^ - 1.
:::

::: paragraph
For example, 8 bits provide 2^8^ = 256 unique sequences. One of those
sequences, 0b00000000, is reserved for 0, leaving 255 sequences for
storing positive values. Therefore, an 8-bit variable represents the
positive values 1 through 255, the largest of which is 255.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
