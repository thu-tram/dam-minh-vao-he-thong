
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.3. Signed Binary Integers](signed.html)
:::

::: content
::: sect1
## [](#_signed_binary_integers){.anchor}4.3. Signed Binary Integers {#_signed_binary_integers}

::: sectionbody
::: paragraph
So far, we've limited the discussion of binary numbers to *unsigned*
(strictly non-negative) integers. This section presents an alternative
interpretation of binary that incorporates negative numbers. Given that
a variable has finite storage space, a signed binary encoding must
distinguish between negative values, zero, and positive values.
Manipulating signed numbers additionally requires a procedure for
negating a number.
:::

::: paragraph
A signed binary encoding must divide bit sequences between negative and
non-negative values. In practice, systems designers build
*general-purpose* systems, so a 50% / 50% split is a good
middle-of-the-road choice. Therefore, the signed number encodings that
this chapter presents represent an equal number of negative and
non-negative values.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Non-Negative versus Positive      |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Note that there's a subtle but    |
|                                   | important difference between      |
|                                   | *non-negative* and *positive*.    |
|                                   | The set of strictly positive      |
|                                   | values excludes zero, whereas the |
|                                   | non-negative set includes zero.   |
|                                   | Even after dividing the available |
|                                   | bit sequences 50% / 50% between   |
|                                   | negative and non-negative values, |
|                                   | one of the non-negative values    |
|                                   | must still be reserved for zero.  |
|                                   | Thus, with a fixed number of      |
|                                   | bits, a number system may end up  |
|                                   | representing more negative values |
|                                   | than positive values (e.g., in    |
|                                   | the two's complement system).     |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
Signed number encodings use one bit to distinguish between the sets of
*negative* numbers and *non-negative* numbers. By convention, the
left-most bit indicates whether a number is negative (1) or non-negative
(0). This leftmost bit is known as the **high-order bit** or the **most
significant bit**.
:::

::: paragraph
This chapter presents two potential signed binary encodings --- *signed
magnitude* and *two's complement*. Even though only one of these
encodings (two's complement) is still used in practice, comparing them
will help to illustrate their important characteristics.
:::

::: sect2
### [](#_signed_magnitude){.anchor}4.3.1. Signed Magnitude {#_signed_magnitude}

::: paragraph
The **signed magnitude** representation treats the high-order bit
exclusively as a sign bit. That is, whether the high-order bit is a 0 or
a 1 does not affect the absolute value of the number, it *only*
determines whether the value is positive (high-order bit 0) or negative
(high-order bit 1). Compared to two's complement, signed magnitude makes
the decimal conversion and negation procedures relatively
straightforward:
:::

::: ulist
-   To compute a decimal value for an *N*-bit signed magnitude sequence,
    compute the value of digits d~0~ through d~N-2~ using the familiar
    [unsigned method](bases.html#_unsigned_binary_numbers){.page}. Then,
    check the most significant bit, d~N-1~: if it's 1, the value is
    negative; otherwise it isn't.

-   To negate a value, simply flip the most significant bit to change
    its sign.
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Negation Misconception            |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Signed magnitude is presented     |
|                                   | purely for pedagogical purposes.  |
|                                   | Although it was used by some      |
|                                   | machines in the past (e.g.,       |
|                                   | [IBM's                            |
|                                   | 7090](https:                      |
|                                   | //en.wikipedia.org/wiki/IBM_7090) |
|                                   | in the 1960s), no modern systems  |
|                                   | use signed magnitude to represent |
|                                   | integers (although a similar      |
|                                   | mechanism *is* part of the        |
|                                   | standard for storing              |
|                                   | [floating-point                   |
|                                   | values](https                     |
|                                   | ://en.wikipedia.org/wiki/Single-p |
|                                   | recision_floating-point_format)). |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Unless you're explicitly asked to |
|                                   | consider signed magnitude, you    |
|                                   | should *not* assume that flipping |
|                                   | the first bit of a binary number  |
|                                   | will negate that number's value   |
|                                   | on a modern system.               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::

::: paragraph
[Figure 1](#FigSignedMagnitude) shows how four-bit signed magnitude
sequences correspond to decimal values. At first glance, signed
magnitude might seem attractive due to its simplicity. Unfortunately, it
suffers from two major drawbacks that make it unappealing. The first is
that it presents *two* representations of zero. For example, with four
bits, signed magnitude represents both *zero* (0b0000) and *negative
zero* (0b1000). Consequently, it poses a challenge to hardware designers
because the hardware will need to account for two possible binary
sequences that are numerically equal despite having different bit
values. The hardware designer's job is much easier with just one way of
representing such an important number.
:::

::: {#FigSignedMagnitude .imageblock .text-center}
::: content
![A circle with non-negative values on one side ranging from 0b0000 (0)
to 0b0111 (7). The other side holds 0b1000 (-0) to 0b1111
(-7).](_images/SignedMagnitude.png){width="680"}
:::

::: title
Figure 1. A logical layout of signed magnitude values for bit sequences
of length four.
:::
:::

::: paragraph
The other drawback of signed magnitude is that it exhibits an
inconvenient discontinuity between negative values and zero. While we'll
cover [overflow](overflow.html#_integer_overflow){.page} in more detail
later, adding 1 to the four-bit sequence 0b1111 \"rolls over\" back to
0b0000. With signed magnitude, this effect means 0b1111 (-7) + 1 might
be mistaken for 0 rather than the expected -6. This problem is solvable,
but the solution again complicates the design of the hardware,
essentially turning any transition between negative and non-negative
integers into a special case that requires extra care.
:::

::: paragraph
For these reasons, signed magnitude has largely disappeared in practice,
and two's complement reigns supreme.
:::
:::

::: sect2
### [](#_twos_complement){.anchor}4.3.2. Two's Complement {#_twos_complement}

::: paragraph
**Two's complement** encoding solves signed magnitude's problems in an
elegant way. Like signed magnitude, the high-order bit of a two's
complement number indicates whether or not the value should be
interpreted as negative. In contrast though, the high-order bit also
affects the value of the number. So, how can it do both?
:::

::: paragraph
Computing a decimal value for an *N*-bit two's complement number is
similar to the familiar [unsigned
method](bases.html#_unsigned_binary_numbers){.page}, except the
high-order bit's contribution to the overall value is negated. That is,
for an *N*-bit two's complement sequence, instead of the first bit
contributing d~N-1~ × 2^N-1^ to the sum, it contributes **-d~N-1~** ×
2^N-1^ (note the negative sign). Therefore, if the most significant bit
is a 1, the overall value will be negative because that first bit
contributes the largest absolute value to the sum. Otherwise, the first
bit contributes nothing to the sum, and the result is non-negative. The
full formula is:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
**-** (d~N-1~ × 2^N-1^)    +    (d~N-2~ × 2^N-2^)    +    ...​    +   
(d~2~ × 2^2^)    +    (d~1~ × 2^1^)    +    (d~0~ × 2^0^)
:::

::: paragraph
\^ note the leading negative sign for just the first term!
:::
:::
:::

::: paragraph
[Figure 2](#FigTwosComplement) illustrates the layout of four-bit
sequences in two's complement. This definition encodes just one
representation of zero --- a sequence of bits that are all 0's. With
only a single *zero* sequence, two's complement represents one more
negative value than positive. Using four-bit sequences as an example,
two's complement represents a minimum value of 0b1000 (-8), but a
maximum value of only 0b0111 (7). Fortunately, this quirk doesn't hinder
hardware design and rarely causes problems for applications.
:::

::: {#FigTwosComplement .imageblock .text-center}
::: content
![A circle with non-negative values on one side ranging from 0b0000 (0)
to 0b0111 (7). The other side holds 0b1111 (-1) to 0b1000
(-8).](_images/TwosComplement.png){width="680"}
:::

::: title
Figure 2. A logical layout of two's complement values for bit sequences
of length four.
:::
:::

::: paragraph
Compared to signed magnitude, two's complement also simplifies the
transition between negative numbers and zero. Regardless of the number
of bits used to store it, a two's complement number consisting of all
ones will always hold the value -1. Adding 1 to a bit sequence of all
1's \"rolls over\" to zero, which makes two's complement convenient,
since -1 + 1 *should* produce zero.
:::

::: sect3
#### [](#_negation){.anchor}Negation {#_negation}

::: paragraph
Negating a two's complement number is slightly trickier than negating a
signed magnitude value. To negate an *N*-bit value, determine its
**complement** with respect to 2^N^ (this is where the encoding's name
comes from). In other words, to negate an *N*-bit value *X*, find a bit
sequence *Y* (*X*\'s complement) such that *X* + *Y* = 2^N^.
:::

::: paragraph
Fortunately, there's a quick shortcut for negating a two's complement
number in practice: flip all the bits and add one. For example, to
negate the eight-bit value 13, first [determine the binary value of
13](conversion.html#_converting_from_decimal){.page}. Because 13 is the
sum of 8, 4, and 1, set the bits in positions 3, 2, and 0:
:::

::: listingblock
::: content
    00001101  (decimal 13)
:::
:::

::: paragraph
Next, \"flip the bits\" (change all zeros to ones, and vice versa):
:::

::: listingblock
::: content
    11110010
:::
:::

::: paragraph
Finally, adding one yields 0b11110011. Sure enough, applying the formula
for interpreting a two's complement bit sequence shows that the value is
-13:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
-(1 × 2^7^)    +    (1 × 2^6^)    +    (1 × 2^5^)    +    (1 × 2^4^)
   +    (0 × 2^3^)    +    (0 × 2^2^)    +    (1 × 2^1^)    +    (1 ×
2^0^)
:::

::: {.paragraph .lead}
  =    -128 + 64 + 32 + 16 + 0 + 0 + 2 + 1    =    -13
:::
:::
:::

::: paragraph
If you're curious as to why this seemingly magical shortcut works,
consider the eight-bit negation of 13 more formally. To find 13's
complement, solve 0b00001101 (13) + *Y* = 0b100000000 (2^8^, which
requires an extra bit to represent). The equation can be rearranged as
*Y* = 0b100000000 - 0b00001101. This is clearly now a subtraction
problem:
:::

::: listingblock
::: content
     100000000  (256)
    - 00001101   (13)
:::
:::

::: paragraph
While such a subtraction might seem daunting, we can express it in a way
that's easier to compute as (0b011111111 + 1) - 0b00001101. Note that
this change simply expresses 2^8^ (256) as (255 + 1). After that change,
the arithmetic looks like:
:::

::: listingblock
::: content
     011111111  (255)  + 00000001  (1)
    - 00001101   (13)
:::
:::

::: paragraph
As it turns out, for *any* bit value *b*, 1 - *b* is equivalent to
\"flipping\" that bit. Thus, the entire subtraction in the preceding
example can be reduced to just flipping all the bits of the lower
number. All that's left is to add the remaining +1 from expressing 256
as 255 + 1. Putting it all together, we can simply flip a value's bits
and add one to compute its complement!
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | C Programming With Signed versus  |
|                                   | Unsigned Integers                 |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In addition to allocating space,  |
|                                   | declaring variables in C also     |
|                                   | tells the compiler how you'd like |
|                                   | the variable to be interpreted.   |
|                                   | When you declare an `int`, the    |
|                                   | compiler interprets the variable  |
|                                   | as a signed two's complement      |
|                                   | integer. To allocate an unsigned  |
|                                   | value, declare an `unsigned int`. |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The distinction is also relevant  |
|                                   | to C in other places, like the    |
|                                   | `printf` function. As this        |
|                                   | chapter has been stressing        |
|                                   | throughout, a bit sequence can be |
|                                   | interpreted in different ways!    |
|                                   | With `printf`, the interpretation |
|                                   | depends on the formatting         |
|                                   | placeholder you use. For example: |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main(void) {                  |
|                                   |     int example = -100;           |
|                                   |                                   |
|                                   |     /*                            |
|                                   |  Print example int using both sig |
|                                   | ned and unsigned placeholders. */ |
|                                   |     prin                          |
|                                   | tf("%d  %u\n", example, example); |
|                                   |                                   |
|                                   |     return 0;                     |
|                                   | }                                 |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Even though this code passes      |
|                                   | `printf` the same variable        |
|                                   | (`example`) twice, it prints      |
|                                   | `-100  4294967196`. Be careful to |
|                                   | interpret your values correctly!  |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect3
#### [](#_sign_extension){.anchor}Sign Extension {#_sign_extension}

::: paragraph
Occasionally, you may find yourself wanting to perform an arithmetic
operation on two numbers that are stored using different numbers of
bits. For example, in C you may want to add a 32-bit `int` and a 16-bit
`short`. In such cases, the smaller number needs to be **sign
extended**, which is a fancy way of saying that its most significant bit
gets repeated as many times as necessary to extend the length of the bit
sequence to the target length. Though the compiler will take care of
wrangling the bits for you in C, it's still helpful to understand how
the process works.
:::

::: paragraph
For example, to extend the four-bit sequence 0b0110 (6) to an eight-bit
sequence, take the high-order bit (0) and prepend it four times to
produce the extended value: 0b**0000**0110 (still 6). Extending 0b1011
(-5) to an eight-bit sequence similarly takes the high-order bit (this
time, 1) and prepends it four times to the resulting extended value:
0b**1111**1011 (still -5). To verify the correctness, consider how the
value changes after adding each new bit:
:::

::: listingblock
::: content
        0b1011 =                       -8 + 0 + 2 + 1  =  -5
       0b11011 =                  -16 + 8 + 0 + 2 + 1  =  -5
      0b111011 =             -32 + 16 + 8 + 0 + 2 + 1  =  -5
     0b1111011 =        -64 + 32 + 16 + 8 + 0 + 2 + 1  =  -5
    0b11111011 =  -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1  =  -5
:::
:::

::: paragraph
As evidenced by the examples, numbers that are non-negative (high-order
bit of zero) remain non-negative after adding zeros to the front.
Likewise, negatives (high-order bit of one) remain negative after
prepending ones to extended values.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Unsigned Zero Extension           |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | For an unsigned value (e.g., a C  |
|                                   | variable explicitly declared with |
|                                   | an `unsigned` qualifier),         |
|                                   | extending it to a longer bit      |
|                                   | sequence instead requires **zero  |
|                                   | extension**, since the `unsigned` |
|                                   | qualifier prevents the value from |
|                                   | ever being interpreted as         |
|                                   | negative. Zero extension simply   |
|                                   | prepends zeros to the high-order  |
|                                   | bits of the extended bit          |
|                                   | sequence. For example, 0b1110 (14 |
|                                   | when interpreted as unsigned!)    |
|                                   | extends to 0b**0000**1110 despite |
|                                   | the original leading 1.           |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
