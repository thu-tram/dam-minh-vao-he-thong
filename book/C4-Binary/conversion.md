
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.2. Converting Between Bases](conversion.html)
:::

::: content
::: sect1
## [](#_converting_between_bases){.anchor}4.2. Converting Between Bases {#_converting_between_bases}

::: sectionbody
::: paragraph
You're likely to encounter each of the three number bases we've
introduced in this chapter in different contexts. In some cases, you may
need to convert from one base to another. This section starts by showing
how to convert between binary and hexadecimal, since those two map
easily to each other. After that, we'll explore conversions to and from
decimal.
:::

::: sect2
### [](#_converting_between_binary_and_hexadecimal){.anchor}4.2.1. Converting Between Binary and Hexadecimal {#_converting_between_binary_and_hexadecimal}

::: paragraph
Because the bases for both binary and hexadecimal are powers of 2,
converting between the two is relatively straightforward. Specifically,
each hexadecimal digit holds one of 16 unique values, and four bits also
represents 2^4^ = 16 unique values, making their expressive power
equivalent. [Table 1](#TabHexBinary) enumerates the one-to-one mapping
between any sequence of four bits and any single hexadecimal digit.
:::

+----------------+----------------+---+----------------+----------------+
| Binary         | Hexadecimal    |   | Binary         | Hexadecimal    |
+================+================+===+================+================+
| 0000           | 0              |   | 1000           | 8              |
+----------------+----------------+---+----------------+----------------+
| 0001           | 1              |   | 1001           | 9              |
+----------------+----------------+---+----------------+----------------+
| 0010           | 2              |   | 1010           | A              |
+----------------+----------------+---+----------------+----------------+
| 0011           | 3              |   | 1011           | B              |
+----------------+----------------+---+----------------+----------------+
| 0100           | 4              |   | 1100           | C              |
+----------------+----------------+---+----------------+----------------+
| 0101           | 5              |   | 1101           | D              |
+----------------+----------------+---+----------------+----------------+
| 0110           | 6              |   | 1110           | E              |
+----------------+----------------+---+----------------+----------------+
| 0111           | 7              |   | 1111           | F              |
+----------------+----------------+---+----------------+----------------+

: Table 1. The Correspondence Between All Four-Bit Sequences and
One-Digit Hexadecimal Numbers

::: paragraph
Note that the content of [Table 1](#TabHexBinary) is equivalent to
simply counting from 0 to 15 in both number systems, so there's no need
to memorize it. Armed with this mapping, you can convert any number of
consecutive bits or hex digits in either direction:
:::

::: ulist
-   Converting 0xB491 to binary, simply substitute the corresponding
    binary value for each hexadecimal digit:

    ::: listingblock
    ::: content
          B    4    9    1
        1011 0100 1001 0001  ->  0b1011010010010001
    :::
    :::

-   Converting 0b1111011001 to hexadecimal, first divide up the bits
    into chunks of four, from *right to left*. If the leftmost chunk
    doesn't have four bits, you can pad with leading zeros. Then,
    substitute the corresponding hexadecimal values:

    ::: listingblock
    ::: content
        1111011001  ->  11 1101 1001  ->  0011 1101 1001
                                          ^ padding

        0011 1101 1001
          3    D    9  ->  0x3D9
    :::
    :::
:::
:::

::: sect2
### [](#_converting_to_decimal){.anchor}4.2.2. Converting to Decimal {#_converting_to_decimal}

::: paragraph
Fortunately, converting values to decimal is what we've been doing
throughout [previous sections of this
chapter](bases.html#_unsigned_binary_numbers){.page}. Given a number in
*any* base **B**, labeling the digits from *right to left* as d~0~,
d~1~, d~2~, etc. enables a general formula for converting values to
decimal:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(d~N-1~ × **B**^N-1^)    +    (d~N-2~ × **B**^N-2^)    +    ...​    +   
(d~2~ × **B**^2^)    +    (d~1~ × **B**^1^)    +    (d~0~ × **B**^0^)
:::
:::
:::
:::

::: sect2
### [](#_converting_from_decimal){.anchor}4.2.3. Converting from Decimal {#_converting_from_decimal}

::: paragraph
Converting from decimal to other systems requires a little more work.
Informally, the goal is to do the reverse of the previous formula:
determine the value of each digit such that, based on the position of
the digit, adding each term results in the source decimal number. It may
help to think about each digit in the target base system in the same way
that we described the places (the \"ones\" place, the \"tens\" place,
etc.) for decimal. For example, consider converting from decimal to
hexadecimal. Each digit of a hexadecimal number corresponds to an
increasingly large power of 16, and [Table 2](#TabPowersSixteen) lists
the first few powers.
:::

  16^4^   16^3^   16^2^   16^1^   16^0^
  ------- ------- ------- ------- -------
  65536   4096    256     16      1

  : Table 2. Powers of 16.

::: paragraph
For example, to convert **9742** to hexadecimal, consider:
:::

::: ulist
-   *How many multiples of 65536 fit into 9742? (In other words, what is
    the value of the \"65536's\" place?)*

    ::: paragraph
    The resulting hexadecimal value doesn't need any multiples of 65536,
    since the value (9742) is smaller than 65536, so d~4~ should be set
    to 0. Note that by the same logic, all higher-numbered digits will
    also be 0, because each digit would contribute values even larger
    than 65536. Thus far, the result contains only:
    :::

      ------ ------ ------ ------ ------
      0                           
      d~4~   d~3~   d~2~   d~1~   d~0~
      ------ ------ ------ ------ ------

-   *How many multiples of 4096 fit into 9742? (In other words, what is
    the value of the \"4096's\" place?)*

    ::: paragraph
    4096 fits into 9742 twice (2 × 4096 = 8192), so the value of d~3~
    should be 2. Thus, d~3~ will contribute 8192 to the overall value,
    so the result must still account for 9742 - 8192 = 1550.
    :::

      ------ ------ ------ ------ ------
      0      2                    
      d~4~   d~3~   d~2~   d~1~   d~0~
      ------ ------ ------ ------ ------

-   *How many multiples of 256 fit into 1550? (In other words, what is
    the value of the \"256's\" place?)*

    ::: paragraph
    256 fits into 1550 six times (6 × 256 = 1536), so the value of d~2~
    should be 6, leaving 1550 - 1536 = 14.
    :::

      ------ ------ ------ ------ ------
      0      2      6             
      d~4~   d~3~   d~2~   d~1~   d~0~
      ------ ------ ------ ------ ------

-   *How many multiples of 16 fit into 14? (In other words, what is the
    value of the \"sixteens\" place?)*

    ::: paragraph
    None, so d~1~ must be 0.
    :::

      ------ ------ ------ ------ ------
      0      2      6      0      
      d~4~   d~3~   d~2~   d~1~   d~0~
      ------ ------ ------ ------ ------

-   *Finally, how many multiples of 1 fit into 14? (In other words, what
    is the value of the \"ones\" place?)*

    ::: paragraph
    The answer is 14, of course, which hexadecimal represents with the
    digit `E`.
    :::

      ------ ------ ------ ------ ------
      0      2      6      0      E
      d~4~   d~3~   d~2~   d~1~   d~0~
      ------ ------ ------ ------ ------
:::

::: paragraph
Thus, decimal 9742 corresponds to 0x260E.
:::

::: sect3
#### [](#_decimal_to_binary_powers_of_two){.anchor}Decimal to Binary: Powers of Two {#_decimal_to_binary_powers_of_two}

::: paragraph
The same procedure works for binary, as well (or any other number
system), provided that you use powers of the appropriate base. [Table
3](#TabPowersTwo) lists the first few powers of two, which will help to
convert the example decimal value **422** to binary.
:::

  2^8^   2^7^   2^6^   2^5^   2^4^   2^3^   2^2^   2^1^   2^0^
  ------ ------ ------ ------ ------ ------ ------ ------ ------
  256    128    64     32     16     8      4      2      1

  : Table 3. Powers of Two

::: paragraph
Because an individual bit is only allowed to store a 0 or 1, the
question is no longer *\"How many multiples of each power fit within a
value?\"* when converting to binary. Instead, ask a simpler question:
*\"Does the next power of two fit?\"* For example, in converting 422:
:::

::: ulist
-   256 fits into 422, so d~8~ should be a 1. That leaves 422 - 256 =
    166.

-   128 fits into 166, so d~7~ should be a 1. That leaves 166 - 128 =
    38.

-   64 does not fit into 38, so d~6~ should be a 0.

-   32 fits into 38, so d~5~ should be a 1. That leaves 38 - 32 = 6.

-   16 does not fit into 6, so d~4~ should be a 0.

-   8 does not fit into 6, so d~3~ should be a 0.

-   4 fits into 6, so d~2~ should be a 1. That leaves 6 - 4 = 2.

-   2 fits into 2, so d~1~ should be a 1. That leaves 2 - 2 = 0. (Note:
    upon reaching 0, all remaining digits will always be 0.)

-   1 does not fit into 0, so d~0~ should be a 0.
:::

::: paragraph
Thus, decimal 422 corresponds to 0b110100110.
:::
:::

::: sect3
#### [](#_decimal_to_binary_repeated_division){.anchor}Decimal to Binary: Repeated Division {#_decimal_to_binary_repeated_division}

::: paragraph
The method we just described generally works well for students who are
familiar with the relevant powers of two (e.g., for 422, the converter
must recognize that it should start at d~8~ because 2^9^ = 512 is too
large).
:::

::: paragraph
An alternative method doesn't require knowing powers of two. Instead,
this method builds a binary result by checking the parity (even or odd)
status of a decimal number and repeatedly dividing it by two (rounding
halves down) to determine each successive bit. Note that it builds the
resulting bit sequence from *right to left*. If the decimal value is
even, the next bit should be a zero; if it's odd, the next bit should be
a one. When the division reaches zero, the conversion is complete.
:::

::: paragraph
For example, when converting 422:
:::

::: ulist
-   422 is even, so d~0~ should be a 0. (This is the rightmost bit.)

-   422 / 2 = 211, which is odd, so d~1~ should be a 1.

-   211 / 2 = 105, which is odd, so d~2~ should be a 1.

-   105 / 2 = 52, which is even, so d~3~ should be a 0.

-   52 / 2 = 26, which is even, so d~4~ should be a 0.

-   26 / 2 = 13, which is odd, so d~5~ should be a 1.

-   13 / 2 = 6, which is even, so d~6~ should be a 0.

-   6 / 2 = 3, which is odd, so d~7~ should be a 1.

-   3 / 2 = 1, which is odd, so d~8~ should be a 1.

-   1 / 2 = 0, so any digit numbered nine or above will be 0, and the
    algorithm terminates.
:::

::: paragraph
As expected, this method produces the same binary sequence: 0b110100110.
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
