
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.6. Bitwise Operators](bitwise.html)
:::

::: content
::: sect1
## [](#_bitwise_operators){.anchor}4.6. Bitwise Operators {#_bitwise_operators}

::: sectionbody
::: paragraph
In addition to the standard arithmetic operations described earlier,
CPUs also support operations that are uncommon outside of binary. These
**bitwise operators** directly apply the behavior of [logic
gates](../C5-Arch/gates.html#_basic_logic_gates){.page} to bit
sequences, making them straightforward to implement efficiently in
hardware. Unlike addition and subtraction, which programmers typically
use to manipulate a variable's numerical interpretation, programmers
commonly use bitwise operators to modify specific bits in a variable.
For example, a program might encode a certain bit position in a variable
to hold a true/false meaning, and bitwise operations allow the program
to manipulate the variable's individual bits to change that specific
bit.
:::

::: sect2
### [](#_bitwise_and){.anchor}4.6.1. Bitwise AND {#_bitwise_and}

::: paragraph
The bitwise AND operator (`&`) evaluates two input bit sequences. For
each digit of the inputs, it outputs a 1 in the corresponding position
of the output if *both* inputs are 1 in that position. Otherwise, it
outputs a 0 for the digit. [Table 1](#TabANDTruth) shows the truth table
for the bitwise AND of two values, *A* and *B*.
:::

+-----------------+-----------------+-----------------------------------+
| A               | B               | A & B                             |
+=================+=================+===================================+
| 0               | 0               | 0                                 |
+-----------------+-----------------+-----------------------------------+
| 0               | 1               | 0                                 |
+-----------------+-----------------+-----------------------------------+
| 1               | 0               | 0                                 |
+-----------------+-----------------+-----------------------------------+
| 1               | 1               | 1                                 |
+-----------------+-----------------+-----------------------------------+

: Table 1. The Results of Bitwise ANDing Two Values (*A* AND *B*)

::: paragraph
For example, to bitwise AND 0b011010 with 0b110110, start by lining up
the two sequences. Checking vertically through each digit, set the
result of the column to 1 if *both* digits are 1. Otherwise, set the
result of the column to 0:
:::

::: listingblock
::: content
            011010
        AND 110110  Only digits 1 and 4 are 1's in BOTH inputs, so
    Result: 010010  those are the only digits set to 1 in the output.
:::
:::

::: paragraph
To perform a bitwise AND in C, place C's bitwise AND operator (`&`)
between two operand variables. Here's the same example again, performed
in C:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x = 26;
int y = 54;

printf("Result: %d\n", x & y);  // Prints 18
```
:::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Bitwise Operations versus Logical |
|                                   | Truth Operations                  |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Be careful not to conflate        |
|                                   | bitwise operators with [logical   |
|                                   | truth                             |
|                                   | operat                            |
|                                   | ors](../C1-C_intro/conditionals.h |
|                                   | tml#_boolean_values_in_c){.page}. |
|                                   | Despite having similar names      |
|                                   | (AND, OR, NOT, etc.), the two     |
|                                   | *are not* the same:               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: ulist                         |
|                                   | -   Bitwise operators consider    |
|                                   |     each bit of their inputs      |
|                                   |     independently and produce an  |
|                                   |     output bit sequence as a      |
|                                   |     function of the specific      |
|                                   |     input bits that are set.      |
|                                   |                                   |
|                                   | -   Logical operators consider    |
|                                   |     only the *truth*              |
|                                   |     interpretation of their       |
|                                   |     operands. To C, a value of    |
|                                   |     zero is *false*, whereas all  |
|                                   |     other values are considered   |
|                                   |     *true*. Logical operators are |
|                                   |     often used when evaluating    |
|                                   |     conditionals (e.g., `if`      |
|                                   |     statements).                  |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Note that C often uses similar    |
|                                   | (but slightly different)          |
|                                   | operators to distinguish between  |
|                                   | the two. For example, you can     |
|                                   | indicate bitwise AND and bitwise  |
|                                   | OR using a single `&` and `|`,    |
|                                   | respectively. Logical AND and     |
|                                   | logical OR correspond to a double |
|                                   | `&&` and `||`. Finally, bitwise   |
|                                   | NOT uses `~`, whereas logical NOT |
|                                   | is expressed by `!`.              |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect2
### [](#_bitwise_or){.anchor}4.6.2. Bitwise OR {#_bitwise_or}

::: paragraph
The bitwise OR operator (`|`) behaves like the bitwise AND operator
except that it outputs a 1 for a digit if *either or both* of the inputs
is 1 in the corresponding position. Otherwise, it outputs a 0 for the
digit. [Table 2](#TabORTruth) shows the truth table for the bitwise OR
of two values, *A* and *B*.
:::

+-----------------+-----------------+-----------------------------------+
| A               | B               | A \| B                            |
+=================+=================+===================================+
| 0               | 0               | 0                                 |
+-----------------+-----------------+-----------------------------------+
| 0               | 1               | 1                                 |
+-----------------+-----------------+-----------------------------------+
| 1               | 0               | 1                                 |
+-----------------+-----------------+-----------------------------------+
| 1               | 1               | 1                                 |
+-----------------+-----------------+-----------------------------------+

: Table 2. The Results of Bitwise ORing Two Values (*A* OR *B*)

::: paragraph
For example, to bitwise OR 0b011010 with 0b110110, start by lining up
the two sequences. Checking vertically through each digit, set the
result of the column to 1 if *either* digit is 1:
:::

::: listingblock
::: content
            011010
         OR 110110     Only digit 0 contains a 0 in both inputs, so it's
    Result: 111110     the only digit not set to 1 in the result.
:::
:::

::: paragraph
To perform a bitwise OR in C, place C's bitwise OR operator (`|`)
between two operands. Here's the same example again, performed in C:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x = 26;
int y = 54;

printf("Result: %d\n", x | y);  // Prints 62
```
:::
:::
:::

::: sect2
### [](#_bitwise_xor_exclusive_or){.anchor}4.6.3. Bitwise XOR (Exclusive OR) {#_bitwise_xor_exclusive_or}

::: paragraph
The bitwise XOR operator (`^`) behaves like the bitwise OR operator
except that it outputs a 1 for a digit only if *exactly one* (but not
both) of the inputs is 1 in the corresponding position. Otherwise, it
outputs a 0 for the digit. [Table 3](#TabXORTruth) shows the truth table
for the bitwise XOR of two values, *A* and *B*.
:::

+-----------------+-----------------+-----------------------------------+
| A               | B               | A \^ B                            |
+=================+=================+===================================+
| 0               | 0               | 0                                 |
+-----------------+-----------------+-----------------------------------+
| 0               | 1               | 1                                 |
+-----------------+-----------------+-----------------------------------+
| 1               | 0               | 1                                 |
+-----------------+-----------------+-----------------------------------+
| 1               | 1               | 0                                 |
+-----------------+-----------------+-----------------------------------+

: Table 3. The Results of Bitwise XORing Two Values (*A* XOR *B*)

::: paragraph
For example, to bitwise XOR 0b011010 with 0b110110, start by lining up
the two sequences. Checking vertically through each digit, set the
result of the column to 1 if *only one* digit is 1:
:::

::: listingblock
::: content
            011010
        XOR 110110     Digits 2, 3, and 6 contain a 1 in exactly one of
    Result: 101100     the two inputs.
:::
:::

::: paragraph
To perform a bitwise XOR in C, place C's bitwise XOR operator (`^`)
between two operands. Here's the same example again, performed in C:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x = 26;
int y = 54;

printf("Result: %d\n", x ^ y);  // Prints 44
```
:::
:::
:::

::: sect2
### [](#_bitwise_not){.anchor}4.6.4. Bitwise NOT {#_bitwise_not}

::: paragraph
The bitwise NOT operator (`~`) operates on just one operand. For each
bit in the sequence, it simply flips the bit such that a zero becomes a
one or vice versa. [Table 4](#TabNOTTruth) shows the truth table for the
bitwise NOT operator.
:::

+-----------------------------------+-----------------------------------+
| A                                 | \~ A                              |
+===================================+===================================+
| 0                                 | 1                                 |
+-----------------------------------+-----------------------------------+
| 1                                 | 0                                 |
+-----------------------------------+-----------------------------------+

: Table 4. The Results of Bitwise NOTing a Value (*A*)

::: paragraph
For example, to bitwise NOT 0b011010, invert the value of each bit:
:::

::: listingblock
::: content
        NOT 011010
    Result: 100101
:::
:::

::: paragraph
To perform a bitwise NOT in C, place a tilde character (`~`) in front of
an operand. Here's the same example again, performed in C:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x = 26;

printf("Result: %d\n", ~x); // Prints -27
```
:::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Bitwise NOT vs. Negation          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Note that all modern systems      |
|                                   | represent integers using two's    |
|                                   | complement, so bitwise NOT isn't  |
|                                   | quite the same as negation.       |
|                                   | Bitwise NOT *only* flips the bits |
|                                   | and *doesn't* add one.            |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::

::: sect2
### [](#_bit_shifting){.anchor}4.6.5. Bit Shifting {#_bit_shifting}

::: paragraph
Another important bitwise operation involves shifting the position of an
operand's bits either to the left (`<<`) or to the right (`>>`). Both
the left and right shifting operators take two operands: the bit
sequence to shift and the number of places it should be shifted.
:::

::: sect3
#### [](#_shifting_left){.anchor}Shifting Left {#_shifting_left}

::: paragraph
Shifting a sequence to the left by *N* places moves each of its bits to
the left *N* times, appending new zeros to the right side of the
sequence. For example, shifting the eight-bit sequence 0b00101101 to the
left by two produces 0b101101**00**. The two zeros at the right are
appended to end of the sequence, since the result still needs to be an
eight-bit sequence.
:::

::: paragraph
In the absence of overflow, shifting to the left *increases* the value
of the result because bits move toward digits that contribute larger
powers of two to the value of the number. However, with a fixed number
of bits, any bits that shift into positions beyond the maximum capacity
of the number get truncated. For example, shifting the eight-bit
sequence 0b11110101 (unsigned interpretation 245) to the left by one
produces 0b1110101**0** (unsigned interpretation 234). Here, the
truncation of the high-order bit that shifted out makes the result
smaller.
:::

::: paragraph
To perform a left bit shift in C, place two less-than characters (`<<`)
between a value and the number of places to shift that value:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x = 13;  // 13 is 0b00001101

printf("Result: %d\n", x << 3);  // Prints 104 (0b01101000)
```
:::
:::
:::

::: sect3
#### [](#_shifting_right){.anchor}Shifting Right {#_shifting_right}

::: paragraph
Shifting to the right is similar to left shifting --- any bits that are
shifted out of a variable's capacity (e.g., off the end to the right)
disappear due to truncation. However, right shifting introduces an
additional consideration: the new bits prepended to the left side of the
result may need to be either all zeros or all ones depending on the
*type* of the variable being shifted and its high-order bit value.
Conceptually, the choice to prepend zeros or ones resembles that of
[sign extension](signed.html#_sign_extension){.page}. Thus, there exist
two distinct variants of right shifting:
:::

::: ulist
-   A **logical right shift** always prepends zeros to the high-order
    bits of the result. Logical shifting is used to shift *unsigned*
    variables, since a leading 1 in the most significant bit of an
    unsigned value isn't intended to mean that the value is negative.
    For example, shifting 0b10110011 to the right by two using a logical
    shift yields 0b**00**101100.

-   An **arithmetic right shift** prepends a copy of the shifted value's
    most significant bit into each of the new bit positions. Arithmetic
    shifting applies to *signed* variables, for which it's important to
    preserve the signedness of the high-order bits. For example,
    shifting 0b10110011 to the right by two using an arithmetic shift
    yields 0b**11**101100.
:::

::: paragraph
Fortunately, when programming in C, you don't typically need to worry
about the distinction if you've declared your variables properly. If
your program includes a right shift operator (`>>`), virtually every C
compiler will automatically perform the appropriate type of shifting
according to the type of the shifting variable. That is, if the shifting
variable was declared with the *unsigned* qualifier, the compiler will
perform a logical shift. Otherwise, it will perform an arithmetic shift.
:::

::: {.admonitionblock .note}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | C Right Shift Example Program     |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | You can test the behavior of      |
|                                   | right shifting with a small       |
|                                   | example program like this one:    |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main(int argc, char **argv) { |
|                                   |     /*                            |
|                                   | Unsigned integer value: u_val. */ |
|                                   |                                   |
|                                   |  unsigned int u_val = 0xFF000000; |
|                                   |                                   |
|                                   |     /                             |
|                                   | * Signed integer value: s_val. */ |
|                                   |     int s_val = 0xFF000000;       |
|                                   |                                   |
|                                   |     printf("%08X\n", u_va         |
|                                   | l >> 12);  // logical right shift |
|                                   |     printf("%08X\n", s_val >      |
|                                   | > 12);  // arithmetic right shift |
|                                   |                                   |
|                                   |     return 0;                     |
|                                   | }                                 |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | This program declares two 32-bit  |
|                                   | integers: one as an unsigned      |
|                                   | integer (`u_val`), and another as |
|                                   | a signed integer (`s_val`). It    |
|                                   | initializes both integers to the  |
|                                   | same starting value: a sequence   |
|                                   | of eight ones followed by 24      |
|                                   | zeros                             |
|                                   | (`0b1111                          |
|                                   | 111100000000000000000000000000`), |
|                                   | and then it shifts both values 12 |
|                                   | positions to the right. When      |
|                                   | executed, it prints:              |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   |     $ ./a.out                     |
|                                   |     000FF000                      |
|                                   |     FFFFF000                      |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Because a leading 1 doesn't       |
|                                   | indicate \"negative\" for the     |
|                                   | unsigned `u_val`, the compiler    |
|                                   | uses instructions to prepend it   |
|                                   | with only zeros. The shifted      |
|                                   | result contains 12 zeros, eight   |
|                                   | ones, and 12 more zeros           |
|                                   | (`0b00                            |
|                                   | 000000000011111111000000000000`). |
|                                   | On the other hand, the leading 1  |
|                                   | **does** indicate \"negative\"    |
|                                   | for `s_val`, so the compiler      |
|                                   | prepends 1's to the front of the  |
|                                   | shifted value, yielding 20 ones   |
|                                   | followed by 12 zeros              |
|                                   | (`0b11                            |
|                                   | 111111111111111111000000000000`). |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
