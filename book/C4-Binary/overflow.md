
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.5. Overflow](overflow.html)
:::

::: content
::: sect1
## [](#_integer_overflow){.anchor}4.5. Integer Overflow {#_integer_overflow}

::: sectionbody
::: paragraph
Although the number of integers is mathematically infinite, in practice,
numeric types in a computer's memory [occupy a fixed number of
bits](bases.html#_storage_limitations){.page}. As we've hinted
throughout this chapter, using a fixed number of bits implies that
programs might be unable to represent values that they'd like to store.
For example, the discussion of addition showed that adding two
legitimate values can produce [a result that can't be
represented](arithmetic_addition.html#carryout){.page}. A computation
that lacks the storage to represent its result has **overflowed**.
:::

::: sect2
### [](#_odometer_analogy){.anchor}4.5.1. Odometer Analogy {#_odometer_analogy}

::: paragraph
To characterize overflow, consider an example from the non-computing
world: a car's odometer. An odometer counts the number of miles a car
has driven, and whether it's digital or analog, it can display only so
many (base 10) digits. If the car drives more miles than the odometer
can represent, the odometer \"rolls over\" back to zero, since the true
value can't be expressed. For example, with a standard six-digit
odometer, the maximum value it represents is 999999. Driving just one
additional mile *should* display 1000000, but like the [overflowing
addition example](arithmetic_addition.html#carryout){.page}, the 1
carries out from the six available digits, leaving only 000000.
:::

::: paragraph
For simplicity, let's continue analyzing an odometer that's limited to
just one decimal digit. That is, the odometer represents the range \[0,
9\], so after every 10 miles the odometer resets back to zero.
Illustrating the odometer's range visually, it might look like [Figure
1](#FigBaseTenWheel).
:::

::: {#FigBaseTenWheel .imageblock .text-center}
::: content
![A circle with the values 0 to 9 arranged around
it.](_images/BaseTenWheel.png){width="330"}
:::

::: title
Figure 1. A visual depiction of a one-digit odometer's potential values
:::
:::

::: paragraph
Because a one-digit odometer rolls over upon reaching 10, drawing a
circular shape emphasizes the discontinuity at the top of the circle
(and *only* at the top). Specifically, by adding one to any value *other
than nine*, the result lands on the expected value. On the other hand,
adding one to nine jumps to a value that doesn't naturally follow it
(zero). More generally, when performing *any* arithmetic that crosses
the discontinuity between nine and zero, the computation will overflow.
For example, consider adding 8 + 4, as in [Figure
2](#FigBaseTenWheelAdding).
:::

::: {#FigBaseTenWheelAdding .imageblock .text-center}
::: content
![A circle with the values 0 to 9 arranged around it. The gap between 0
and 9 is labeled as the location where overflow can occur. Arrows show
that adding 4 to 8 causes the arithmetic to jump across the marked
overflow location.](_images/BaseTenWheelAdding.png){width="360"}
:::

::: title
Figure 2. The result of adding 8 + 4 with only one decimal digit.
Crossing the discontinuity between 0 and 9 indicates that an overflow
has occurred.
:::
:::

::: paragraph
Here, the sum yields 2 instead of the expected 12. Note that many other
values added to 8 (for example, 8 + 14) would also land on two, with the
only difference being that the computations would take additional trips
around the circle. Consequently, it doesn't matter whether the car
drives 2, 12, or 152 miles --- in the end, the odometer will read 2
regardless.
:::

::: paragraph
Any device that behaves like an odometer performs **modular
arithmetic**. In this case, all arithmetic is modular with respect to a
modulus of 10, since one decimal digit represents only 10 values.
Therefore, given any number of miles traveled, we can compute what the
odometer will read by dividing the distance by 10 and taking the
remainder as the result. If the odometer had two decimal digits instead
of one, the modulus would change to 100, since it could represent a
larger range of values: \[0, 99\]. Similarly, clocks perform modular
arithmetic with an hour modulus of 12.
:::
:::

::: sect2
### [](#_binary_integer_overflow){.anchor}4.5.2. Binary Integer Overflow {#_binary_integer_overflow}

::: paragraph
Having seen a familiar form of overflow, let's turn to binary number
encodings. Recall that *N* bits of storage represent 2^N^ unique bit
sequences and that those sequences can be interpreted in different ways
(as *unsigned* or *signed*). Some operations that yield correct results
under one interpretation may exhibit overflow according to the other, so
the hardware needs to recognize overflow differently for each.
:::

::: paragraph
For example, suppose that a machine is using four-bit sequences to
compute 0b0010 (2) - 0b0101 (5). Running this operation through the
[subtraction procedure](arithmetic_subtraction.html#_subtraction){.page}
produces a binary result of 0b1101. Interpreting this result as a
*signed* value produces -3 (-8 + 4 + 1), the expected result for 2 - 5
without overflow. Alternatively, interpreting it as an *unsigned* value
yields 13 (8 + 4 + 1), which is incorrect and clearly indicative of
overflow. Scrutinizing this example further, it instinctively makes some
sense --- the result should be negative, and a signed interpretation
allows for negatives, whereas unsigned does not.
:::

::: sect3
#### [](#_unsigned_overflow){.anchor}Unsigned Overflow {#_unsigned_overflow}

::: paragraph
*Unsigned* numbers behave similarly to the decimal odometer examples
given that both represent only non-negative values. *N* bits represent
unsigned values in the range \[0, 2^N^ - 1\], making all arithmetic
modular with respect to 2^N^. [Figure 3](#FigUnsignedWheel) illustrates
an arrangement of the unsigned interpretations of four-bit sequences
into a modular space.
:::

::: {#FigUnsignedWheel .imageblock .text-center}
::: content
![The numbers 0 to 15 are arranged in a circle. The gap between 15 and 0
(at the top of the circle) is labeled as the location where overflow can
occur.](_images/UnsignedWheel.png){width="680"}
:::

::: title
Figure 3. An arrangement of four-bit unsigned values into a modular
space. All arithmetic is modular with respect to 2^4^ (16).
:::
:::

::: paragraph
Given that unsigned interpretations can't hold negative values, the
discontinuity again sits between the maximum value and zero. Therefore,
unsigned overflow results from any operation that crosses the divide
between 2^N^-1 and 0. Stated more plainly, if performing addition (which
should make the result *larger*) produces a smaller result, the addition
caused unsigned overflow. Symmetrically, if performing subtraction
(which should make the result *smaller*) produces a larger result, the
subtraction caused unsigned overflow.
:::

::: paragraph
As a shortcut for detecting unsigned overflow for addition and
subtraction, recall the [carry
out](arithmetic_addition.html#carryout){.page} and [carry
in](arithmetic_subtraction.html#_subtraction){.page} bits of those
operations. A *carry out* is a carry from the most significant bit in
the result of the computation. When set, a *carry in* increments the
value of the result by carrying one into the least significant bit of
the arithmetic operation. The *carry in* is only set to 1 for
subtraction as part of the negation procedure.
:::

::: paragraph
The **shortcut for unsigned arithmetic** is: the carry out must match
the carry in, otherwise the operation causes overflow. Intuitively, this
shortcut works because:
:::

::: ulist
-   For addition (carry in = 0), the result should be larger than (or
    equal to) the first operand. However, if the sum requires an extra
    bit of storage (carry out = 1), truncating that extra bit from the
    sum yields a smaller result (overflow). For example, in the unsigned
    four-bit number space, adding 0b1100 (12) + 0b1101 (13) requires
    *five* bits to store the result 0b**1**1001 (25). When truncated to
    only four bits, the result represents 0b1001 (9), which is smaller
    than the operands (therefore, overflow).

-   For subtraction (carry in = 1), the result should be smaller than
    (or equal to) the first operand. Because subtraction executes as a
    combination of addition and negation, the addition subproblem should
    produce a smaller result. The only way addition can end up with a
    smaller value is by truncating its sum (carry out = 1). If it
    doesn't require truncation (carry out = 0), the subtraction yields a
    larger result (overflow).
:::

::: paragraph
Let's examine two examples of four-bit subtraction: one that overflows,
and one that doesn't. First, consider 0b0111 (7) - 0b1001 (9). The
subtraction procedure treats this computation as:
:::

+--------------+----------------------+-------------------------------+
| Problem      | Converted to         | Worked Example                |
| Setup        | Addition             |                               |
+==============+======================+===============================+
| ::: content  | ::: content          | ::: content                   |
| :::          | ::: listingblock     | ::: listingblock              |
| listingblock | ::: content          | ::: content                   |
| ::: content  |                      |                               |
|              |         1 (carry in) |                  1 (carry in) |
|       0111   |       0111           |                  0111         |
|     - 1001   |     +                |                               |
| :::          |  0110 (bits flipped) |         + 0110 (bits flipped) |
| :::          | :::                  |                               |
| :::          | :::                  |        Result:   1110         |
|              | :::                  |     Carry out:  0             |
|              |                      | :::                           |
|              |                      | :::                           |
|              |                      | :::                           |
+--------------+----------------------+-------------------------------+

::: paragraph
The computation *did not* carry out of d~3~, so no truncation occurs and
the carry in (1) fails to match the carry out (0). The result, 0b1110
(14), is larger than either operand and thus clearly incorrect for 7 - 9
(overflow).
:::

::: paragraph
Next, consider 0b0111 (7) - 0b0101 (5). The subtraction procedure treats
this computation as:
:::

+--------------+----------------------+-------------------------------+
| Problem      | Converted to         | Worked Example                |
| Setup        | Addition             |                               |
+==============+======================+===============================+
| ::: content  | ::: content          | ::: content                   |
| :::          | ::: listingblock     | ::: listingblock              |
| listingblock | ::: content          | ::: content                   |
| ::: content  |                      |                               |
|              |         1 (carry in) |                  1 (carry in) |
|       0111   |       0111           |                  0111         |
|     - 0101   |     +                |                               |
| :::          |  1010 (bits flipped) |         + 1010 (bits flipped) |
| :::          | :::                  |                               |
| :::          | :::                  |        Result:   0010         |
|              | :::                  |     Carry out:  1             |
|              |                      | :::                           |
|              |                      | :::                           |
|              |                      | :::                           |
+--------------+----------------------+-------------------------------+

::: paragraph
The computation carries out a bit to d~4~, causing the carry in (1) to
match the carry out (1). The truncated result, 0b0010 (2), correctly
represents the expected outcome of the subtraction operation (no
overflow).
:::
:::

::: sect3
#### [](#_signed_overflow){.anchor}Signed Overflow {#_signed_overflow}

::: paragraph
The same intuition behind overflow applies to *signed* binary
interpretations: there exists a discontinuity in the modular number
space. However, because a signed interpretation allows for negatives,
the discontinuity doesn't occur around 0. Recall that [two's
complement](signed.html#_twos_complement){.page} \"rolls over\" cleanly
from -1 (0b1111...​111) to 0 (0b0000...​000). Thus, the discontinuity
exists at the *other* end of the number space, where the largest
positive value and smallest negative value meet.
:::

::: paragraph
[Figure 4](#FigSignedWheel) shows an arrangement of the signed
interpretations of four-bit sequences into a modular space. Note that
half the values are negative, the other half are non-negative, and that
the discontinuity lies at the min/max divide between them.
:::

::: {#FigSignedWheel .imageblock .text-center}
::: content
![The numbers 0 to 7 are arranged on the right half of a circle, and the
numbers -1 to -8 are arranged on the left half. The gap between 7 and -8
(at the bottom of the circle) is labeled as the location where overflow
can occur.](_images/SignedWheel.png){width="680"}
:::

::: title
Figure 4. An arrangement of four-bit signed values into a modular space.
Because a signed interpretation allows for negative values, the
discontinuity no longer resides at zero.
:::
:::

::: paragraph
When performing signed arithmetic, it's always safe to generate a result
that moves closer to zero. That is, any operation that reduces the
absolute value of the result cannot overflow, because the overflow
discontinuity resides where the magnitude of the representable values is
the largest.
:::

::: paragraph
Consequently, systems detect overflow in signed addition and subtraction
by comparing the most significant bit of the operands with the most
significant bit of the result. For subtraction, first rearrange the
arithmetic in terms of addition (e.g., rewrite 5 - 2 as 5 + -2).
:::

::: ulist
-   If the addition's operands have *different* high-order bit values
    (i.e., one operand is negative and the other is positive), there can
    be no signed overflow, because the absolute value of the result must
    be smaller than (or equal to) either operand. The result is moving
    *toward* zero.

-   If the addition's operands have the *same* high-order bit value
    (i.e., both are positive or both are negative), a correct result
    must also have the same high-order bit value. Thus, when adding two
    operands with the same sign, a signed overflow occurs if the
    result's sign differs from that of the operands.
:::

::: paragraph
Consider the following four-bit signed binary examples:
:::

::: ulist
-   5 - 4 is equivalent to 5 + -4. The first operand (5) is positive,
    whereas the second (-4) is negative, so the result must be moving
    toward zero where *no overflow* is possible.

-   4 + 2 (both positive) yields 6 (also positive), so *no overflow*
    occurs.

-   -5 - 1 is equivalent to -5 + -1 (both negative) and yields -6 (also
    negative), so *no overflow* occurs.

-   4 + 5 (both positive) yields -7 (negative). Because the operands
    have the same sign and it doesn't match the result's sign, this
    operation *overflows*.

-   -3 - 8 is equivalent to -3 + -8 (both negative) and yields 5
    (positive). Because the operands have the same sign and it doesn't
    match the result's sign, this operation *overflows*.
:::
:::
:::

::: sect2
### [](#_overflow_summary){.anchor}4.5.3. Overflow Summary {#_overflow_summary}

::: paragraph
In general, integer overflow occurs when an arithmetic operation moves
between the minimum and maximum values that its result can represent. If
you're ever in doubt about the rules for signed versus unsigned
overflow, consider the minimum and maximum values of an N-bit sequence:
:::

::: ulist
-   The minimum *unsigned* value is 0 (because unsigned encodings can't
    represent negative numbers) and the maximum unsigned value is 2^N^-1
    (because one bit sequence is reserved for zero). Therefore the
    discontinuity is between 2^N^-1 and 0.

-   The minimum *signed* value is -2^N-1^ (because half of the sequences
    are reserved for negative values) and the maximum is 2^N-1^-1
    (because in the other half, one value is reserved for zero).
    Therefore, the discontinuity is between 2^N-1^-1 and -2^N-1^.
:::
:::

::: sect2
### [](#_overflow_consequences){.anchor}4.5.4. Overflow Consequences {#_overflow_consequences}

::: paragraph
While you may not run into integer overflow frequently, overflows have
the potential to break programs in notable (and potentially devastating)
ways.
:::

::: paragraph
For example, in 2014, PSY's popular [Gangnam
Style](https://en.wikipedia.org/wiki/Gangnam_Style) music video
threatened to overflow the 32-bit counter that YouTube used to track
video hits. As a result, YouTube switched to using a 64-bit counter.
:::

::: paragraph
Another relatively harmless example shows up in the 1980 arcade game
*Pac-Man*. The game's developers used an unsigned eight-bit value to
track the player's progress through the game's levels. As a result, if
an expert player makes it beyond level 255 (the maximum value of an
eight-bit unsigned integer), half of the board ends up glitching
significantly, as shown in [Figure 5](#FigPacMan).
:::

::: {#FigPacMan .imageblock .text-center}
::: content
![The right half of the game board is completely corrupted with
nonsense.](_images/Pacman.png){width="240"}
:::

::: title
Figure 5. The *Pac-Man* game board \"freaks out\" upon reaching level
256
:::
:::

::: paragraph
A much more tragic example of overflow appears in the history of the
[Therac-25](https://en.wikipedia.org/wiki/Therac-25) radiation therapy
machine of the mid 1980s. The Therac-25 suffered from several design
problems, including one that incremented a truth flag variable rather
than setting it to a constant. After enough uses, the flag overflowed,
causing it to erroneously roll over to zero (false) and bypass safety
mechanisms. The Therac-25 ultimately caused serious harm to (and in some
cases killed) six patients.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
