
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.7. Integer Byte Order](byte_order.html)
:::

::: content
::: sect1
## [](#_integer_byte_order){.anchor}4.7. Integer Byte Order {#_integer_byte_order}

::: sectionbody
::: paragraph
So far, this chapter has described several schemes for encoding numbers
with bits, but it hasn't mentioned how the values are organized in
memory. For modern systems, the smallest addressable unit of memory is a
byte, which consists of eight bits. Consequently, to store a one-byte
value (e.g., a variable of type `char`) starting at address *X*, you
don't really have any options --- just store the byte at location *X*.
:::

::: paragraph
However, for multibyte values (e.g., variables of type `short` or
`int`), the hardware has more options for assigning a value's bytes to
memory addresses. For example, consider a two-byte `short` variable `s`
whose bytes are labeled A (containing the high-order bits of `s`) and B
(containing the low-order bits of `s`). When a system is asked to store
a `short` like `s` at address *X* (i.e., in addresses *X* and *X+1*), it
must define which byte of the variable (A or B) should occupy which
address (*X* or *X+1*). [Figure 1](#FigShortMemory) shows the two
options for storing `s` in memory.
:::

::: {#FigShortMemory .imageblock .text-center}
::: content
![In the first layout, byte A occupies address X, and byte B occupies
address X+1. In the other layout, their positions are
reversed.](_images/ShortMemory.png){width="680"}
:::

::: title
Figure 1. Two potential memory layouts for a two-byte short starting at
memory address X
:::
:::

::: paragraph
The **byte order** (or **endianness**) of a system defines how its
hardware assigns the bytes of a multibyte variable to consecutive memory
addresses. Although byte order is rarely an issue for programs that only
run on a single system, it might appear surprising if one of your
programs attempts to print bytes one at a time or if you're examining
variables with a debugger.
:::

::: paragraph
For example, consider the following program:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>

int main(int argc, char **argv) {
    // Initialize a four-byte integer with easily distinguishable byte values
    int value = 0xAABBCCDD;

    // Initialize a character pointer to the address of the integer.
    char *p = (char *) &value;

    // For each byte in the integer, print its memory address and value.
    int i;
    for (i = 0; i < sizeof(value); i++) {
        printf("Address: %p, Value: %02hhX\n", p, *p);
        p += 1;
    }

    return 0;
}
```
:::
:::

::: paragraph
This program allocates a four-byte integer and initializes the bytes, in
order from most to least significant, to the hexadecimal values `0xAA`,
`0xBB`, `0xCC`, and `0xDD`. It then prints the bytes one at a time
starting from the base address of the integer. You'd be forgiven for
expecting the bytes to print in alphabetical order. However, commonly
used CPU architectures (i.e., x86 and most ARM hardware) print the bytes
in reverse order when executing the example program:
:::

::: listingblock
::: content
    $ ./a.out
    Address: 0x7ffc0a234928, Value: DD
    Address: 0x7ffc0a234929, Value: CC
    Address: 0x7ffc0a23492a, Value: BB
    Address: 0x7ffc0a23492b, Value: AA
:::
:::

::: paragraph
x86 CPUs store integers in a **little-endian** format --- from the
least-significant byte (\"little end\") to the most-significant byte in
consecutive addresses. Other **big-endian** CPU architectures store
multibyte integers in the opposite order. Figure [Figure 2](#FigEndian)
depicts a four-byte integer in the (a) big-endian and (b) little-endian
layouts.
:::

::: {#FigEndian .imageblock .text-center}
::: content
![In the big-endian format, byte AA occupies position X, and the bytes
proceed in alphabetical order in consecutive addresses. In the
little-endian format, byte DD occupies position X, and the bytes proceed
in reverse alphabetical order.](_images/Endian.png){width="680"}
:::

::: title
Figure 2. The memory layout of a four-byte integer in the (a) big-endian
and (b) little-endian formats
:::
:::

::: paragraph
The seemingly strange \"endian\" terminology originates from Jonathan
Swift's satirical novel *Gulliver's Travels* (1726)^1^. In the story,
Gulliver finds himself among two empires of six-inch-tall people who are
fighting a war over the proper method for breaking eggs. The
\"big-endian\" empire of Blefuscu cracks the large end of their eggs,
whereas people in the \"little-endian\" empire of Lilliput crack the
small end.
:::

::: paragraph
In the computing world, whether a system is *big-endian* or
*little-endian* typically affects only programs that communicate across
machines (e.g., over a network). When communicating data between
systems, both systems must agree on the byte order for the receiver to
properly interpret the value. In 1980, Danny Cohen authored a note to
the Internet Engineering Task Force (IETF) titled *On Holy Wars and a
Plea for Peace* ^2^. In that note, Cohen adopts Swift's \"endian\"
terminology and suggests that the IETF adopts a standard byte order for
network transmissions. The IETF eventually adopted *big-endian* as the
\"network byte order\" standard.
:::

::: paragraph
The C language provides two libraries that allow a program to reorder an
integer's bytes^3,4^ for communication purposes.
:::

::: sect2
### [](#_references){.anchor}4.7.1. References {#_references}

::: {.olist .arabic}
1.  Jonathan Swift. *Gulliver's Travels*.
    [http://www.gutenberg.org/ebooks/829](http://www.gutenberg.org/ebooks/829){.bare}

2.  Danny Cohen. *On Holy Wars and a Plea for Peace*.
    [https://www.ietf.org/rfc/ien/ien137.txt](https://www.ietf.org/rfc/ien/ien137.txt){.bare}

3.  [https://linux.die.net/man/3/byteorder](https://linux.die.net/man/3/byteorder){.bare}

4.  [https://linux.die.net/man/3/endian](https://linux.die.net/man/3/endian){.bare}
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
