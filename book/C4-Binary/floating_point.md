
-   -   [4. Binary and Data Representation](index.html){.nav-link}
        -   [4.1. Number Bases and Unsigned
            Integers](bases.html){.nav-link}
        -   [4.2. Converting Between Bases](conversion.html){.nav-link}
        -   [4.3. Signed Binary Integers](signed.html){.nav-link}
        -   [4.4. Binary Integer Arithmetic](arithmetic.html){.nav-link}
            -   [4.4.1. Addition](arithmetic_addition.html){.nav-link}
            -   [4.4.2.
                Subtraction](arithmetic_subtraction.html){.nav-link}
            -   [4.4.3. Multiplication &
                Division](arithmetic_mult_div.html){.nav-link}
        -   [4.5. Overflow](overflow.html){.nav-link}
        -   [4.6. Bitwise Operators](bitwise.html){.nav-link}
        -   [4.7. Integer Byte Order](byte_order.html){.nav-link}
        -   [4.8. Real Numbers in
            Binary](floating_point.html){.nav-link}
        -   [4.9. Summary](summary.html){.nav-link}
        -   [4.10. Exercises](exercises.html){.nav-link}

-   -   [5. What von Neumann Knew: Computer
        Architecture](../C5-Arch/index.html){.nav-link}
        -   [5.1. The Origins of Modern
            Computing](../C5-Arch/hist.html){.nav-link}
        -   [5.2. The von Neumann
            Architecture](../C5-Arch/von.html){.nav-link}
        -   [5.3. Logic Gates](../C5-Arch/gates.html){.nav-link}
        -   [5.4. Circuits](../C5-Arch/circuits.html){.nav-link}
            -   [5.4.1. Arithmetic and Logic
                Circuits](../C5-Arch/arithlogiccircs.html){.nav-link}
            -   [5.4.2. Control
                Circuits](../C5-Arch/controlcircs.html){.nav-link}
            -   [5.4.3. Storage
                Circuits](../C5-Arch/storagecircs.html){.nav-link}
        -   [5.5. Building a Processor](../C5-Arch/cpu.html){.nav-link}
        -   [5.6. The Processor's Execution of Program
            Instructions](../C5-Arch/instrexec.html){.nav-link}
        -   [5.7. Pipelining Instruction
            Execution](../C5-Arch/pipelining.html){.nav-link}
        -   [5.8. Advanced Pipelining
            Considerations](../C5-Arch/pipelining_advanced.html){.nav-link}
        -   [5.9. Looking Ahead: CPUs
            Today](../C5-Arch/modern.html){.nav-link}
        -   [5.10. Summary](../C5-Arch/summary.html){.nav-link}
        -   [5.11. Exercises](../C5-Arch/exercises.html){.nav-link}

-   -   [6. Under the C: Dive into
        Assembly](../C6-asm_intro/index.html){.nav-link}

-   -   [7. 64-bit x86 Assembly](../C7-x86_64/index.html){.nav-link}
        -   [7.1. Assembly Basics](../C7-x86_64/basics.html){.nav-link}
        -   [7.2. Common
            Instructions](../C7-x86_64/common.html){.nav-link}
        -   [7.3. Additional Arithmetic
            Instructions](../C7-x86_64/arithmetic.html){.nav-link}
        -   [7.4. Conditional Control and
            Loops](../C7-x86_64/conditional_control_loops.html){.nav-link}
            -   [7.4.1.
                Preliminaries](../C7-x86_64/preliminaries.html){.nav-link}
            -   [7.4.2. If
                Statements](../C7-x86_64/if_statements.html){.nav-link}
            -   [7.4.3. Loops](../C7-x86_64/loops.html){.nav-link}
        -   [7.5. Functions in
            Assembly](../C7-x86_64/functions.html){.nav-link}
        -   [7.6. Recursion](../C7-x86_64/recursion.html){.nav-link}
        -   [7.7. Arrays in
            Assembly](../C7-x86_64/arrays.html){.nav-link}
        -   [7.8. Matrices in
            Assembly](../C7-x86_64/matrices.html){.nav-link}
        -   [7.9. Structs in
            Assembly](../C7-x86_64/structs.html){.nav-link}
        -   [7.10. Buffer
            Overflows](../C7-x86_64/buffer_overflow.html){.nav-link}
        -   [7.11. Exercises](../C7-x86_64/exercises.html){.nav-link}

-   -   [8. 32-bit x86 Assembly](../C8-IA32/index.html){.nav-link}
        -   [8.1. Assembly Basics](../C8-IA32/basics.html){.nav-link}
        -   [8.2. Common
            Instructions](../C8-IA32/common.html){.nav-link}
        -   [8.3. Additional Arithmetic
            Instructions](../C8-IA32/arithmetic.html){.nav-link}
        -   [8.4. Conditional Control and
            Loops](../C8-IA32/conditional_control_loops.html){.nav-link}
            -   [8.4.1.
                Preliminaries](../C8-IA32/preliminaries.html){.nav-link}
            -   [8.4.2. If
                Statements](../C8-IA32/if_statements.html){.nav-link}
            -   [8.4.3. Loops](../C8-IA32/loops.html){.nav-link}
        -   [8.5. Functions in
            Assembly](../C8-IA32/functions.html){.nav-link}
        -   [8.6. Recursion](../C8-IA32/recursion.html){.nav-link}
        -   [8.7. Arrays in Assembly](../C8-IA32/arrays.html){.nav-link}
        -   [8.8. Matrices in
            Assembly](../C8-IA32/matrices.html){.nav-link}
        -   [8.9. Structs in
            Assembly](../C8-IA32/structs.html){.nav-link}
        -   [8.10. Buffer
            Overflows](../C8-IA32/buffer_overflow.html){.nav-link}
        -   [8.11. Exercises](../C8-IA32/exercises.html){.nav-link}

-   -   [9. ARMv8 Assembly](../C9-ARM64/index.html){.nav-link}
        -   [9.1. Assembly Basics](../C9-ARM64/basics.html){.nav-link}
        -   [9.2. Common
            Instructions](../C9-ARM64/common.html){.nav-link}
        -   [9.3. Arithmetic
            Instructions](../C9-ARM64/arithmetic.html){.nav-link}
        -   [9.4. Conditional Control and
            Loops](../C9-ARM64/conditional_control_loops.html){.nav-link}
            -   [9.4.1.
                Preliminaries](../C9-ARM64/preliminaries.html){.nav-link}
            -   [9.4.2. If
                Statements](../C9-ARM64/if_statements.html){.nav-link}
            -   [9.4.3. Loops](../C9-ARM64/loops.html){.nav-link}
        -   [9.5. Functions in
            Assembly](../C9-ARM64/functions.html){.nav-link}
        -   [9.6. Recursion](../C9-ARM64/recursion.html){.nav-link}
        -   [9.7. Arrays in
            Assembly](../C9-ARM64/arrays.html){.nav-link}
        -   [9.8. Matrices in
            Assembly](../C9-ARM64/matrices.html){.nav-link}
        -   [9.9. Structs in
            Assembly](../C9-ARM64/structs.html){.nav-link}
        -   [9.10. Buffer
            Overflows](../C9-ARM64/buffer_overflow.html){.nav-link}
        -   [9.11. Exercises](../C9-ARM64/exercises.html){.nav-link}

-   -   [10. Key Assembly
        Takeaways](../C10-asm_takeaways/index.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [4. Binary and Data Representation](index.html)
-   [4.8. Real Numbers in Binary](floating_point.html)
:::

::: content
::: sect1
## [](#_real_numbers_in_binary){.anchor}4.8. Real Numbers in Binary {#_real_numbers_in_binary}

::: sectionbody
::: paragraph
While this chapter mainly focuses on binary integer representations,
programmers often need to store real numbers, too. Storing real numbers
is inherently difficult, and no binary encoding represents real values
with perfect precision. That is, for any binary encoding of real
numbers, there exist values that cannot be represented *exactly*.
Irrational values like *pi* clearly can't be represented precisely,
since their representation never terminates. Given a fixed number of
bits, binary encodings still can't represent some rational values within
their range.
:::

::: paragraph
Unlike integers, which are [countably
infinite](https://en.wikipedia.org/wiki/Countable_set), the set of real
numbers is [uncountable](https://en.wikipedia.org/wiki/Uncountable_set).
In other words, even for a narrow range of real values (e.g., between
zero and one), the set of values within that range is so large that we
can't even begin to enumerate them. Thus, real number encodings
typically store only approximations of values that have been truncated
to a predetermined number of bits. Given enough bits, the approximations
are typically precise enough for most purposes, but be careful when
writing applications that cannot tolerate rounding.
:::

::: paragraph
The remainder of this section briefly describes two methods for
representing real numbers in binary: *fixed-point*, which extends the
binary integer format, and *floating-point*, which represents a large
range of values at the cost of some extra complexity.
:::

::: sect2
### [](#_fixed_point_representation){.anchor}4.8.1. Fixed-Point Representation {#_fixed_point_representation}

::: paragraph
In a **fixed-point representation**, the position of a value's *binary
point* remains fixed and cannot be changed. Like a *decimal point* in a
decimal number, the binary point indicates where the fractional portion
of the number begins. The fixed-point encoding rules resemble the
[unsigned integer](bases.html#_unsigned_binary_numbers){.page}
representation, with one major exception: the digits after the binary
point represent powers of two raised to a *negative* value. For example,
consider the eight-bit sequence 0b000101.10 in which the first six bits
represent whole numbers, and the remaining two bits represent the
fractional part. [Figure 1](#FigFixed) labels the digit positions and
their individual interpretations.
:::

::: {#FigFixed .imageblock .text-center}
::: content
![From high-order to low-order, the digits are labeled d5, d4, d3, d2,
d1, d0, d-1, d-2. d-1 contributes 0.5, and d-2 contributes 0.25 to the
value.](_images/Fixed.png){width="650"}
:::

::: title
Figure 1. The value of each digit in an eight-bit number with two bits
after the fixed binary point
:::
:::

::: paragraph
Applying the formula for converting 0b000101.10 to decimal shows:
:::

::: sidebarblock
::: content
::: {.paragraph .lead}
(0 × 2^5^)    +    (0 × 2^4^)    +    (0 × 2^3^)    +    (1 × 2^2^)    +
   (0 × 2^1^)    +    (1 × 2^0^)    +    (1 × 2^-1^)    +    (0 × 2^-2^)
:::

::: {.paragraph .lead}
  =    0 + 0 + 0 + 4 + 0 + 1 + 0.5 + 0    =    5.5
:::
:::
:::

::: paragraph
More generally, with two bits after the binary point, the fractional
portion of a number holds one of four sequences: 00 (.00), 01 (.25), 10
(.50), or 11 (.75). Thus, two fractional bits allow a fixed-point number
to represent fractional values that are precise to 0.25 (2^-2^). Adding
a third bit increases the precision to 0.125 (2^-3^), and the pattern
continues similarly, with *N* bits after the binary point enabling 2^-N^
precision.
:::

::: paragraph
Because the number of bits after the binary point remains fixed, some
computations with fully precise operands may produce a result that
requires truncation (rounding). Consider the same eight-bit fixed-point
encoding from the previous example. It precisely represents both 0.75
(0b000000.11) and 2 (0b000010.00). However, it cannot precisely
represent the result of dividing 0.75 by 2: the computation *should*
produce 0.375, but storing it would require a third bit after the binary
point (0b000000.01**1**). Truncating the rightmost 1 enables the result
to fit within the specified format, but it yields a rounded result of
0.75 / 2 = 0.25. In this example, the rounding is egregious due to the
small number of bits involved, but even longer bit sequences will
require truncation at some point.
:::

::: paragraph
Even worse, rounding errors compound over the course of intermediate
calculations, and in some cases the result of a sequence of computations
might vary according to the order in which they're performed. For
example, consider two arithmetic sequences under the same eight-bit
fixed-point encoding described earlier:
:::

::: {.olist .arabic}
1.  `(0.75 / 2) * 3    =    0.75`

2.  `(0.75 * 3) / 2    =    1.00`
:::

::: paragraph
Note that the only difference between the two is the order of the
multiplication and division operations. If no rounding were necessary,
both computations should produce the same result (1.125). However, due
to truncation occurring at different locations in the arithmetic, they
produce different results:
:::

::: {.olist .arabic}
1.  Proceeding from left to right, the intermediate result (`0.75 / 2`)
    gets rounded to 0.25 and ultimately produces 0.75 when multiplied by
    3.

2.  Proceeding from left to right, the intermediate computation
    (`0.75 * 3`) precisely yields 2.25 without any rounding. Dividing
    2.25 by 2 rounds to a final result of 1.
:::

::: paragraph
In this example, just one additional bit for the 2^-3^ place allows the
example to succeed with full precision, but the fixed-point position we
chose only allowed for two bits after the binary point. All the while,
the high-order bits of the operands went entirely unused (digits d~2~
through d~5~ were never set to 1). At the cost of extra complexity, an
alternative representation (floating-point) allows the full range of
bits to contribute to a value regardless of the split between whole and
fractional parts.
:::
:::

::: sect2
### [](#_floating_point_representation){.anchor}4.8.2. Floating-Point Representation {#_floating_point_representation}

::: paragraph
In a **floating-point representation**, a value's binary point is *not*
fixed into a predefined position. That is, the interpretation of a
binary sequence must encode how it's representing the split between the
whole and fractional parts of a value. While the position of the binary
point could be encoded in many possible ways, this section focuses on
just one, the [Institute of Electrical and Electronics Engineers (IEEE)
standard 754](https://en.wikipedia.org/wiki/IEEE_754). Almost all modern
hardware follows the IEEE 754 standard to represent floating-point
values.
:::

::: {#FigIEEE754 .imageblock .text-center}
::: content
![The leftmost digit represents the sign bit. The next eight bits
represent the exponent, and the remaining 23 bits represent the
significand.](_images/IEEE754.png)
:::

::: title
Figure 2. The 32-bit IEEE 754 floating-point standard
:::
:::

::: paragraph
[Figure 2](#FigIEEE754) illustrates the IEEE 754 interpretation of a
32-bit floating-point number (C's `float` type). The standard partitions
the bits into three regions:
:::

::: {.olist .arabic}
1.  The low-order 23 bits (digits d~22~ through d~0~) represent the
    *significand* (sometimes called the *mantissa*). As the largest
    region of bits, the significand serves as the foundation for the
    value, which ultimately gets altered by multiplying it according to
    the other bit regions. When interpreting the significand, its value
    implicitly follows a 1 and binary point. The fractional portion
    behaves like the fixed-point representation described in the
    previous section.

    ::: paragraph
    For example, if the bits of the significand contain 0b110000...​0000,
    the first bit represents 0.5 (1 × 2^-1^), the second bit represents
    0.25 (1 × 2^-2^), and all the remaining bits are zeros, so they
    don't affect the value. Thus, the significand contributes 1.(0.5 +
    0.25), or 1.75.
    :::

2.  The next eight bits (digits d~30~ through d~23~) represent the
    *exponent*, which scales the significand's value to provide a wide
    representable range. The significand gets multiplied by
    2^exponent\ -\ 127^, where the 127 is a *bias* that enables the
    float to represent both very large and very small values.

3.  The final high-order bit (digit d~31~) represents the *sign bit*,
    which encodes whether the value is positive (0) or negative (1).
:::

::: paragraph
As an example, consider decoding the bit sequence
0b11000001101101000000000000000000. The significand portion is
01101000000000000000000, which represents 2^-2^ + 2^-3^ + 2^-5^ =
0.40625, so the signifcand region contributes 1.40625. The exponent is
10000011, which represents the decimal value 131, so the exponent
contributes a factor of 2^(131-127)^ (16). Finally, the sign bit is 1,
so the sequence represents a negative value. Putting it all together,
the bit sequence represents:
:::

::: listingblock
::: content
    1.40625 × 16 × -1  = -22.5
:::
:::

::: paragraph
While clearly more complex than the fixed-point scheme described
earlier, the IEEE floating-point standard provides additional
flexibility for representing a wide range of values. Despite the
flexibility, a floating-point format with a constant number of bits
still can't precisely represent every possible value. That is, like
fixed-point, rounding problems similarly affect floating-point
encodings.
:::
:::

::: sect2
### [](#_rounding_consequences){.anchor}4.8.3. Rounding Consequences {#_rounding_consequences}

::: paragraph
While rounding isn't likely to ruin most of the programs you write, real
number rounding errors have occasionally caused some high-profile system
failures. During the Gulf War in 1991, a rounding error caused an
American Patriot missile battery to [fail to intercept an Iraqi
missile](http://www-users.math.umn.edu/~arnold/disasters/patriot.html).
The missile killed 28 soldiers and left many others wounded. In 1996,
the European Space Agency's first launch of the Ariane 5 rocket
[exploded 39 seconds after taking
off](https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284).
The rocket, which borrowed much of its code from the Ariane 4, triggered
an overflow when attempting to convert a floating-point value into an
integer value.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
