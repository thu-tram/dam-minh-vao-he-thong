
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful C](index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](input_output.html){.nav-link}
        -   [1.3. Conditionals and Loops](conditionals.html){.nav-link}
        -   [1.4. Functions](functions.html){.nav-link}
        -   [1.5. Arrays and Strings](arrays_strings.html){.nav-link}
        -   [1.6. Structs](structs.html){.nav-link}
        -   [1.7. Summary](summary.html){.nav-link}
        -   [1.8. Exercises](exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](../C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](../C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](../C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](../C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](../C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](../C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](../C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](../C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](../C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](../C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](../C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](../C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](../C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](../C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](../C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](../C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](../C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](../C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](../C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [1. By the C, the Beautiful C](index.html)
-   [1.6. Structs](structs.html)
:::

::: content
::: sect1
## [](#_structs){.anchor}1.6. Structs {#_structs}

::: sectionbody
::: paragraph
Arrays and structs are the two ways in which C supports creating
collections of data elements. Arrays are used to create an ordered
collection of data elements of the same type, whereas **structs** are
used to create a collection of data elements of *different types*. A C
programmer can combine array and struct building blocks in many
different ways to create more complex data types and structures. This
section introduces structs, and in the next chapter we [characterize
structs in more detail](../C2-C_depth/structs.html#_c_structs){.page}
and [show how you can combine them with
arrays](../C2-C_depth/structs.html#_arrays_of_structs){.page}.
:::

::: paragraph
C is not an object-oriented language; thus, it doesn't support classes.
It does, however, support defining structured types, which are like the
data part of classes. A `struct` is a type used to represent a
heterogeneous collection of data; it's a mechanism for treating a set of
different types as a single, coherent unit. C structs provide a level of
abstraction on top of individual data values, treating them as a single
type. For example, a student has a name, age, grade point average (GPA),
and graduation year. A programmer could define a new `struct` type to
combine those four data elements into a single `struct student` variable
that contains a name value (type `char []`, to hold a string), an age
value (type `int`), a GPA value (type `float`), and a graduation year
value (type `int`). A single variable of this struct type can store all
four pieces of data for a particular student; for example, (\"Freya\",
19, 3.7, 2021).
:::

::: paragraph
There are three steps to defining and using `struct` types in C
programs:
:::

::: {.olist .arabic}
1.  Define a new `struct` type that represents the structure.

2.  Declare variables of the new `struct` type.

3.  Use dot (`.`) notation to access individual field values of the
    variable.
:::

::: sect2
### [](#_defining_a_struct_type){.anchor}1.6.1. Defining a Struct Type {#_defining_a_struct_type}

::: paragraph
A struct type definition should appear *outside of any function*,
typically near the top of the program's `.c` file. The syntax for
defining a new struct type is the following (`struct` is a reserved
keyword):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct <struct_name> {
    <field 1 type> <field 1 name>;
    <field 2 type> <field 2 name>;
    <field 3 type> <field 3 name>;
    ...
};
```
:::
:::

::: paragraph
Here's an example of defining a new `struct studentT` type for storing
student data:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct studentT {
    char name[64];
    int age;
    float gpa;
    int grad_yr;
};
```
:::
:::

::: paragraph
This struct definition adds a new type to C's type system, and the
type's name is `struct studentT`. This struct defines four fields, and
each field definition includes the type and name of the field. Note that
in this example, the `name` field's type is a character array, for [use
as a
string](arrays_strings.html#_introduction_to_strings_and_the_c_string_library){.page}.
:::
:::

::: sect2
### [](#_declaring_variables_of_struct_types){.anchor}1.6.2. Declaring Variables of Struct Types {#_declaring_variables_of_struct_types}

::: paragraph
Once the type has been defined, you can declare variables of the new
type, `struct studentT`. Note that unlike the other types we've
encountered so far that consist of just a single word (for example,
`int`, `char`, and `float`), the name of our new struct type is two
words, `struct studentT`.
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct studentT student1, student2; // student1, student2 are struct studentT
```
:::
:::
:::

::: sect2
### [](#_accessing_field_values){.anchor}1.6.3. Accessing Field Values {#_accessing_field_values}

::: paragraph
To access field values in a struct variable, use *dot notation*:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
<variable name>.<field name>
```
:::
:::

::: paragraph
When accessing structs and their fields, carefully consider the types of
the variables you're using. Novice C programmers often introduce bugs
into their programs by failing to account for the types of struct
fields. [Table 1](#TabStructTypes) shows the types of several
expressions surrounding our `struct studentT` type.
:::

+-----------------+-----------------------------------------------------+
| Expression      | C type                                              |
+=================+=====================================================+
| `student1`      | `struct studentT`                                   |
+-----------------+-----------------------------------------------------+
| `student1.age`  | integer (`int`)                                     |
+-----------------+-----------------------------------------------------+
| `student1.name` | array of characters (`char []`)                     |
+-----------------+-----------------------------------------------------+
| `st             | character (`char`), the type stored in each         |
| udent1.name[3]` | position of the name array                          |
+-----------------+-----------------------------------------------------+

: Table 1. The Types Associated with Various Struct studentT Expressions

::: paragraph
Here are some examples of assigning a `struct studentT` variable's
fields:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// The 'name' field is an array of characters, so we can use the 'strcpy'
// string library function to fill in the array with a string value.
strcpy(student1.name, "Kwame Salter");

// The 'age' field is an integer.
student1.age = 18 + 2;

// The 'gpa' field is a float.
student1.gpa = 3.5;

// The 'grad_yr' field is an int
student1.grad_yr = 2020;
student2.grad_yr = student1.grad_yr;
```
:::
:::

::: paragraph
[Figure 1](#FigStudentStruct) illustrates the layout of the `student1`
variable in memory after the field assignments in the preceding example.
Only the struct variable's fields (the areas in boxes) are stored in
memory. The field names are labeled on the figure for clarity, but to
the C compiler, fields are simply storage locations or **offsets** from
the start of the struct variable's memory. For example, based on the
definition of a `struct studentT`, the compiler knows that to access the
field named `gpa`, it must skip past an array of 64 characters (`name`)
and one integer (`age`). Note that in the figure, the `name` field only
depicts the first six characters of the 64-character array.
:::

::: {#FigStudentStruct .imageblock .text-center}
::: content
![The layout of student1's memory: the name field is a character array
containing \'k\' \'w\' \'a\' \'m\' \'e\' ...â€‹ The age field holds 20, the
gpa field stores 3.5, and grad_yr contains
2020.](_images/studentstruct.png){width="800"}
:::

::: title
Figure 1. The student1 variable's memory after assigning each of its
fields
:::
:::

::: paragraph
C struct types are **lvalues**, meaning they can appear on the left side
of an assignment statement. Thus, a struct variable can be assigned the
value of another struct variable using a simple assignment statement.
The field values of the struct on the right side of the assignment
statement are *copied* to the field values of the struct on the left
side of the assignment statement. In other words, the contents of memory
of one struct are copied to the memory of the other. Here's an example
of assigning a struct's values in this way:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
student2 = student1;  // student2 gets the value of student1
                      // (student1's field values are copied to
                      //  corresponding field values of student2)

strcpy(student2.name, "Frances Allen");  // change one field value
```
:::
:::

::: paragraph
[Figure 2](#FigStructAssign) shows the values of the two student
variables after the assignment statement and call to `strcpy` have
executed. Note that the figure depicts the `name` fields as the string
values they contain rather than the full array of 64 characters.
:::

::: {#FigStructAssign .imageblock .text-center}
::: content
![Struct Values and Assignment: the field values of the struct on the
right hand side are assigned to corresponding field values of the struct
on the left hand side of the assignment
statement.](_images/structassign.png){width="800"}
:::

::: title
Figure 2. Layout of the student1 and student2 structs after executing
the struct assignment and strcpy call
:::
:::

::: paragraph
C provides a `sizeof` operator that takes a type and returns the number
of bytes used by the type. The `sizeof` operator can be used on any C
type, including struct types, to see how much memory space a variable of
that type needs. For example, we can print the size of a
`struct studentT` type:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
// Note: the `%lu` format placeholder specifies an unsigned long value.
printf("number of bytes in student struct: %lu\n", sizeof(struct studentT));
```
:::
:::

::: paragraph
When run, this line should print out a value of *at least* 76 bytes,
because 64 characters are in the `name` array (1 byte for each `char`),
4 bytes for the `int` `age` field, 4 bytes for the `float` `gpa` field,
and 4 bytes for the `int` `grad_yr` field. The exact number of bytes
might be larger than 76 on some machines.
:::

::: paragraph
Here's a [full example program](_attachments/studentTstruct.c) that
defines and demonstrates the use of our `struct studentT` type:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <string.h>

// Define a new type: struct studentT
// Note that struct definitions should be outside function bodies.
struct studentT {
    char name[64];
    int age;
    float gpa;
    int grad_yr;
};

int main(void) {
    struct studentT student1, student2;

    strcpy(student1.name, "Kwame Salter");  // name field is a char array
    student1.age = 18 + 2;                  // age field is an int
    student1.gpa = 3.5;                     // gpa field is a float
    student1.grad_yr = 2020;                // grad_yr field is an int

    /* Note: printf doesn't have a format placeholder for printing a
     * struct studentT (a type we defined).  Instead, we'll need to
     * individually pass each field to printf. */
    printf("name: %s age: %d gpa: %g, year: %d\n",
           student1.name, student1.age, student1.gpa, student1.grad_yr);

    /* Copy all the field values of student1 into student2. */
    student2 = student1;

    /* Make a few changes to the student2 variable. */
    strcpy(student2.name, "Frances Allen");
    student2.grad_yr = student1.grad_yr + 1;

    /* Print the fields of student2. */
    printf("name: %s age: %d gpa: %g, year: %d\n",
           student2.name, student2.age, student2.gpa, student2.grad_yr);

    /* Print the size of the struct studentT type. */
    printf("number of bytes in student struct: %lu\n", sizeof(struct studentT));

    return 0;
}
```
:::
:::

::: paragraph
When run, this program outputs the following:
:::

::: listingblock
::: content
    name: Kwame Salter age: 20 gpa: 3.5, year: 2020
    name: Frances Allen age: 20 gpa: 3.5, year: 2021
    number of bytes in student struct: 76
:::
:::

::: {#_lvalues .sidebarblock}
::: content
::: title
lvalues
:::

::: paragraph
An **lvalue** is an expression that can appear on the left side of an
assignment statement. It's an expression that represents a memory
storage location. As we introduce C pointer types and examples of
creating more complicated structures that combine C arrays, structs, and
pointers, it's important to think carefully about types and to keep in
mind which C expressions are valid lvalues (which can be used on the
left side of an assignment statement).
:::

::: paragraph
From what we know about C so far, single variables of base types, array
elements, and structs are all lvalues. The name of a statically declared
array is *not* an lvalue (you cannot change the base address of a
statically declared array in memory). The following example code snippet
illustrates valid and invalid C assignment statements based on the
lvalue status of different types:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
struct studentT {
    char name[32];
    int  age;
    float gpa;
    int  grad_yr;
};

int main(void) {
    struct studentT  student1, student2;
    int x;
    char arr[10], ch;

    x = 10;                 // Valid C: x is an lvalue
    ch = 'm';               // Valid C: ch is an lvalue
    student1.age = 18;      // Valid C: age field is an lvalue
    student2 = student1;    // Valid C: student2 is an lvalue
    arr[3] = ch;            // Valid C: arr[3] is an lvalue

    x + 1 = 8;       // Invalid C: x+1 is not an lvalue
    arr = "hello";   // Invalid C: arr is not an lvalue
                     //  cannot change base addr of statically declared array
                     //  (use strcpy to copy the string value "hello" to arr)

    student1.name = student2.name;  // Invalid C: name field is not an lvalue
                                    // (the base address of a statically
                                    //  declared array cannot be changed)
```
:::
:::
:::
:::
:::

::: sect2
### [](#_passing_structs_to_functions){.anchor}1.6.4. Passing Structs to Functions {#_passing_structs_to_functions}

::: paragraph
In C, arguments of all types are *passed by value* to functions. Thus,
if a function has a struct type parameter, then when called with a
struct argument, the argument's **value** is passed to its parameter,
meaning that the parameter gets a copy of its argument's value. The
value of a struct variable is the contents of its memory, which is why
we can assign the fields of one struct to be the same as another struct
in a single assignment statement like this:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
student2 = student1;
```
:::
:::

::: paragraph
Because the value of a struct variable represents the full contents of
its memory, passing a struct as an argument to a function gives the
parameter a **copy** of all the argument struct's field values. If the
function changes the field values of a struct parameter, the changes to
the parameter's field values have *no effect* on the corresponding field
values of the argument. That is, changes to the parameter's fields only
modify values in the parameter's memory locations for those fields, not
in the argument's memory locations for those fields.
:::

::: paragraph
Here's a [full example program](_attachments/structfunc.c) using the
`checkID` function that takes a struct parameter:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
#include <stdio.h>
#include <string.h>

/* struct type definition: */
struct studentT {
    char name[64];
    int  age;
    float gpa;
    int  grad_yr;
};

/* function prototype (prototype: a declaration of the
 *    checkID function so that main can call it, its full
 *    definition is listed after main function in the file):
 */
int checkID(struct studentT s1, int min_age);

int main(void) {
    int can_vote;
    struct studentT student;

    strcpy(student.name, "Ruth");
    student.age = 17;
    student.gpa = 3.5;
    student.grad_yr = 2021;

    can_vote = checkID(student, 18);
    if (can_vote) {
        printf("%s is %d years old and can vote.\n",
                student.name, student.age);
    } else {
        printf("%s is only %d years old and cannot vote.\n",
                student.name, student.age);
    }

    return 0;
}

/*  check if a student is at least the min age
 *    s: a student
 *    min_age: a minimum age value to test
 *    returns: 1 if the student is min_age or older, 0 otherwise
 */
int checkID(struct studentT s, int min_age) {
    int ret = 1;  // initialize the return value to 1 (true)

    if (s.age < min_age) {
        ret = 0;  // update the return value to 0 (false)

        // let's try changing the student's age
        s.age = min_age + 1;
    }

    printf("%s is %d years old\n", s.name, s.age);

    return ret;
}
```
:::
:::

::: paragraph
When `main` calls `checkID`, the value of the `student` struct (a copy
of the memory contents of all its fields) is passed to the `s`
parameter. When the function changes the value of its parameter's `age`
field, it *doesn't* affect the `age` field of its argument (`student`).
This behavior can be seen by running the program, which outputs the
following:
:::

::: listingblock
::: content
    Ruth is 19 years old
    Ruth is only 17 years old and cannot vote.
:::
:::

::: paragraph
The output shows that when `checkID` prints the `age` field, it reflects
the function's change to the `age` field of the parameter `s`. However,
after the function call returns, `main` prints the `age` field of
`student` with the same value it had prior to the `checkID` call.
[Figure 3](#FigStructStack) illustrates the contents of the call stack
just before the `checkID` function returns.
:::

::: {#FigStructStack .imageblock .text-center}
::: content
![As the student struct is passed to checkID, the parameter gets a copy
of its contents. When checkID modifies the age field to 19, the change
only applies to its local copy. The student struct's age field in main
remains at 17.](_images/structstack.png){width="450"}
:::

::: title
Figure 3. The contents of the call stack before returning from the
checkID function
:::
:::

::: paragraph
Understanding the pass-by-value semantics of struct parameters is
particularly important when a struct contains a statically declared
array field (like the `name` field in `struct studentT`). When such a
struct is passed to a function, the struct argument's entire memory
contents, including every array element in the array field, is copied to
its parameter. If the parameter struct's array contents are changed by
the function, those changes will *not* persist after the function
returns. This behavior might seem odd given what we know about [how
arrays are passed to
functions](arrays_strings.html#_arrays_and_functions){.page}, but it's
consistent with the struct-copying behavior described earlier.
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
