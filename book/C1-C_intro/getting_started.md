
### [Dive Into Systems](../index-2.html) {#dive-into-systems .title}

-   -   [Dive Into Systems]{.nav-text}
        -   [Authors](../index-2.html){.nav-link}
        -   [Copyright](../copyright.html){.nav-link}
        -   [Acknowledgements](../acknowledgements.html){.nav-link}
        -   [Preface](../preface.html){.nav-link}
    -   [0. Introduction](../introduction.html){.nav-link}

-   -   [1. By the C, the Beautiful C](index.html){.nav-link}
        -   [1.1. Getting Started Programming in
            C](getting_started.html){.nav-link}
        -   [1.2. Input/Output (printf and
            scanf)](input_output.html){.nav-link}
        -   [1.3. Conditionals and Loops](conditionals.html){.nav-link}
        -   [1.4. Functions](functions.html){.nav-link}
        -   [1.5. Arrays and Strings](arrays_strings.html){.nav-link}
        -   [1.6. Structs](structs.html){.nav-link}
        -   [1.7. Summary](summary.html){.nav-link}
        -   [1.8. Exercises](exercises.html){.nav-link}

-   -   [2. A Deeper Dive Into C](../C2-C_depth/index.html){.nav-link}
        -   [2.1. Parts of Program Memory and
            Scope](../C2-C_depth/scope_memory.html){.nav-link}
        -   [2.2. C Pointer
            Variables](../C2-C_depth/pointers.html){.nav-link}
        -   [2.3. Pointers and
            Functions](../C2-C_depth/pointers_functions.html){.nav-link}
        -   [2.4. Dynamic Memory
            Allocation](../C2-C_depth/dynamic_memory.html){.nav-link}
        -   [2.5. Arrays in C](../C2-C_depth/arrays.html){.nav-link}
        -   [2.6. Strings and the String
            Library](../C2-C_depth/strings.html){.nav-link}
        -   [2.7. Structs](../C2-C_depth/structs.html){.nav-link}
        -   [2.8. Input / Output in C](../C2-C_depth/IO.html){.nav-link}
        -   [2.9. Advanced C
            Features](../C2-C_depth/advanced.html){.nav-link}
            -   [2.9.1. Constants, switch, enum, and
                typedef](../C2-C_depth/advanced_switch.html){.nav-link}
            -   [2.9.2. Command Line
                Arguments](../C2-C_depth/advanced_cmd_line_args.html){.nav-link}
            -   [2.9.3. The void\*
                Type](../C2-C_depth/advanced_voidstar.html){.nav-link}
            -   [2.9.4. Pointer
                Arithmetic](../C2-C_depth/advanced_pointer_arithmetic.html){.nav-link}
            -   [2.9.5. C Libraries: Using, Compiling and
                Linking](../C2-C_depth/advanced_libraries.html){.nav-link}
            -   [2.9.6. Writing and using your own C libraries (and
                compiling multiple .c and .h
                files)](../C2-C_depth/advanced_writing_libraries.html){.nav-link}
            -   [2.9.7. Compiling C to Assembly and Compiling Assembly
                Code](../C2-C_depth/advanced_assembly.html){.nav-link}
        -   [2.10. Summary](../C2-C_depth/summary.html){.nav-link}
        -   [2.11. Exercises](../C2-C_depth/exercises.html){.nav-link}

-   -   [3. C Debugging Tools](../C3-C_debug/index.html){.nav-link}
        -   [3.1. Debugging with GDB](../C3-C_debug/gdb.html){.nav-link}
        -   [3.2. GDB Commands in
            Detail](../C3-C_debug/gdb_commands.html){.nav-link}
        -   [3.3. Debugging Memory with
            Valgrind](../C3-C_debug/valgrind.html){.nav-link}
        -   [3.4. Advanced GDB
            Features](../C3-C_debug/gdb_advanced.html){.nav-link}
        -   [3.5. Debugging Assembly
            Code](../C3-C_debug/gdb_assembly.html){.nav-link}
        -   [3.6. Debugging Multi-threaded
            Programs](../C3-C_debug/gdb_pthreads.html){.nav-link}
        -   [3.7. Summary](../C3-C_debug/summary.html){.nav-link}

-   -   [11. Storage and the Memory
        Hierarchy](../C11-MemHierarchy/index.html){.nav-link}
        -   [11.1. The Memory
            Hierarchy](../C11-MemHierarchy/mem_hierarchy.html){.nav-link}
        -   [11.2. Storage
            Devices](../C11-MemHierarchy/devices.html){.nav-link}
        -   [11.3.
            Locality](../C11-MemHierarchy/locality.html){.nav-link}
        -   [11.4. Caching](../C11-MemHierarchy/caching.html){.nav-link}
        -   [11.5. Cache Analysis and
            Cachegrind](../C11-MemHierarchy/cachegrind.html){.nav-link}
        -   [11.6. Looking Ahead: Caching on Multicore
            Processors](../C11-MemHierarchy/coherency.html){.nav-link}
        -   [11.7. Summary](../C11-MemHierarchy/summary.html){.nav-link}
        -   [11.8.
            Exercises](../C11-MemHierarchy/exercises.html){.nav-link}

-   -   [12. Code Optimization](../C12-CodeOpt/index.html){.nav-link}
        -   [12.1. First Steps](../C12-CodeOpt/basic.html){.nav-link}
        -   [12.2. Other Compiler
            Optimizations](../C12-CodeOpt/loops_functions.html){.nav-link}
        -   [12.3. Memory
            Considerations](../C12-CodeOpt/memory_considerations.html){.nav-link}
        -   [12.4. Summary](../C12-CodeOpt/summary.html){.nav-link}

-   -   [13. The Operating System](../C13-OS/index.html){.nav-link}
        -   [13.1. Booting and Running](../C13-OS/impl.html){.nav-link}
        -   [13.2. Processes](../C13-OS/processes.html){.nav-link}
        -   [13.3. Virtual Memory](../C13-OS/vm.html){.nav-link}
        -   [13.4. Interprocess
            Communication](../C13-OS/ipc.html){.nav-link}
            -   [13.4.1. Signals](../C13-OS/ipc_signals.html){.nav-link}
            -   [13.4.2. Message
                Passing](../C13-OS/ipc_msging.html){.nav-link}
            -   [13.4.3. Shared
                Memory](../C13-OS/ipc_shm.html){.nav-link}
        -   [13.5. Summary and Other OS
            Functionality](../C13-OS/advanced.html){.nav-link}
        -   [13.6. Exercises](../C13-OS/exercises.html){.nav-link}

-   -   [14. Leveraging Shared Memory in the Multicore
        Era](../C14-SharedMemory/index.html){.nav-link}
        -   [14.1. Programming Multicore
            Systems](../C14-SharedMemory/multicore.html){.nav-link}
        -   [14.2. POSIX
            Threads](../C14-SharedMemory/posix.html){.nav-link}
        -   [14.3. Synchronizing
            Threads](../C14-SharedMemory/synchronization.html){.nav-link}
            -   [14.3.1. Mutual
                Exclusion](../C14-SharedMemory/mutex.html){.nav-link}
            -   [14.3.2.
                Semaphores](../C14-SharedMemory/semaphores.html){.nav-link}
            -   [14.3.3. Other Synchronization
                Constructs](../C14-SharedMemory/other_syncs.html){.nav-link}
        -   [14.4. Measuring Parallel
            Performance](../C14-SharedMemory/performance.html){.nav-link}
            -   [14.4.1. Parallel Performance
                Basics](../C14-SharedMemory/performance_basics.html){.nav-link}
            -   [14.4.2. Advanced
                Topics](../C14-SharedMemory/performance_advanced.html){.nav-link}
        -   [14.5. Cache
            Coherence](../C14-SharedMemory/cache_coherence.html){.nav-link}
        -   [14.6. Thread
            Safety](../C14-SharedMemory/thread_safety.html){.nav-link}
        -   [14.7. Implicit Threading with
            OpenMP](../C14-SharedMemory/openmp.html){.nav-link}
        -   [14.8. Summary](../C14-SharedMemory/summary.html){.nav-link}
        -   [14.9.
            Exercises](../C14-SharedMemory/exercises.html){.nav-link}

-   -   [15. Looking Ahead: Other Parallel
        Systems](../C15-Parallel/index.html){.nav-link}
        -   [15.1. Hardware Acceleration and
            CUDA](../C15-Parallel/gpu.html){.nav-link}
        -   [15.2. Distributed Memory
            Systems](../C15-Parallel/distrmem.html){.nav-link}
        -   [15.3. To Exascale and
            Beyond](../C15-Parallel/cloud.html){.nav-link}

-   -   [16. Appendix 1: Chapter 1 for Java
        Programmers](../Appendix1/index.html){.nav-link}
        -   [16.1. Getting Started Programming in
            C](../Appendix1/getting_started.html){.nav-link}
        -   [16.2. Input/Output (printf and
            scanf)](../Appendix1/input_output.html){.nav-link}
        -   [16.3. Conditionals and
            Loops](../Appendix1/conditionals.html){.nav-link}
        -   [16.4. Functions](../Appendix1/functions.html){.nav-link}
        -   [16.5. Arrays and
            Strings](../Appendix1/arrays_strings.html){.nav-link}
        -   [16.6. Structs](../Appendix1/structs.html){.nav-link}
        -   [16.7. Summary](../Appendix1/summary.html){.nav-link}
        -   [16.8. Exercises](../Appendix1/exercises.html){.nav-link}

-   -   [17. Appendix 2: Using Unix](../Appendix2/index.html){.nav-link}
        -   [17.1. Unix Command Line and the Unix File
            System](../Appendix2/cmdln_basics.html){.nav-link}
        -   [17.2. Man and the Unix
            Manual](../Appendix2/man.html){.nav-link}
        -   [17.3. Remote Access](../Appendix2/ssh_scp.html){.nav-link}
        -   [17.4. Unix Editors](../Appendix2/editors.html){.nav-link}
        -   [17.5. make and
            Makefiles](../Appendix2/makefiles.html){.nav-link}
        -   [17.6 Searching: grep and
            find](../Appendix2/grep.html){.nav-link}
        -   [17.7 File Permissions](../Appendix2/chmod.html){.nav-link}
        -   [17.8 Archiving and Compressing
            Files](../Appendix2/tar.html){.nav-link}
        -   [17.9 Process Control](../Appendix2/pskill.html){.nav-link}
        -   [17.10 Timing](../Appendix2/timing.html){.nav-link}
        -   [17.11 Command
            History](../Appendix2/history.html){.nav-link}
        -   [17.12 I/0
            Redirection](../Appendix2/ioredirect.html){.nav-link}
        -   [17.13 Pipes](../Appendix2/pipe.html){.nav-link}
        -   [17.14 Dot Files and
            .bashrc](../Appendix2/dotfiles.html){.nav-link}
        -   [17.15 Shell
            Programming](../Appendix2/shellprog.html){.nav-link}
        -   [17.16 Getting System
            Information](../Appendix2/sysinfo.html){.nav-link}



-   [Dive Into Systems](../index-2.html)
-   [1. By the C, the Beautiful C](index.html)
-   [1.1. Getting Started Programming in C](getting_started.html)
:::

::: content
::: sect1
## [](#_getting_started_programming_in_c){.anchor}1.1. Getting Started Programming in C {#_getting_started_programming_in_c}

::: sectionbody
::: paragraph
Let's start by looking at a \"hello world\" program that includes an
example of calling a function from the math library. In [Table
1](#TabPythonC) we compare the C version of this program to the Python
version. The C version might be put in a file named `hello.c` (`.c` is
the suffix convention for C source code files), whereas the Python
version might be in a file named `hello.py`.
:::

+-----------------------------------+-----------------------------------+
| Python version                    | C version                         |
| ([                                | ([hello.c](_attachments/hello.c)) |
| hello.py](_attachments/hello.py)) |                                   |
+===================================+===================================+
| ::: content                       | ::: content                       |
| ::: listingblock                  | ::: listingblock                  |
| ::: content                       | ::: content                       |
| ``` {.highlightjs .highlight}     | ``` {.highlightjs .highlight}     |
| '''                               | /*                                |
|                                   |     The Hello World Program in C  |
| The Hello World Program in Python |  */                               |
| '''                               |                                   |
|                                   | /* C math and I/O libraries */    |
| # Python math library             | #include <math.h>                 |
| from math import *                | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* main function definition: */   |
| # main function definition:       | int main(void) {                  |
| def main():                       |     //                            |
|                                   | statements end in a semicolon (;) |
|    # statements on their own line |     printf("Hello World\n");      |
|     print("Hello World")          |     pr                            |
|     p                             | intf("sqrt(4) is %f\n", sqrt(4)); |
| rint("sqrt(4) is %f" % (sqrt(4))) |                                   |
|                                   |     r                             |
| # call the main function:         | eturn 0;  // main returns value 0 |
| main()                            | }                                 |
| ```                               | ```                               |
| :::                               | :::                               |
| :::                               | :::                               |
| :::                               | :::                               |
+-----------------------------------+-----------------------------------+

: Table 1. Syntax Comparison of a Small Program in Python and C. Both
the [C version](_attachments/hello.c) and [Python
version](_attachments/hello.py) are available for download.

::: paragraph
Notice that both versions of this program have similar structure and
language constructs, albeit with different language syntax. In
particular:
:::

::: paragraph
**Comments:**
:::

::: ulist
-   In Python, multiline comments begin and end with `'''`, and
    single-line comments begin with `#`.

-   In C, multiline comments begin with `/*` and end with `*/`, and
    single-line comments begin with `//`.
:::

::: paragraph
**Importing library code:**
:::

::: ulist
-   In Python, libraries are included (imported) using `import`.

-   In C, libraries are included (imported) using `#include`. All
    `#include` statements appear at the top of the program, outside of
    function bodies.
:::

::: paragraph
**Blocks:**
:::

::: ulist
-   In Python, indentation denotes a block.

-   In C, blocks (for example, function, loop, and conditional bodies)
    start with `{` and end with `}`.
:::

::: paragraph
**The main function:**
:::

::: ulist
-   In Python, `def main():` defines the main function.

-   In C, `int main(void){ }` defines the main function. The `main`
    function returns a value of type `int`, which is C's name for
    specifying the signed integer type (signed integers are values like
    -3, 0, 1234). The `main` function returns the `int` value 0 to
    signify running to completion without error. The `void` means it
    doesn't expect to receive a parameter. Future sections show how
    `main` can take parameters to receive command line arguments.
:::

::: paragraph
**Statements:**
:::

::: ulist
-   In Python, each statement is on a separate line.

-   In C, each statement ends with a semicolon `;`. In C, statements
    must be within the body of some function (in `main` in this
    example).
:::

::: paragraph
**Output:**
:::

::: ulist
-   In Python, the `print` function prints a formatted string. Values
    for the placeholders in the format string follow a `%` symbol in a
    comma-separated list of values (for example, the value of `sqrt(4)`
    will be printed in place of the `%f` placeholder in the format
    string).

-   In C, the `printf` function prints a formatted string. Values for
    the placeholders in the format string are additional arguments
    separated by commas (for example, the value of `sqrt(4)` will be
    printed in place of the `%f` placeholder in the format string).
:::

::: paragraph
There are a few important differences to note in the C and Python
versions of this program:
:::

::: paragraph
**Indentation:** In C, indentation doesn't have meaning, but it's good
programming style to indent statements based on the nested level of
their containing block.
:::

::: paragraph
**Output:** C's `printf` function doesn't automatically print a newline
character at the end like Python's `print` function does. As a result, C
programmers need to explicitly specify a newline character (`\n`) in the
format string when a newline is desired in the output.
:::

::: paragraph
**`main` function:**
:::

::: ulist
-   A C program must have a function named `main`, and its return type
    must be `int`. This means that the `main` function returns a signed
    integer type value. Python programs don't need to name their main
    function `main`, but they often do by convention.

-   The C `main` function has an explicit `return` statement to return
    an `int` value (by convention, `main` should return `0` if the main
    function is successfully executed without errors).

-   A Python program needs to include an explicit call to its `main`
    function to run it when the program executes. In C, its `main`
    function is automatically called when the C program executes.
:::

::: sect2
### [](#_compiling_and_running_c_programs){.anchor}1.1.1. Compiling and Running C Programs {#_compiling_and_running_c_programs}

::: paragraph
Python is an interpreted programming language, which means that another
program, the Python interpreter, runs Python programs: the Python
interpreter acts like a virtual machine on which Python programs are
run. To run a Python program, the program source code (`hello.py`) is
given as input to the Python interpreter program that runs it. For
example (`$` is the Linux shell prompt):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ python hello.py
```
:::
:::

::: paragraph
The Python interpreter is a program that is in a form that can be run
directly on the underlying system (this form is called **binary
executable**) and takes as input the Python program that it runs
([Figure 1](#FigPythonExecution)).
:::

::: {#FigPythonExecution .imageblock .text-center}
::: content
![Interpreted execution of a Python
program.](_images/interpreted.png){width="350"}
:::

::: title
Figure 1. A Python program is directly executed by the Python
interpreter, which is a binary executable program that is run on the
underlying system (OS and hardware)
:::
:::

::: paragraph
To run a C program, it must first be translated into a form that a
computer system can directly execute. A C **compiler** is a program that
translates C source code into a **binary executable** form that the
computer hardware can directly execute. A binary executable consists of
a series of 0's and 1's in a well-defined format that a computer can
run.
:::

::: paragraph
For example, to run the C program `hello.c` on a Unix system, the C code
must first be compiled by a C compiler (for example, the [GNU C
compiler](https://gcc.gnu.org/), GCC) that produces a binary executable
(by default named `a.out`). The binary executable version of the program
can then be run directly on the system ([Figure 2](#FigCCompilation)):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc hello.c
$ ./a.out
```
:::
:::

::: paragraph
(Note that some C compilers might need to be explicitly told to link in
the math library: `-lm`):
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
$ gcc hello.c -lm
```
:::
:::

::: {#FigCCompilation .imageblock .text-center}
::: content
![C program text goes to the C compiler, which converts it into an
executable sequence of zeroes and ones. The format of the executable
sequence can be run by the underlying
system.](_images/compile.png){width="550"}
:::

::: title
Figure 2. The C compiler (gcc) builds C source code into a binary
executable file (a.out). The underlying system (OS and hardware)
directly executes the a.out file to run the program.
:::
:::

::: sect3
#### [](#_detailed_steps){.anchor}Detailed Steps {#_detailed_steps}

::: paragraph
In general, the following sequence describes the necessary steps for
editing, compiling, and running a C program on a Unix system:
:::

::: {.olist .arabic}
1.  Using a [text
    editor](https://www.cs.swarthmore.edu/help/editors.html) (for
    example, `vim`), write and save your C source code program in a file
    (e.g., `hello.c`):

    ::: listingblock
    ::: content
        $ vim hello.c
    :::
    :::

2.  Compile the source to an executable form, and then run it. The most
    basic syntax for compiling with `gcc` is:

    ::: listingblock
    ::: content
        $ gcc <input_source_file>
    :::
    :::
:::

::: paragraph
If compilation yields no errors, the compiler creates a binary
executable file named `a.out`. The compiler also allows you to specify
the name of the binary executable file to generate using the `-o` flag:
:::

::: listingblock
::: content
    $ gcc -o <output_executable_file> <input_source_file>
:::
:::

::: paragraph
For example, this command instructs `gcc` to compile `hello.c` into an
executable file named `hello`:
:::

::: listingblock
::: content
    $ gcc -o hello hello.c
:::
:::

::: paragraph
We can invoke the executable program using `./hello`:
:::

::: listingblock
::: content
    $ ./hello
:::
:::

::: paragraph
Any changes made to the C source code (the `hello.c` file) must be
recompiled with `gcc` to produce a new version of `hello`. If the
compiler detects any errors during compilation, the `./hello` file won't
be created/re-created (but beware, an older version of the file from a
previous successful compilation might still exist).
:::

::: paragraph
Often when compiling with `gcc`, you want to include several command
line options. For example, these options enable more compiler warnings
and build a binary executable with extra debugging information:
:::

::: listingblock
::: content
    $ gcc -Wall -g -o hello hello.c
:::
:::

::: paragraph
Because the `gcc` command line can be long, frequently the `make`
utility is used to simplify compiling C programs and for cleaning up
files created by `gcc`. [Using make and writing
Makefiles](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)
are important skills that you will develop as you build up experience
with C programming.
:::

::: paragraph
We cover compiling and linking with C library code in more detail at the
end of [Chapter
2](../C2-C_depth/advanced_libraries.html#_compilation_steps_){.page}.
:::
:::
:::

::: sect2
### [](#_variables_and_c_numeric_types){.anchor}1.1.2. Variables and C Numeric Types {#_variables_and_c_numeric_types}

::: paragraph
Like Python, C uses variables as named storage locations for holding
data. Thinking about the **scope** and **type** of program variables is
important to understand the semantics of what your program will do when
you run it. A variable's **scope** defines when the variable has meaning
(that is, where and when in your program it can be used) and its
lifetime (that is, it could persist for the entire run of a program or
only during a function activation). A variable's **type** defines the
range of values that it can represent and how those values will be
interpreted when performing operations on its data.
:::

::: paragraph
In C, all variables must be declared before they can be used. To declare
a variable, use the following syntax:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
type_name variable_name;
```
:::
:::

::: paragraph
A variable can have only a single **type**. The basic C types include
`char`, `int`, `float`, and `double`. By convention, C variables should
be declared at the beginning of their scope (at the top of a `{ }`
block), before any C statements in that scope.
:::

::: paragraph
Below is an example C code snippet that shows declarations and uses of
variables of some different types. We discuss types and operators in
more detail after the example.
:::

::: {#varsc .listingblock}
::: title
vars.c
:::

::: content
``` {.highlightjs .highlight}
{
    /* 1. Define variables in this block's scope at the top of the block. */

    int x; // declares x to be an int type variable and allocates space for it

    int i, j, k;  // can define multiple variables of the same type like this

    char letter;  // a char stores a single-byte integer value
                  // it is often used to store a single ASCII character
                  // value (the ASCII numeric encoding of a character)
                  // a char in C is a different type than a string in C

    float winpct; // winpct is declared to be a float type
    double pi;    // the double type is more precise than float

    /* 2. After defining all variables, you can use them in C statements. */

    x = 7;        // x stores 7 (initialize variables before using their value)
    k = x + 2;    // use x's value in an expression

    letter = 'A';        // a single quote is used for single character value
    letter = letter + 1; // letter stores 'B' (ASCII value one more than 'A')

    pi = 3.1415926;

    winpct = 11 / 2.0; // winpct gets 5.5, winpct is a float type
    j = 11 / 2;        // j gets 5: int division truncates after the decimal
    x = k % 2;         // % is C's mod operator, so x gets 9 mod 2 (1)
}
```
:::
:::

::: paragraph
Note the semicolons galore. Recall that C statements are delineated by
`;`, not line breaks --- C expects a semicolon after every statement.
You'll forget some, and `gcc` almost never informs you that you missed a
semicolon, even though that might be the only syntax error in your
program. In fact, often when you forget a semicolon, the compiler
indicates a syntax error on the line *after* the one with the missing
semicolon: the reason is that `gcc` interprets it as part of the
statement from the previous line. As you continue to program in C,
you'll learn to correlate `gcc` errors with the specific C syntax
mistakes that they describe.
:::
:::

::: sect2
### [](#_c_types){.anchor}1.1.3. C Types {#_c_types}

::: paragraph
C supports a small set of built-in data types, and it provides a few
ways in which programmers can construct basic collections of types
(arrays and structs). From these basic building blocks, a C programmer
can build complex data structures.
:::

::: paragraph
C defines a set of basic types for storing numeric values. Here are some
examples of numeric literal values of different C types:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
8     // the int value 8
3.4   // the double value 3.4
'h'   // the char value 'h' (its value is 104, the ASCII value of h)
```
:::
:::

::: paragraph
The C `char` type stores a numeric value. However, it's often used by
programmers to store the value of an ASCII character. A character
literal value is specified in C as a single character between single
quotes.
:::

::: paragraph
C doesn't support a string type, but programmers can create strings from
the `char` type and C's support for constructing arrays of values, which
we discuss in later sections. C does, however, support a way of
expressing string literal values in programs: a string literal is any
sequence of characters between double quotes. C programmers often pass
string literals as the format string argument to `printf`:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("this is a C string\n");
```
:::
:::

::: paragraph
Python supports strings, but it doesn't have a `char` type. In C, a
string and a `char` are two very different types, and they evaluate
differently. This difference is illustrated by contrasting a C string
literal that contains one character with a C `char` literal. For
example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
'h'  // this is a char literal value   (its value is 104, the ASCII value of h)
"h"  // this is a string literal value (its value is NOT 104, it is not a char)
```
:::
:::

::: paragraph
We discuss C strings and `char` variables in more detail in the
[Strings](../C2-C_depth/strings.html#_strings_and_the_string_library){.page}
section later in this chapter. Here, we'll mainly focus on C's numeric
types.
:::

::: sect3
#### [](#_c_numeric_types){.anchor}C Numeric Types {#_c_numeric_types}

::: paragraph
C supports several different types for storing numeric values. The types
differ in the format of the numeric values they represent. For example,
the `float` and `double` types can represent real values, `int`
represents signed integer values, and `unsigned int` represents unsigned
integer values. Real values are positive or negative values with a
decimal point, such as `-1.23` or `0.0056`. Signed integers store
positive, negative, or zero integer values, such as `-333`, `0`, or
`3456`. Unsigned integers store strictly nonnegative integer values,
such as `0` or `1234`.
:::

::: paragraph
C's numeric types also differ in the range and precision of the values
they can represent. The range or precision of a value depends on the
number of bytes associated with its type. Types with more bytes can
represent a larger range of values (for integer types), or
higher-precision values (for real types), than types with fewer bytes.
:::

::: paragraph
[Table 2](#TabNumericTypes) shows the number of storage bytes, the kind
of numeric values stored, and how to declare a variable for a variety of
common C numeric types (note that these are typical sizes --- the exact
number of bytes depends on the hardware architecture).
:::

+-----------------+-----------------+-----------------+-----------------+
| Type name       | Usual size      | Values stored   | How to declare  |
+=================+=================+=================+=================+
| `char`          | 1 byte          | integers        | `char x;`       |
+-----------------+-----------------+-----------------+-----------------+
| `short`         | 2 bytes         | signed integers | `short x;`      |
+-----------------+-----------------+-----------------+-----------------+
| `int`           | 4 bytes         | signed integers | `int x;`        |
+-----------------+-----------------+-----------------+-----------------+
| `long`          | 4 or 8 bytes    | signed integers | `long x;`       |
+-----------------+-----------------+-----------------+-----------------+
| `long long`     | 8 bytes         | signed integers | `long long x;`  |
+-----------------+-----------------+-----------------+-----------------+
| `float`         | 4 bytes         | signed real     | `float x;`      |
|                 |                 | numbers         |                 |
+-----------------+-----------------+-----------------+-----------------+
| `double`        | 8 bytes         | signed real     | `double x;`     |
|                 |                 | numbers         |                 |
+-----------------+-----------------+-----------------+-----------------+

: Table 2. C Numeric Types

::: paragraph
C also provides *unsigned* versions of the integer numeric types
(`char`, `short`, `int`, `long`, and `long long`). To declare a variable
as unsigned, add the keyword `unsigned` before the type name. For
example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
int x;           // x is a signed int variable
unsigned int y;  // y is an unsigned int variable
```
:::
:::

::: paragraph
The C standard doesn't specify whether the `char` type is signed or
unsigned. As a result, some implementations might implement `char` as
signed integer values and others as unsigned. It's good programming
practice to explicitly declare `unsigned char` if you want to use the
unsigned version of a `char` variable.
:::

::: paragraph
The exact number of bytes for each of the C types might vary from one
architecture to the next. The sizes in [Table 2](#TabNumericTypes) are
minimum (and common) sizes for each type. You can print the exact size
on a given machine using C's `sizeof` operator, which takes the name of
a type as an argument and evaluates to the number of bytes used to store
that type. For example:
:::

::: listingblock
::: content
``` {.highlightjs .highlight}
printf("number of bytes in an int: %lu\n", sizeof(int));
printf("number of bytes in a short: %lu\n", sizeof(short));
```
:::
:::

::: paragraph
The `sizeof` operator evaluates to an unsigned long value, so in the
call to `printf`, use the placeholder `%lu` to print its value. On most
architectures the output of these statements will be:
:::

::: listingblock
::: content
    number of bytes in an int: 4
    number of bytes in a short: 2
:::
:::
:::

::: sect3
#### [](#_arithmetic_operators){.anchor}Arithmetic Operators {#_arithmetic_operators}

::: paragraph
Arithmetic operators combine values of numeric types. The resulting type
of the operation is based on the types of the operands. For example, if
two `int` values are combined with an arithmetic operator, the resulting
type is also an integer.
:::

::: paragraph
C performs automatic type conversion when an operator combines operands
of two different types. For example, if an `int` operand is combined
with a `float` operand, the integer operand is first converted to its
floating-point equivalent before the operator is applied, and the type
of the operation's result is `float`.
:::

::: paragraph
The following arithmetic operators can be used on most numeric type
operands:
:::

::: ulist
-   add (`+`) and subtract (`-`)

-   multiply (`*`), divide (`/`), and mod (`%`):

    ::: paragraph
    The mod operator (`%`) can only take integer-type operands (`int`,
    `unsigned int`, `short`, and so on).
    :::

    ::: paragraph
    If both operands are `int` types, the divide operator (`/`) performs
    integer division (the resulting value is an `int`, truncating
    anything beyond the decimal point from the division operation). For
    example `8/3` evaluates to `2`.
    :::

    ::: paragraph
    If one or both of the operands are `float` (or `double`), `/`
    performs real division and evaluates to a `float` (or `double`)
    result. For example, `8 / 3.0` evaluates to approximately
    `2.666667`.
    :::

-   assignment (`=`):

    ::: listingblock
    ::: content
        variable = value of expression;  // e.g., x = 3 + 4;
    :::
    :::

-   assignment with update (`+=`, `-=`, `*=`, `/=`, and `%=`):

    ::: listingblock
    ::: content
        variable op= expression;  // e.g., x += 3; is shorthand for x = x + 3;
    :::
    :::
:::

::: ulist
-   increment (`++`) and decrement (`--`):

    ::: listingblock
    ::: content
        variable++;  // e.g., x++; assigns to x the value of x + 1
    :::
    :::
:::

::: {.admonitionblock .warning}
+-----------------------------------+-----------------------------------+
|                                   | ::: title                         |
|                                   | Pre- vs. Post-increment           |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The operators `++variable` and    |
|                                   | `variable++` are both valid, but  |
|                                   | they're evaluated slightly        |
|                                   | differently:                      |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: ulist                         |
|                                   | -   `++x`: increment `x` first,   |
|                                   |     then use its value.           |
|                                   |                                   |
|                                   | -   `x++`: use \`x's value first, |
|                                   |     then increment it.            |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In many cases, it doesn't matter  |
|                                   | which you use because the value   |
|                                   | of the incremented or decremented |
|                                   | variable isn't being used in the  |
|                                   | statement. For example, these two |
|                                   | statements are equivalent         |
|                                   | (although the first is the most   |
|                                   | commonly used syntax for this     |
|                                   | statement):                       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | x++;                              |
|                                   | ++x;                              |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | In some cases, the context        |
|                                   | affects the outcome (when the     |
|                                   | value of the incremented or       |
|                                   | decremented variable *is* being   |
|                                   | used in the statement). For       |
|                                   | example:                          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | x = 6;                            |
|                                   | y = ++x +                         |
|                                   | 2;  // y is assigned 9: increment |
|                                   |  x first, then evaluate x + 2 (9) |
|                                   |                                   |
|                                   | x = 6;                            |
|                                   | y = x++ +                         |
|                                   | 2;  // y is assigned 8: evaluate  |
|                                   | x + 2 first (8), then increment x |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Code like the preceding example   |
|                                   | that uses an arithmetic           |
|                                   | expression with an increment      |
|                                   | operator is often hard to read,   |
|                                   | and it's easy to get wrong. As a  |
|                                   | result, it's generally best to    |
|                                   | avoid writing code like this;     |
|                                   | instead, write separate           |
|                                   | statements for exactly the order  |
|                                   | you want. For example, if you     |
|                                   | want to first increment `x` and   |
|                                   | then assign `x + 1` to `y`, just  |
|                                   | write it as two separate          |
|                                   | statements.                       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | Instead of writing this:          |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | y = ++x + 1;                      |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | write it as two separate          |
|                                   | statements:                       |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: listingblock                  |
|                                   | ::: content                       |
|                                   | ``` {.highlightjs .highlight}     |
|                                   | x++;                              |
|                                   | y = x + 1;                        |
|                                   | ```                               |
|                                   | :::                               |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+
:::
:::
:::
:::
:::

::: toc-menu
:::
:::
:::
:::

Copyright (C) 2020 Dive into Systems, LLC.

*Dive into Systems,* is licensed under the Creative Commons
[Attribution-NonCommercial-NoDerivatives 4.0
International](https://creativecommons.org/licenses/by-nc-nd/4.0/) (CC
BY-NC-ND 4.0).
