<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions in Assembly - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html" class="active"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="75-functions-in-assembly"><a class="header" href="#75-functions-in-assembly">7.5. Functions in Assembly</a></h2>
<p>Trong phần trước, chúng ta đã lần theo các hàm đơn giản trong assembly.<br />
Trong phần này, chúng ta sẽ thảo luận về sự tương tác giữa nhiều hàm trong assembly trong bối cảnh của một chương trình lớn hơn. Chúng ta cũng sẽ giới thiệu một số lệnh mới liên quan đến việc quản lý hàm.</p>
<p>Hãy bắt đầu bằng việc ôn lại cách <strong>call stack</strong> được quản lý. Hãy nhớ rằng <code>%rsp</code> là <strong>stack pointer</strong> và luôn trỏ tới đỉnh của stack. Thanh ghi <code>%rbp</code> đại diện cho <strong>base pointer</strong> (còn gọi là <strong>frame pointer</strong>) và trỏ tới đáy của <strong>stack frame</strong> hiện tại. <strong>Stack frame</strong> (còn gọi là <strong>activation frame</strong> hoặc <strong>activation record</strong>) là phần của stack được cấp phát cho một lần gọi hàm. Hàm đang thực thi luôn nằm ở đỉnh stack, và stack frame của nó được gọi là <strong>active frame</strong>. Active frame được giới hạn bởi stack pointer (ở đỉnh stack) và frame pointer (ở đáy frame). <strong>Activation record</strong> thường chứa các biến cục bộ của hàm.</p>
<p>Hình 1 minh họa các stack frame của <code>main</code> và một hàm mà nó gọi tên là <code>fname</code>. Chúng ta sẽ gọi hàm <code>main</code> là hàm <em>caller</em> và <code>fname</code> là hàm <em>callee</em>.</p>
<p><img src="_images/stackFrame.png" alt="an illustration of stack frames" /></p>
<p><strong>Hình 1.</strong> Quản lý stack frame</p>
<p>Trong Hình 1, active frame hiện tại thuộc về hàm callee (<code>fname</code>). Vùng nhớ giữa stack pointer và frame pointer được dùng cho các biến cục bộ. Stack pointer thay đổi khi các giá trị cục bộ được <strong>push</strong> và <strong>pop</strong> khỏi stack. Ngược lại, frame pointer hầu như không thay đổi, luôn trỏ tới phần bắt đầu (đáy) của stack frame hiện tại. Vì vậy, các compiler như GCC thường tham chiếu các giá trị trên stack tương đối so với frame pointer. Trong Hình 1, active frame được giới hạn phía dưới bởi base pointer của <code>fname</code>, là địa chỉ stack 0x418. Giá trị lưu tại địa chỉ 0x418 là giá trị <code>%rbp</code> đã “lưu” (0x42c), bản thân nó là một địa chỉ cho biết đáy của activation frame của hàm <code>main</code>. Đỉnh của activation frame của <code>main</code> được giới hạn bởi <strong>return address</strong>, cho biết vị trí trong hàm <code>main</code> mà chương trình sẽ tiếp tục thực thi khi hàm callee <code>fname</code> kết thúc.</p>
<blockquote>
<p><strong>Return address</strong> trỏ tới bộ nhớ của code segment, không phải stack memory.<br />
Hãy nhớ rằng vùng call stack (stack memory) của một chương trình khác với vùng code (code segment memory). Trong khi <code>%rbp</code> và <code>%rsp</code> trỏ tới địa chỉ trong stack memory, <code>%rip</code> trỏ tới một địa chỉ trong <em>code segment memory</em>. Nói cách khác, return address là một địa chỉ trong code segment memory, không phải stack memory:</p>
<p><img src="_images/memparts.png" alt="The parts of a program's address space." /><br />
<em>Hình 2. Các phần của không gian địa chỉ của một chương trình</em></p>
</blockquote>
<p><strong>Bảng 1.</strong> Một số lệnh quản lý hàm thông dụng</p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Translation</th></tr></thead><tbody>
<tr><td><code>leaveq</code></td><td>Chuẩn bị stack để thoát khỏi hàm. Tương đương với:<br><code>mov %rbp, %rsp</code><br><code>pop %rbp</code></td></tr>
<tr><td><code>callq addr &lt;fname&gt;</code></td><td>Chuyển active frame sang hàm callee. Tương đương với:<br><code>push %rip</code><br><code>mov addr, %rip</code></td></tr>
<tr><td><code>retq</code></td><td>Khôi phục active frame về hàm caller. Tương đương với:<br><code>pop %rip</code></td></tr>
</tbody></table>
</div>
<p>Ví dụ, lệnh <code>leaveq</code> là một dạng viết tắt mà compiler dùng để khôi phục stack pointer và frame pointer khi chuẩn bị thoát khỏi hàm. Khi hàm callee kết thúc, <code>leaveq</code> đảm bảo frame pointer được <strong>khôi phục</strong> về giá trị trước đó.</p>
<p>Các lệnh <code>callq</code> và <code>retq</code> đóng vai trò quan trọng trong quá trình một hàm gọi hàm khác. Cả hai lệnh này đều thay đổi <strong>instruction pointer</strong> (<code>%rip</code>). Khi hàm caller thực thi lệnh <code>callq</code>, giá trị hiện tại của <code>%rip</code> sẽ được lưu trên stack để làm <strong>return address</strong> — tức địa chỉ trong chương trình mà caller sẽ tiếp tục thực thi khi callee kết thúc. Lệnh <code>callq</code> cũng thay thế giá trị <code>%rip</code> bằng địa chỉ của hàm callee.</p>
<p>Lệnh <code>retq</code> khôi phục giá trị <code>%rip</code> từ giá trị đã lưu trên stack, đảm bảo chương trình tiếp tục thực thi tại địa chỉ được chỉ định trong hàm caller. Bất kỳ giá trị trả về nào của callee sẽ được lưu trong <code>%rax</code> hoặc một trong các <strong>component register</strong> của nó (ví dụ <code>%eax</code>). Lệnh <code>retq</code> thường là lệnh cuối cùng được thực thi trong bất kỳ hàm nào.</p>
<h3 id="751-function-parameters"><a class="header" href="#751-function-parameters">7.5.1. Function Parameters</a></h3>
<p>Không giống IA32, các tham số của hàm trong x86-64 thường được nạp sẵn vào các thanh ghi trước khi gọi hàm. <strong>Bảng 2</strong> liệt kê các tham số của hàm và thanh ghi (nếu có) mà chúng được nạp vào trước khi gọi hàm.</p>
<p><strong>Bảng 2.</strong> Vị trí lưu trữ tham số hàm</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Location</th></tr></thead><tbody>
<tr><td>Parameter 1</td><td>%rdi</td></tr>
<tr><td>Parameter 2</td><td>%rsi</td></tr>
<tr><td>Parameter 3</td><td>%rdx</td></tr>
<tr><td>Parameter 4</td><td>%rcx</td></tr>
<tr><td>Parameter 5</td><td>%r8</td></tr>
<tr><td>Parameter 6</td><td>%r9</td></tr>
<tr><td>Parameter 7+</td><td>trên call stack</td></tr>
</tbody></table>
</div>
<p>Sáu tham số đầu tiên của hàm lần lượt được nạp vào các thanh ghi <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, và <code>%r9</code>. Bất kỳ tham số bổ sung nào sẽ được nạp lần lượt vào call stack dựa trên kích thước của chúng (dịch 4 byte cho dữ liệu 32-bit, dịch 8 byte cho dữ liệu 64-bit).</p>
<h3 id="752-tracing-through-an-example"><a class="header" href="#752-tracing-through-an-example">7.5.2. Tracing Through an Example</a></h3>
<p>Dựa trên kiến thức về quản lý hàm, hãy lần theo ví dụ mã nguồn đã được giới thiệu ở đầu chương này. Lưu ý rằng từ khóa <code>void</code> được thêm vào danh sách tham số của mỗi định nghĩa hàm để chỉ rõ rằng các hàm này không nhận đối số nào. Thay đổi này không làm thay đổi kết quả của chương trình; tuy nhiên, nó giúp đơn giản hóa code assembly tương ứng.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int assign(void) {
    int y = 40;
    return y;
}

int adder(void) {
    int a;
    return a + 2;
}

int main(void) {
    int x;
    assign();
    x = adder();
    printf(&quot;x is: %d\n&quot;, x);
    return 0;
}
</code></pre>
<p>Chúng ta biên dịch đoạn code này với lệnh:</p>
<pre><code>gcc -o prog prog.c
</code></pre>
<p>và sử dụng:</p>
<pre><code>objdump -d
</code></pre>
<p>để xem code assembly bên dưới. Lệnh thứ hai sẽ xuất ra một tệp khá lớn chứa nhiều thông tin không cần thiết. Hãy dùng <code>less</code> và chức năng tìm kiếm để trích xuất các hàm <code>adder</code>, <code>assign</code> và <code>main</code>:</p>
<pre><code class="language-assembly">0000000000400526 &lt;assign&gt;:
  400526:       55                      push   %rbp
  400527:       48 89 e5                mov    %rsp,%rbp
  40052a:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%rbp)
  400531:       8b 45 fc                mov    -0x4(%rbp),%eax
  400534:       5d                      pop    %rbp
  400535:       c3                      retq

0000000000400536 &lt;adder&gt;:
  400536:       55                      push   %rbp
  400537:       48 89 e5                mov    %rsp,%rbp
  40053a:       8b 45 fc                mov    -0x4(%rbp),%eax
  40053d:       83 c0 02                add    $0x2,%eax
  400540:       5d                      pop    %rbp
  400541:       c3                      retq

0000000000400542 &lt;main&gt;:
  400542:       55                      push   %rbp
  400543:       48 89 e5                mov    %rsp,%rbp
  400546:       48 83 ec 10             sub    $0x10,%rsp
  40054a:       e8 e3 ff ff ff          callq  400526 &lt;assign&gt;
  40054f:       e8 d2 ff ff ff          callq  400536 &lt;adder&gt;
  400554:       89 45 fc                mov    %eax,-0x4(%rbp)
  400557:       8b 45 fc                mov    -0x4(%rbp),%eax
  40055a:       89 c6                   mov    %eax,%esi
  40055c:       bf 04 06 40 00          mov    $0x400604,%edi
  400561:       b8 00 00 00 00          mov    $0x0,%eax
  400566:       e8 95 fe ff ff          callq  400400 &lt;printf@plt&gt;
  40056b:       b8 00 00 00 00          mov    $0x0,%eax
  400570:       c9                      leaveq
  400571:       c3                      retq
</code></pre>
<p>Mỗi hàm bắt đầu bằng một <strong>symbolic label</strong> (nhãn ký hiệu) tương ứng với tên được khai báo của nó trong chương trình. Ví dụ, <code>&lt;main&gt;:</code> là symbolic label cho hàm <code>main</code>. Địa chỉ của một nhãn hàm cũng chính là địa chỉ của lệnh đầu tiên trong hàm đó. Để tiết kiệm không gian trong các hình minh họa bên dưới, chúng ta rút gọn địa chỉ xuống 12 bit thấp. Vì vậy, địa chỉ chương trình <code>0x400542</code> sẽ được hiển thị thành <code>0x542</code>.</p>
<h3 id="753-tracing-through-main"><a class="header" href="#753-tracing-through-main">7.5.3. Tracing Through main</a></h3>
<p><strong>Hình 3</strong> cho thấy execution stack ngay trước khi thực thi <code>main</code>.</p>
<p><img src="_images/procedures/Slide1.png" alt="slide1" /></p>
<p><strong>Hình 3.</strong> Trạng thái ban đầu của các thanh ghi CPU và call stack trước khi thực thi hàm <code>main</code></p>
<p>Hãy nhớ rằng stack phát triển về phía các địa chỉ thấp hơn. Trong ví dụ này, <code>%rbp</code> ban đầu là địa chỉ stack <code>0x830</code>, và <code>%rsp</code> ban đầu là địa chỉ stack <code>0xd48</code>. Cả hai giá trị này được giả định cho ví dụ.</p>
<p>Vì các hàm trong ví dụ trước sử dụng dữ liệu kiểu số nguyên, chúng ta làm nổi bật các <strong>component register</strong> <code>%eax</code> và <code>%edi</code>, vốn ban đầu chứa giá trị rác. Mũi tên đỏ (góc trên bên trái) biểu thị lệnh đang được thực thi. Ban đầu, <code>%rip</code> chứa địa chỉ <code>0x542</code>, là địa chỉ trong bộ nhớ chương trình của dòng đầu tiên trong hàm <code>main</code>.</p>
<p><img src="_images/procedures/Slide2.png" alt="slide2" /></p>
<p>Lệnh đầu tiên lưu giá trị hiện tại của <code>%rbp</code> bằng cách <strong>push</strong> <code>0x830</code> lên stack. Vì stack phát triển về phía địa chỉ thấp hơn, stack pointer <code>%rsp</code> được cập nhật thành <code>0xd40</code>, tức nhỏ hơn <code>0xd48</code> 8 byte. <code>%rip</code> tăng tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide3.png" alt="slide3" /></p>
<p>Lệnh tiếp theo (<code>mov %rsp, %rbp</code>) cập nhật giá trị <code>%rbp</code> thành bằng <code>%rsp</code>. Frame pointer (<code>%rbp</code>) giờ trỏ tới đầu stack frame của hàm <code>main</code>. <code>%rip</code> tăng tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide4.png" alt="slide4" /></p>
<p>Lệnh <code>sub</code> trừ <code>0x10</code> khỏi địa chỉ của stack pointer, về cơ bản làm stack “mở rộng” thêm 16 byte, được biểu diễn bằng hai ô nhớ 8 byte trên stack. <code>%rsp</code> giờ có giá trị mới là <code>0xd30</code>. <code>%rip</code> tăng tới lệnh tiếp theo.</p>
<p><img src="_images/procedures/Slide5.png" alt="slide5" /></p>
<p>Lệnh <code>callq &lt;assign&gt;</code> <strong>push</strong> giá trị trong <code>%rip</code> (địa chỉ của lệnh <em>tiếp theo</em> sẽ thực thi) lên stack. Vì lệnh tiếp theo sau <code>callq &lt;assign&gt;</code> có địa chỉ <code>0x55f</code>, giá trị này được push lên stack làm <strong>return address</strong>. Hãy nhớ rằng return address cho biết địa chỉ chương trình sẽ tiếp tục thực thi khi quay lại <code>main</code>.</p>
<p>Tiếp đó, lệnh <code>callq</code> đưa địa chỉ của hàm <code>assign</code> (<code>0x526</code>) vào <code>%rip</code>, báo hiệu chương trình sẽ tiếp tục thực thi trong hàm callee <code>assign</code> thay vì lệnh tiếp theo trong <code>main</code>.</p>
<p><img src="_images/procedures/Slide6.png" alt="slide6" /></p>
<p>Hai lệnh đầu tiên trong hàm <code>assign</code> là phần “dọn dẹp sổ sách” (book-keeping) mà mọi hàm đều thực hiện. Lệnh đầu tiên <strong>push</strong> giá trị trong <code>%rbp</code> (địa chỉ <code>0xd40</code>) lên stack. Hãy nhớ rằng địa chỉ này trỏ tới đầu stack frame của <code>main</code>. <code>%rip</code> tăng tới lệnh thứ hai trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide7.png" alt="slide7" /></p>
<p>Lệnh tiếp theo (<code>mov %rsp, %rbp</code>) cập nhật <code>%rbp</code> để trỏ tới đỉnh stack, đánh dấu đầu stack frame của <code>assign</code>. <code>%rip</code> tăng tới lệnh tiếp theo trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide8.png" alt="slide8" /></p>
<p>Lệnh <code>mov</code> tại địa chỉ <code>0x52a</code> đưa giá trị <code>$0x28</code> (tức 40) vào stack tại địa chỉ <code>-0x4(%rbp)</code>, tức 4 byte phía trên frame pointer. Frame pointer thường được dùng để tham chiếu các vị trí trên stack. Lưu ý rằng thao tác này <strong>không</strong> thay đổi <code>%rsp</code> — stack pointer vẫn trỏ tới <code>0xd20</code>. <code>%rip</code> tăng tới lệnh tiếp theo trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide9.png" alt="slide9" /></p>
<p>Lệnh <code>mov</code> tại địa chỉ <code>0x531</code> đưa giá trị <code>$0x28</code> vào <code>%eax</code>, thanh ghi chứa giá trị trả về của hàm. <code>%rip</code> tăng tới lệnh <code>pop</code> trong <code>assign</code>.</p>
<p><img src="_images/procedures/Slide10.png" alt="slide10" /></p>
<p>Lúc này, hàm <code>assign</code> gần như đã hoàn tất. Lệnh tiếp theo là <code>pop %rbp</code>, khôi phục <code>%rbp</code> về giá trị trước đó (<code>0xd40</code>). Vì <code>pop</code> thay đổi stack pointer, <code>%rsp</code> được cập nhật thành <code>0xd28</code>.</p>
<p><img src="_images/procedures/Slide11.png" alt="slide11" /></p>
<p>Lệnh cuối cùng trong <code>assign</code> là <code>retq</code>. Khi <code>retq</code> thực thi, return address được <strong>pop</strong> khỏi stack vào <code>%rip</code>. Trong ví dụ này, <code>%rip</code> giờ trỏ tới lệnh <code>callq</code> trong <code>main</code> tại địa chỉ <code>0x55f</code>.</p>
<p>Một số điểm quan trọng cần lưu ý:</p>
<ul>
<li>Stack pointer và frame pointer đã được khôi phục về giá trị trước khi gọi <code>assign</code>, cho thấy stack frame của <code>main</code> lại trở thành active frame.</li>
<li>Các giá trị cũ trên stack từ stack frame trước <strong>không</strong> bị xóa. Chúng vẫn tồn tại trên call stack.</li>
</ul>
<p><img src="_images/procedures/Slide12.png" alt="slide12" /></p>
<p>Quay lại <code>main</code>, lệnh gọi <code>adder</code> <strong>ghi đè</strong> return address cũ trên stack bằng return address mới (<code>0x554</code>). Return address này trỏ tới lệnh sẽ thực thi sau khi <code>adder</code> trả về, tức <code>mov %eax, -0x4(%rbp)</code>. <code>%rip</code> được cập nhật trỏ tới lệnh đầu tiên trong <code>adder</code> tại địa chỉ <code>0x536</code>.</p>
<p><img src="_images/procedures/Slide13.png" alt="slide13" /></p>
<p>Lệnh đầu tiên trong <code>adder</code> lưu frame pointer của caller (<code>%rbp</code> của <code>main</code>) lên stack.</p>
<p><img src="_images/procedures/Slide14.png" alt="slide14" /></p>
<p>Lệnh tiếp theo cập nhật <code>%rbp</code> bằng giá trị hiện tại của <code>%rsp</code> (<code>0xd20</code>). Hai lệnh này thiết lập đầu stack frame cho <code>adder</code>.</p>
<p><img src="_images/procedures/Slide15.png" alt="slide15" /></p>
<p>Hãy chú ý tới lệnh tiếp theo. Hãy nhớ rằng <code>$0x28</code> đã được đặt trên stack khi gọi <code>assign</code>. Lệnh <code>mov $-0x4(%rbp), %eax</code> di chuyển <strong>giá trị cũ</strong> trên stack vào <code>%eax</code>! Điều này sẽ không xảy ra nếu lập trình viên đã khởi tạo biến <code>a</code> trong <code>adder</code>.</p>
<p><img src="_images/procedures/Slide16.png" alt="slide16" /></p>
<p>Lệnh <code>add</code> tại địa chỉ <code>0x53d</code> cộng 2 vào <code>%eax</code>. Hãy nhớ rằng khi trả về một số nguyên 32-bit, x86-64 sử dụng <code>%eax</code> thay vì <code>%rax</code>. Hai lệnh cuối này tương đương với đoạn code trong <code>adder</code>:</p>
<pre><code class="language-c">int a;
return a + 2;
</code></pre>
<p><img src="_images/procedures/Slide17.png" alt="slide20" /></p>
<p>Sau khi <code>pop</code> thực thi, frame pointer lại trỏ tới đầu stack frame của <code>main</code> (<code>0xd40</code>). Stack pointer lúc này chứa địa chỉ <code>0xd28</code>.</p>
<p><img src="_images/procedures/Slide18.png" alt="slide18" /></p>
<p>Việc thực thi lệnh <code>retq</code> sẽ <strong>pop</strong> địa chỉ trả về (return address) ra khỏi stack, khôi phục <strong>instruction pointer</strong> về <code>0x554</code>, tức địa chỉ của lệnh tiếp theo sẽ được thực thi trong <code>main</code>. Địa chỉ chứa trong <code>%rsp</code> lúc này là <code>0xd30</code>.</p>
<p><img src="_images/procedures/Slide19.png" alt="slide19" /></p>
<p>Quay lại <code>main</code>, lệnh <code>mov %eax, -0x4(%rbp)</code> đặt giá trị trong <code>%eax</code> vào vị trí bộ nhớ cách <code>%rbp</code> 4 byte, tức địa chỉ <code>0xd3c</code>. Lệnh tiếp theo lại đưa giá trị này trở lại vào thanh ghi <code>%eax</code>.</p>
<p><img src="_images/procedures/Slide21.png" alt="slide21" /></p>
<p>Bỏ qua một vài bước, lệnh <code>mov</code> tại địa chỉ <code>0x55a</code> sao chép giá trị trong <code>%eax</code> (tức <code>0x2A</code>) vào thanh ghi <code>%esi</code>, là <strong>component register</strong> 32-bit của <code>%rsi</code> và thường lưu tham số thứ hai của một hàm.</p>
<p><img src="_images/procedures/Slide22.png" alt="slide22" /></p>
<p>Lệnh tiếp theo (<code>mov $0x400604, %edi</code>) sao chép một giá trị hằng (một địa chỉ trong <strong>code segment memory</strong>) vào thanh ghi <code>%edi</code>. Hãy nhớ rằng <code>%edi</code> là <strong>component register</strong> 32-bit của <code>%rdi</code>, thường lưu tham số thứ nhất của một hàm. Địa chỉ <code>0x400604</code> trong code segment là địa chỉ bắt đầu của chuỗi <code>&quot;x is %d\n&quot;</code>.</p>
<p><img src="_images/procedures/Slide23.png" alt="slide23" /></p>
<p>Lệnh tiếp theo đặt lại giá trị của <code>%eax</code> thành 0. Instruction pointer lúc này trỏ tới lời gọi hàm <code>printf</code> (được ký hiệu là <code>&lt;printf@plt&gt;</code>).</p>
<p><img src="_images/procedures/Slide24.png" alt="slide24" /></p>
<p>Lệnh tiếp theo gọi hàm <code>printf</code>. Để ngắn gọn, chúng ta sẽ không lần theo chi tiết hàm <code>printf</code> (thuộc <code>stdio.h</code>). Tuy nhiên, theo trang hướng dẫn (<code>man -s3 printf</code>), <code>printf</code> có dạng:</p>
<pre><code>int printf(const char * format, ...)
</code></pre>
<p>Nói cách khác, tham số đầu tiên là con trỏ tới chuỗi định dạng, và các tham số tiếp theo là các giá trị sẽ được chèn vào định dạng đó. Các lệnh từ địa chỉ <code>0x55a</code> đến <code>0x566</code> tương ứng với dòng lệnh trong hàm <code>main</code>:</p>
<pre><code class="language-c">printf(&quot;x is %d\n&quot;, x);
</code></pre>
<p>Khi hàm <code>printf</code> được gọi:</p>
<ul>
<li>Một <strong>return address</strong> chỉ lệnh sẽ thực thi sau khi <code>printf</code> kết thúc được <strong>push</strong> lên stack.</li>
<li>Giá trị của <code>%rbp</code> được <strong>push</strong> lên stack, và <code>%rbp</code> được cập nhật để trỏ tới đỉnh stack, đánh dấu bắt đầu stack frame của <code>printf</code>.</li>
</ul>
<p>Tại một thời điểm nào đó, <code>printf</code> sẽ tham chiếu tới các đối số của nó: chuỗi <code>&quot;x is %d\n&quot;</code> và giá trị <code>0x2A</code>. Tham số thứ nhất được lưu trong <code>%edi</code>, tham số thứ hai được lưu trong <code>%esi</code>. Return address nằm ngay bên dưới <code>%rbp</code> tại vị trí <code>%rbp+8</code>.</p>
<p>Với bất kỳ hàm nào có <em>n</em> tham số, GCC sẽ đặt 6 tham số đầu tiên vào các thanh ghi (như trong Bảng 2), và các tham số còn lại sẽ được đặt trên stack <em>bên dưới</em> return address.</p>
<p>Sau khi gọi <code>printf</code>, giá trị <code>0x2A</code> sẽ được in ra cho người dùng ở dạng số nguyên. Do đó, giá trị <strong>42</strong> được in ra màn hình.</p>
<p><img src="_images/procedures/Slide25.png" alt="slide25" /></p>
<p>Sau khi gọi <code>printf</code>, một vài lệnh cuối sẽ dọn dẹp stack và chuẩn bị thoát sạch sẽ khỏi hàm <code>main</code>. Đầu tiên, lệnh <code>mov</code> tại địa chỉ <code>0x56b</code> đảm bảo rằng giá trị 0 nằm trong thanh ghi trả về (vì việc cuối cùng <code>main</code> làm là <code>return 0</code>).</p>
<p><img src="_images/procedures/Slide26.png" alt="slide26" /></p>
<p>Lệnh <code>leaveq</code> chuẩn bị stack để trả về từ lời gọi hàm. Hãy nhớ rằng <code>leaveq</code> tương đương với cặp lệnh:</p>
<pre><code>mov %rbp, %rsp
pop %rbp
</code></pre>
<p>Nói cách khác, CPU ghi đè stack pointer bằng frame pointer. Trong ví dụ này, stack pointer được cập nhật từ <code>0xd30</code> thành <code>0xd40</code>. Tiếp đó, CPU thực thi <code>pop %rbp</code>, lấy giá trị tại <code>0xd40</code> (trong ví dụ này là địa chỉ <code>0x830</code>) và đặt vào <code>%rbp</code>. Sau khi <code>leaveq</code> thực thi, stack pointer và frame pointer trở lại giá trị ban đầu trước khi <code>main</code> chạy.</p>
<p>Lệnh cuối cùng được thực thi là <code>retq</code>. Với giá trị <code>0x0</code> trong thanh ghi trả về <code>%eax</code>, chương trình trả về 0, báo hiệu kết thúc thành công.</p>
<p>Nếu bạn đã đọc kỹ phần này, bạn sẽ hiểu vì sao chương trình in ra giá trị <strong>42</strong>. Về bản chất, chương trình đã vô tình sử dụng các giá trị cũ trên stack, khiến nó hoạt động theo cách mà ta không ngờ tới. Ví dụ này khá vô hại; tuy nhiên, ở các phần sau, chúng ta sẽ thảo luận cách tin tặc lợi dụng lời gọi hàm để khiến chương trình hoạt động sai lệch theo những cách thực sự nguy hiểm.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C7-x86_64/loops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C7-x86_64/recursion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C7-x86_64/loops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C7-x86_64/recursion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
