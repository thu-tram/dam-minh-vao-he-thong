<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Matrices in Assembly - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html" class="active"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="78-ma-trận-matrices"><a class="header" href="#78-ma-trận-matrices">7.8. Ma trận (Matrices)</a></h2>
<p><strong>Ma trận</strong> là một mảng hai chiều. Trong C, một ma trận có thể được cấp phát tĩnh dưới dạng mảng hai chiều (<code>M[n][m]</code>), được cấp phát động chỉ với một lần gọi <code>malloc</code>, hoặc được cấp phát động dưới dạng <strong>mảng của các mảng</strong>.<br />
Hãy xét cách triển khai <strong>mảng của các mảng</strong>. Mảng thứ nhất chứa <code>n</code> phần tử (<code>M[n]</code>), và mỗi phần tử <code>M[i]</code> trong ma trận của chúng ta chứa một mảng gồm <code>m</code> phần tử. Các đoạn code sau đây lần lượt khai báo các ma trận kích thước 4 × 3:</p>
<pre><code class="language-c">// ma trận cấp phát tĩnh (trên stack)
int M1[4][3];

// ma trận cấp phát động (dễ lập trình, cấp phát trên heap)
int **M2, i;
M2 = malloc(4 * sizeof(int*));
for (i = 0; i &lt; 4; i++) {
    M2[i] = malloc(3 * sizeof(int));
}
</code></pre>
<p>Trong trường hợp ma trận được cấp phát động, mảng chính chứa một mảng liên tiếp các con trỏ kiểu <code>int</code>. Mỗi con trỏ này trỏ tới một mảng khác trong bộ nhớ. <strong>Hình 1</strong> minh họa cách chúng ta thường hình dung hai loại ma trận này.</p>
<p><img src="_images/matrices.png" alt="matrices" /><br />
<strong>Hình 1.</strong> Minh họa ma trận cấp phát tĩnh (M1) và ma trận cấp phát động (M2) kích thước 3×4</p>
<p>Với cả hai khai báo ma trận này, phần tử (<em>i</em>, <em>j</em>) có thể được truy cập bằng cú pháp chỉ số kép <code>M[i][j]</code>, trong đó <code>M</code> là <code>M1</code> hoặc <code>M2</code>. Tuy nhiên, các ma trận này được tổ chức khác nhau trong bộ nhớ.<br />
Mặc dù cả hai đều lưu các phần tử trong mảng chính một cách liên tiếp trong bộ nhớ, ma trận cấp phát tĩnh còn lưu <strong>toàn bộ các hàng</strong> liên tiếp nhau trong bộ nhớ, như minh họa ở <strong>Hình 2</strong>.</p>
<p><img src="_images/matrixArray.png" alt="matrixArray" /><br />
<strong>Hình 2.</strong> Cách sắp xếp bộ nhớ của ma trận M1 theo thứ tự hàng (row-major order)</p>
<p>Sự liên tiếp này <strong>không được đảm bảo</strong> đối với <code>M2</code>. <a href="../C2-C_depth/arrays.html#_two_dimensional_array_memory_layout">Hãy nhớ rằng</a> để cấp phát liên tiếp một ma trận <em>n</em> × <em>m</em> trên heap, chúng ta nên dùng một lần gọi <code>malloc</code> để cấp phát <em>n</em> × <em>m</em> phần tử:</p>
<pre><code class="language-c">// ma trận động (cấp phát trên heap, cách tiết kiệm bộ nhớ)
#define ROWS 4
#define COLS 3
int *M3;
M3 = malloc(ROWS * COLS * sizeof(int));
</code></pre>
<p>Với khai báo <code>M3</code>, phần tử (<em>i</em>, <em>j</em>) <strong>không thể</strong> truy cập bằng cú pháp <code>M[i][j]</code>. Thay vào đó, chúng ta phải truy cập bằng công thức <code>M3[i*COLS + j]</code>.</p>
<h3 id="781-ma-trận-hai-chiều-liên-tiếp-contiguous-two-dimensional-arrays"><a class="header" href="#781-ma-trận-hai-chiều-liên-tiếp-contiguous-two-dimensional-arrays">7.8.1. Ma trận hai chiều liên tiếp (Contiguous Two-Dimensional Arrays)</a></h3>
<p>Xét hàm <code>sumMat</code> nhận vào một con trỏ tới ma trận được cấp phát liên tiếp (có thể là cấp phát tĩnh hoặc cấp phát động tiết kiệm bộ nhớ) làm tham số đầu tiên, cùng với số hàng và số cột, và trả về tổng tất cả các phần tử trong ma trận.</p>
<p>Chúng ta sử dụng <strong>scaled indexing</strong> (chỉ số có nhân hệ số) trong đoạn code dưới đây vì nó áp dụng cho cả ma trận liên tiếp cấp phát tĩnh và động. Hãy nhớ rằng cú pháp <code>m[i][j]</code> <strong>không hoạt động</strong> với cách cấp phát động liên tiếp tiết kiệm bộ nhớ đã nói ở trên.</p>
<pre><code class="language-c">int sumMat(int *m, int rows, int cols) {
    int i, j, total = 0;
    for (i = 0; i &lt; rows; i++){
        for (j = 0; j &lt; cols; j++){
            total += m[i*cols + j];
        }
    }
    return total;
}
</code></pre>
<p>Dưới đây là code assembly tương ứng. Mỗi dòng đều được chú thích bằng tiếng Việt:</p>
<pre><code>Dump of assembler code for function sumMat:
0x400686 &lt;+0&gt;:   push %rbp                 # lưu rbp
0x400687 &lt;+1&gt;:   mov  %rsp,%rbp            # cập nhật rbp (stack frame mới)
0x40068a &lt;+4&gt;:   mov  %rdi,-0x18(%rbp)     # copy m vào %rbp-0x18
0x40068e &lt;+8&gt;:   mov  %esi,-0x1c(%rbp)     # copy rows vào %rbp-0x1c
0x400691 &lt;+11&gt;:  mov  %edx,-0x20(%rbp)     # copy cols vào %rbp-0x20
0x400694 &lt;+14&gt;:  movl $0x0,-0x4(%rbp)      # copy 0 vào %rbp-0x4 (total)
0x40069b &lt;+21&gt;:  movl $0x0,-0xc(%rbp)      # copy 0 vào %rbp-0xc (i)
0x4006a2 &lt;+28&gt;:  jmp  0x4006e1 &lt;sumMat+91&gt; # goto &lt;sumMat+91&gt;
0x4006a4 &lt;+30&gt;:  movl $0x0,-0x8(%rbp)      # copy 0 vào %rbp-0x8 (j)
0x4006ab &lt;+37&gt;:  jmp  0x4006d5 &lt;sumMat+79&gt; # goto &lt;sumMat+79&gt;
0x4006ad &lt;+39&gt;:  mov  -0xc(%rbp),%eax      # copy i vào %eax
0x4006b0 &lt;+42&gt;:  imul -0x20(%rbp),%eax     # nhân i với cols, lưu vào %eax
0x4006b4 &lt;+46&gt;:  mov  %eax,%edx            # copy i*cols vào %edx
0x4006b6 &lt;+48&gt;:  mov  -0x8(%rbp),%eax      # copy j vào %eax
0x4006b9 &lt;+51&gt;:  add  %edx,%eax            # cộng i*cols với j, lưu vào %eax
0x4006bb &lt;+53&gt;:  cltq                      # chuyển %eax sang số nguyên 64-bit
0x4006bd &lt;+55&gt;:  lea  0x0(,%rax,4),%rdx    # nhân (i*cols+j) với 4, lưu vào %rdx
0x4006c5 &lt;+63&gt;:  mov  -0x18(%rbp),%rax     # copy m vào %rax
0x4006c9 &lt;+67&gt;:  add  %rdx,%rax            # cộng m với (i*cols+j)*4, lưu vào %rax
0x4006cc &lt;+70&gt;:  mov  (%rax),%eax          # copy m[i*cols+j] vào %eax
0x4006ce &lt;+72&gt;:  add  %eax,-0x4(%rbp)      # cộng m[i*cols+j] vào total
0x4006d1 &lt;+75&gt;:  addl $0x1,-0x8(%rbp)      # cộng 1 vào j (j++)
0x4006d5 &lt;+79&gt;:  mov  -0x8(%rbp),%eax      # copy j vào %eax
0x4006d8 &lt;+82&gt;:  cmp  -0x20(%rbp),%eax     # so sánh j với cols
0x4006db &lt;+85&gt;:  jl   0x4006ad &lt;sumMat+39&gt; # nếu (j &lt; cols) goto &lt;sumMat+39&gt;
0x4006dd &lt;+87&gt;:  addl $0x1,-0xc(%rbp)      # cộng 1 vào i
0x4006e1 &lt;+91&gt;:  mov  -0xc(%rbp),%eax      # copy i vào %eax
0x4006e4 &lt;+94&gt;:  cmp  -0x1c(%rbp),%eax     # so sánh i với rows
0x4006e7 &lt;+97&gt;:  jl   0x4006a4 &lt;sumMat+30&gt; # nếu (i &lt; rows) goto &lt;sumMat+30&gt;
0x4006e9 &lt;+99&gt;:  mov  -0x4(%rbp),%eax      # copy total vào %eax
0x4006ec &lt;+102&gt;: pop  %rbp                 # dọn dẹp stack
</code></pre>
<p>Các biến cục bộ <code>i</code>, <code>j</code> và <code>total</code> lần lượt được lưu tại các địa chỉ <code>%rbp-0xc</code>, <code>%rbp-0x8</code> và <code>%rbp-0x4</code> trên stack. Các tham số đầu vào <code>m</code>, <code>row</code> và <code>cols</code> lần lượt được lưu tại <code>%rbp-0x18</code>, <code>%rbp-0x1c</code> và <code>%rbp-0x20</code>. Với thông tin này, hãy phóng to vào phần chỉ xử lý việc truy cập phần tử (<em>i</em>, <em>j</em>) trong ma trận:</p>
<pre><code>0x4006ad &lt;+39&gt;: mov  -0xc(%rbp),%eax    # copy i to %eax
0x4006b0 &lt;+42&gt;: imul -0x20(%rbp),%eax   # multiply i with cols, place in %eax
0x4006b4 &lt;+46&gt;: mov  %eax,%edx          # copy i*cols to %edx
</code></pre>
<p>Bộ lệnh đầu tiên tính giá trị <code>i*cols</code> và đặt vào thanh ghi <code>%edx</code>. Hãy nhớ rằng với một ma trận tên <code>matrix</code>, biểu thức <code>matrix + (i * cols)</code> tương đương với <code>&amp;matrix[i]</code>.</p>
<pre><code>0x4006b6 &lt;+48&gt;: mov  -0x8(%rbp),%eax    # copy j to %eax
0x4006b9 &lt;+51&gt;: add  %edx,%eax          # add i*cols with j, place in %eax
0x4006bb &lt;+53&gt;: cltq                    # convert %eax to a 64-bit int
0x4006bd &lt;+55&gt;: lea  0x0(,%rax,4),%rdx  # multiply (i*cols+j) by 4, put in %rdx
</code></pre>
<p>Bộ lệnh tiếp theo tính <code>(i*cols + j) * 4</code>. Compiler nhân chỉ số <code>i*cols + j</code> với 4 vì mỗi phần tử trong ma trận là một số nguyên 4 byte, và phép nhân này giúp tính đúng offset. Lệnh <code>cltq</code> ở dòng <code>&lt;sumMat+53&gt;</code> được dùng để <strong>sign-extend</strong> nội dung của <code>%eax</code> thành số nguyên 64-bit, vì giá trị này sắp được dùng để tính địa chỉ.</p>
<p>Tiếp theo, bộ lệnh sau cộng offset vừa tính vào con trỏ ma trận và dereference để lấy giá trị phần tử (<em>i</em>, <em>j</em>):</p>
<pre><code>0x4006c5 &lt;+63&gt;: mov -0x18(%rbp),%rax   # copy m to %rax
0x4006c9 &lt;+67&gt;: add %rdx,%rax          # add m to (i*cols+j)*4, place in %rax
0x4006cc &lt;+70&gt;: mov (%rax),%eax        # copy m[i*cols+j] to %eax
0x4006ce &lt;+72&gt;: add %eax,-0x4(%rbp)    # add m[i*cols+j] to total
</code></pre>
<ul>
<li>Lệnh đầu tiên nạp địa chỉ của ma trận <code>m</code> vào <code>%rax</code>.</li>
<li>Lệnh <code>add</code> cộng <code>(i*cols + j) * 4</code> vào địa chỉ <code>m</code> để tính đúng offset của phần tử (<em>i</em>, <em>j</em>).</li>
<li>Lệnh thứ ba dereference địa chỉ trong <code>%rax</code> và đặt giá trị vào <code>%eax</code>. Lưu ý việc dùng <code>%eax</code> làm thanh ghi đích: vì ma trận chứa số nguyên (4 byte), nên <strong>component register</strong> <code>%eax</code> được dùng thay vì <code>%rax</code>.</li>
<li>Lệnh cuối cộng giá trị trong <code>%eax</code> vào biến tích lũy <code>total</code> tại <code>%rbp-0x4</code>.</li>
</ul>
<p>Hãy xét cách truy cập phần tử (1,2) trong <strong>Hình 2</strong> (được lặp lại dưới đây):</p>
<p><img src="_images/matrixArray.png" alt="matrixArray" /><br />
<strong>Hình 3.</strong> Cách sắp xếp bộ nhớ của ma trận M1 theo thứ tự hàng (row-major order)</p>
<p>Phần tử (1,2) nằm tại địa chỉ <code>M1 + 1*COLS + 2</code>. Vì <code>COLS = 3</code>, phần tử (1,2) tương ứng với <code>M1 + 5</code>. Để truy cập phần tử này, compiler phải nhân 5 với kích thước kiểu dữ liệu <code>int</code> (4 byte), thu được offset <code>M1 + 20</code>, tương ứng với byte x~20~ trong hình. Dereference vị trí này sẽ lấy được giá trị 5, chính là phần tử (1,2) trong ma trận.</p>
<h3 id="782-ma-trận-không-liên-tiếp-noncontiguous-matrix"><a class="header" href="#782-ma-trận-không-liên-tiếp-noncontiguous-matrix">7.8.2. Ma trận không liên tiếp (Noncontiguous Matrix)</a></h3>
<p>Cách triển khai ma trận không liên tiếp phức tạp hơn một chút. <strong>Hình 4</strong> minh họa cách <code>M2</code> có thể được bố trí trong bộ nhớ.</p>
<p><img src="_images/dynamicMatrixLayout.png" alt="matrixDynamic" /><br />
<strong>Hình 4.</strong> Cách bố trí không liên tiếp của ma trận M2 trong bộ nhớ</p>
<p>Lưu ý rằng mảng con trỏ là liên tiếp, và mỗi mảng được trỏ tới bởi một phần tử của <code>M2</code> (ví dụ <code>M2[i]</code>) cũng liên tiếp. Tuy nhiên, các mảng riêng lẻ này <strong>không</strong> liên tiếp với nhau. Vì <code>M2</code> là mảng con trỏ, mỗi phần tử của <code>M2</code> chiếm 8 byte. Ngược lại, vì <code>M2[i]</code> là mảng <code>int</code>, mỗi phần tử của <code>M2[i]</code> cách nhau 4 byte.</p>
<p>Hàm <code>sumMatrix</code> dưới đây nhận một mảng con trỏ số nguyên (<code>matrix</code>) làm tham số đầu tiên, và số hàng cùng số cột làm tham số thứ hai và thứ ba:</p>
<pre><code class="language-c">int sumMatrix(int **matrix, int rows, int cols) {
    int i, j, total = 0;

    for (i = 0; i &lt; rows; i++) {
        for (j = 0; j &lt; cols; j++) {
            total += matrix[i][j];
        }
    }
    return total;
}
</code></pre>
<p>Mặc dù hàm này trông gần như giống hệt <code>sumMat</code> ở trên, ma trận mà nó nhận vào là một mảng liên tiếp các <em>con trỏ</em>. Mỗi con trỏ chứa địa chỉ của một mảng liên tiếp khác, tương ứng với một hàng riêng trong ma trận.</p>
<p>Mã assembly tương ứng của <code>sumMatrix</code> (mỗi dòng được chú thích):</p>
<pre><code>Dump of assembler code for function sumMatrix:
0x4006ee &lt;+0&gt;:   push   %rbp                    # lưu rbp
0x4006ef &lt;+1&gt;:   mov    %rsp,%rbp               # cập nhật rbp (stack frame mới)
0x4006f2 &lt;+4&gt;:   mov    %rdi,-0x18(%rbp)        # copy matrix vào %rbp-0x18
0x4006f6 &lt;+8&gt;:   mov    %esi,-0x1c(%rbp)        # copy rows vào %rbp-0x1c
0x4006f9 &lt;+11&gt;:  mov    %edx,-0x20(%rbp)        # copy cols vào %rbp-0x20
0x4006fc &lt;+14&gt;:  movl   $0x0,-0x4(%rbp)         # copy 0 vào %rbp-0x4 (total)
0x400703 &lt;+21&gt;:  movl   $0x0,-0xc(%rbp)         # copy 0 vào %rbp-0xc (i)
0x40070a &lt;+28&gt;:  jmp    0x40074e &lt;sumMatrix+96&gt; # goto &lt;sumMatrix+96&gt;
0x40070c &lt;+30&gt;:  movl   $0x0,-0x8(%rbp)         # copy 0 vào %rbp-0x8 (j)
0x400713 &lt;+37&gt;:  jmp    0x400742 &lt;sumMatrix+84&gt; # goto &lt;sumMatrix+84&gt;
0x400715 &lt;+39&gt;:  mov    -0xc(%rbp),%eax         # copy i vào %eax
0x400718 &lt;+42&gt;:  cltq                           # chuyển i sang số nguyên 64-bit
0x40071a &lt;+44&gt;:  lea    0x0(,%rax,8),%rdx       # nhân i với 8, lưu vào %rdx
0x400722 &lt;+52&gt;:  mov    -0x18(%rbp),%rax        # copy matrix vào %rax
0x400726 &lt;+56&gt;:  add    %rdx,%rax               # i*8 + matrix vào %rax
0x400729 &lt;+59&gt;:  mov    (%rax),%rax             # copy matrix[i] vào %rax (ptr)
0x40072c &lt;+62&gt;:  mov    -0x8(%rbp),%edx         # copy j vào %edx
0x40072f &lt;+65&gt;:  movsl
</code></pre>
<p>Một lần nữa, các biến <code>i</code>, <code>j</code> và <code>total</code> lần lượt nằm tại các địa chỉ stack <code>%rbp-0xc</code>, <code>%rbp-0x8</code> và <code>%rbp-0x4</code>. Các tham số đầu vào <code>matrix</code>, <code>row</code> và <code>cols</code> lần lượt nằm tại các địa chỉ stack <code>%rbp-0x18</code>, <code>%rbp-0x1c</code> và <code>%rbp-0x20</code>.<br />
Hãy phóng to vào đoạn code xử lý riêng việc truy cập phần tử (<em>i</em>, <em>j</em>), hay <code>matrix[i][j]</code>:</p>
<pre><code>0x400715 &lt;+39&gt;: mov  -0xc(%rbp),%eax       # copy i to %eax
0x400718 &lt;+42&gt;: cltq                       # convert i to 64-bit integer
0x40071a &lt;+44&gt;: lea  0x0(,%rax,8),%rdx     # multiply i by 8, place in %rdx
0x400722 &lt;+52&gt;: mov  -0x18(%rbp),%rax      # copy matrix to %rax
0x400726 &lt;+56&gt;: add  %rdx,%rax             # add i*8 to matrix, place in %rax
0x400729 &lt;+59&gt;: mov  (%rax),%rax           # copy matrix[i] to %rax (pointer)
</code></pre>
<p>Năm lệnh trên tính toán <code>matrix[i]</code>, hay <code>*(matrix + i)</code>.<br />
Vì <code>matrix[i]</code> chứa một con trỏ, nên <code>i</code> trước tiên được chuyển sang số nguyên 64-bit. Sau đó, compiler nhân <code>i</code> với 8 trước khi cộng vào <code>matrix</code> để tính đúng offset địa chỉ (hãy nhớ rằng con trỏ có kích thước 8 byte). Lệnh tại <code>&lt;sumMatrix+59&gt;</code> sau đó dereference địa chỉ vừa tính để lấy phần tử <code>matrix[i]</code>.</p>
<p>Vì <code>matrix</code> là một mảng các con trỏ <code>int</code>, phần tử tại <code>matrix[i]</code> bản thân nó là một con trỏ <code>int</code>. Phần tử thứ <em>j</em> trong <code>matrix[i]</code> nằm tại offset <code>j × 4</code> trong mảng <code>matrix[i]</code>.</p>
<p>Bộ lệnh tiếp theo trích xuất phần tử thứ <em>j</em> trong mảng <code>matrix[i]</code>:</p>
<pre><code>0x40072c &lt;+62&gt;: mov    -0x8(%rbp),%edx    # copy j to %edx
0x40072f &lt;+65&gt;: movslq %edx,%rdx          # convert j to a 64-bit integer
0x400732 &lt;+68&gt;: shl    $0x2,%rdx          # multiply j by 4, place in %rdx
0x400736 &lt;+72&gt;: add    %rdx,%rax          # add j*4 to matrix[i], put in %rax
0x400739 &lt;+75&gt;: mov    (%rax),%eax        # copy matrix[i][j] to %eax
0x40073b &lt;+77&gt;: add    %eax,-0x4(%rbp)    # add matrix[i][j] to total
</code></pre>
<ul>
<li>Lệnh đầu tiên nạp biến <code>j</code> vào thanh ghi <code>%edx</code>.</li>
<li>Lệnh <code>movslq</code> tại <code>&lt;sumMatrix+65&gt;</code> chuyển <code>%edx</code> thành số nguyên 64-bit, lưu kết quả vào thanh ghi 64-bit <code>%rdx</code>.</li>
<li>Compiler sau đó dùng lệnh dịch trái (<code>shl</code>) để nhân <code>j</code> với 4 và lưu kết quả vào <code>%rdx</code>.</li>
<li>Compiler cuối cùng cộng giá trị này vào địa chỉ trong <code>matrix[i]</code> để lấy địa chỉ của phần tử <code>matrix[i][j]</code>.</li>
<li>Các lệnh tại <code>&lt;sumMatrix+75&gt;</code> và <code>&lt;sumMatrix+77&gt;</code> lấy giá trị tại <code>matrix[i][j]</code> và cộng giá trị này vào <code>total</code>.</li>
</ul>
<p>Hãy quay lại <strong>Hình 4</strong> và xét ví dụ truy cập <code>M2[1][2]</code>.<br />
Để tiện theo dõi, hình được lặp lại dưới đây:</p>
<p><img src="_images/dynamicMatrixLayout.png" alt="matrixDynamic" /></p>
<p><strong>Hình 5.</strong> Cách bố trí không liên tiếp của ma trận M2 trong bộ nhớ</p>
<p>Lưu ý rằng <code>M2</code> bắt đầu tại địa chỉ bộ nhớ x~0~.<br />
Compiler trước tiên tính địa chỉ của <code>M2[1]</code> bằng cách nhân 1 với 8 (<code>sizeof(int *)</code>) và cộng vào địa chỉ của <code>M2</code> (x~0~), thu được địa chỉ mới x~8~.<br />
Dereference địa chỉ này sẽ cho ra địa chỉ gắn với <code>M2[1]</code>, tức x~36~.<br />
Tiếp theo, compiler nhân chỉ số 2 với 4 (<code>sizeof(int)</code>) và cộng kết quả (8) vào x~36~, thu được địa chỉ cuối cùng x~44~.<br />
Dereference địa chỉ x~44~ sẽ cho giá trị 5.<br />
Quả thật, phần tử trong <strong>Hình 4</strong> tương ứng với <code>M2[1][2]</code> có giá trị là 5.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C7-x86_64/arrays.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C7-x86_64/structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C7-x86_64/arrays.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C7-x86_64/structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
