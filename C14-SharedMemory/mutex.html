<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mutual Exclusion - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html" class="active"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="1431-loại-trừ-lẫn-nhau-mutual-exclusion"><a class="header" href="#1431-loại-trừ-lẫn-nhau-mutual-exclusion">14.3.1. Loại trừ lẫn nhau (Mutual Exclusion)</a></h3>
<p><em>Mutex là gì? Câu trả lời ở ngoài kia, nó đang tìm kiếm bạn, và nó sẽ tìm thấy bạn nếu bạn muốn.</em></p>
<p>~ Trinity giải thích về mutex cho Neo (Xin lỗi <em>The Matrix</em>)</p>
<p>Để khắc phục <strong>data race</strong> (tranh chấp dữ liệu), chúng ta sẽ sử dụng một cấu trúc đồng bộ hóa gọi là <strong>mutual exclusion lock</strong> (khóa loại trừ lẫn nhau), hay <strong>mutex</strong>.<br />
Mutex là một loại <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) đảm bảo rằng tại bất kỳ thời điểm nào, chỉ <strong>một</strong> thread được phép vào và thực thi đoạn mã bên trong <strong>critical section</strong> (vùng tới hạn).</p>
<p>Trước khi sử dụng mutex, chương trình cần:</p>
<ol>
<li><strong>Khai báo</strong> mutex trong vùng nhớ được chia sẻ giữa các thread (thường là biến toàn cục).</li>
<li><strong>Khởi tạo</strong> mutex trước khi các thread cần dùng (thường trong hàm <code>main</code>).</li>
</ol>
<p>Thư viện <strong>Pthreads</strong> định nghĩa kiểu <code>pthread_mutex_t</code> cho mutex.<br />
Để khai báo một biến mutex, thêm dòng:</p>
<pre><code class="language-c">pthread_mutex_t mutex;
</code></pre>
<p>Để khởi tạo mutex, dùng hàm <code>pthread_mutex_init</code>, nhận vào địa chỉ của mutex và một cấu trúc thuộc tính (thường đặt là <code>NULL</code>):</p>
<pre><code class="language-c">pthread_mutex_init(&amp;mutex, NULL);
</code></pre>
<p>Khi không còn cần mutex nữa (thường ở cuối hàm <code>main</code>, sau khi gọi <code>pthread_join</code>), chương trình nên giải phóng cấu trúc mutex bằng cách gọi <code>pthread_mutex_destroy</code>:</p>
<pre><code class="language-c">pthread_mutex_destroy(&amp;mutex);
</code></pre>
<h4 id="mutex-khóa-và-sẵn-sàng"><a class="header" href="#mutex-khóa-và-sẵn-sàng">Mutex: Khóa và sẵn sàng</a></h4>
<p>Trạng thái ban đầu của mutex là <strong>unlocked</strong> (mở khóa), nghĩa là bất kỳ thread nào cũng có thể sử dụng ngay.<br />
Để vào critical section, một thread phải <strong>acquire</strong> (giành) được khóa.<br />
Điều này được thực hiện bằng cách gọi hàm <code>pthread_mutex_lock</code>.</p>
<p>Sau khi một thread đã giữ khóa, <strong>không thread nào khác</strong> có thể vào critical section cho đến khi thread giữ khóa <strong>release</strong> (nhả) nó.<br />
Nếu một thread khác gọi <code>pthread_mutex_lock</code> khi mutex đang bị khóa, thread đó sẽ <strong>block</strong> (chờ) cho đến khi mutex khả dụng.<br />
Hãy nhớ rằng <a href="../C13-OS/processes.html#_process_state"><em>blocking</em> nghĩa là thread sẽ không được lập lịch</a> để sử dụng CPU cho đến khi điều kiện nó chờ (mutex khả dụng) trở thành đúng.</p>
<p>Khi một thread thoát khỏi critical section, nó phải gọi <code>pthread_mutex_unlock</code> để nhả mutex, cho phép thread khác sử dụng.<br />
Như vậy, tại một thời điểm, tối đa chỉ có <strong>một thread</strong> giữ khóa và vào critical section, ngăn chặn nhiều thread cùng “tranh” đọc và cập nhật biến chia sẻ.</p>
<p>Sau khi đã khai báo và khởi tạo mutex, câu hỏi tiếp theo là <strong>đặt lệnh khóa và mở khóa ở đâu</strong> để đảm bảo critical section được bảo vệ tốt nhất.<br />
Dưới đây là một thử nghiệm ban đầu khi bổ sung mutex vào hàm <code>countElems</code><br />
(Toàn bộ mã nguồn có thể tải từ <a href="_attachments/countElems_p_v2.c">countElems_p_v2.c</a>):</p>
<pre><code class="language-c">pthread_mutex_t mutex; //global declaration of mutex, initialized in main()

/*parallel version of step 1 of CountSort algorithm (attempt 1 with mutexes):
 * extracts arguments from args value
 * calculates component of the array that thread is responsible for counting
 * computes the frequency of all the elements in assigned component and stores
 * the associated counts of each element in counts array
*/
void *countElems( void *args ) {
    //extract arguments
    //ommitted for brevity
    int *array = myargs-&gt;ap;
    long *counts = myargs-&gt;countp;

    //assign work to the thread
    long chunk = length / nthreads; //nominal chunk size
    long start = myid * chunk;
    long end = (myid + 1) * chunk;
    long val;
    if (myid == nthreads - 1) {
        end = length;
    }
    long i;

    //heart of the program
    pthread_mutex_lock(&amp;mutex); //acquire the mutex lock
    for (i = start; i &lt; end; i++) {
        val = array[i];
        counts[val] = counts[val] + 1;
    }
    pthread_mutex_unlock(&amp;mutex); //release the mutex lock

    return NULL;
}
</code></pre>
<p>Các lệnh khởi tạo và hủy mutex được đặt trong <code>main</code>, bao quanh phần tạo và join thread:</p>
<pre><code class="language-c">// trích từ hàm main():

pthread_mutex_init(&amp;mutex, NULL); // khởi tạo mutex

for (t = 0; t &lt; nthreads; t++) {
    pthread_create(&amp;thread_array[t], NULL, countElems, &amp;thread_args[t]);
}

for (t = 0; t &lt; nthreads; t++) {
    pthread_join(thread_array[t], NULL);
}

pthread_mutex_destroy(&amp;mutex); // hủy (giải phóng) mutex
</code></pre>
<p>Hãy biên dịch lại và chạy chương trình mới này với số lượng thread khác nhau:</p>
<pre><code>$ ./countElems_p_v2 10000000 1 1
Counts array:
999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207

$ ./countElems_p_v2 10000000 1 2
Counts array:
999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207

$ ./countElems_p_v2 10000000 1 4
Counts array:
999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207
</code></pre>
<p>Tuyệt vời — kết quả <strong>cuối cùng</strong> đã nhất quán bất kể số lượng thread!</p>
<p>Hãy nhớ rằng một mục tiêu quan trọng khác của multithreading là <strong>giảm thời gian chạy</strong> của chương trình khi số lượng thread tăng (tức là <em>tăng tốc</em> thực thi).<br />
Hãy benchmark hiệu năng của hàm <code>countElems</code>.</p>
<p>Mặc dù có thể bạn muốn dùng lệnh <code>time -p</code>, nhưng hãy nhớ rằng <code>time -p</code> đo <strong>wall-clock time</strong> của <strong>toàn bộ</strong> chương trình (bao gồm cả phần sinh dữ liệu ngẫu nhiên), chứ <strong>không chỉ</strong> thời gian chạy của <code>countElems</code>.<br />
Trong trường hợp này, tốt hơn là dùng system call <code>gettimeofday</code>, cho phép đo chính xác wall-clock time của một đoạn mã cụ thể.</p>
<p>Benchmark <code>countElems</code> trên 100 triệu phần tử cho kết quả:</p>
<pre><code>$ ./countElems_p_v2 100000000 0 1
Time for Step 1 is 0.368126 s

$ ./countElems_p_v2 100000000 0 2
Time for Step 1 is 0.438357 s

$ ./countElems_p_v2 100000000 0 4
Time for Step 1 is 0.519913 s
</code></pre>
<p>Việc <strong>tăng số lượng thread</strong> lại khiến chương trình <strong>chạy chậm hơn</strong>! Điều này đi ngược lại mục tiêu sử dụng thread để làm chương trình <strong>nhanh hơn</strong>.</p>
<p>Để hiểu chuyện gì đang xảy ra, hãy xem vị trí đặt <strong>lock</strong> trong hàm <code>countElems</code>:</p>
<pre><code class="language-c">// trích đoạn code từ hàm countElems ở phần trước
// phần lõi của chương trình
pthread_mutex_lock(&amp;mutex); // giành mutex lock
for (i = start; i &lt; end; i++){
    val = array[i];
    counts[val] = counts[val] + 1;
}
pthread_mutex_unlock(&amp;mutex); // nhả mutex lock
</code></pre>
<p>Trong ví dụ này, chúng ta đặt lock bao quanh <strong>toàn bộ</strong> vòng lặp <code>for</code>.<br />
Mặc dù cách đặt này giải quyết vấn đề <strong>đúng đắn</strong> (correctness), nhưng lại <strong>rất tệ</strong> về mặt hiệu năng — critical section giờ bao trùm toàn bộ thân vòng lặp.<br />
Đặt lock như vậy đảm bảo rằng <strong>chỉ một thread</strong> có thể thực thi vòng lặp tại một thời điểm, về cơ bản là <strong>tuần tự hóa</strong> chương trình!</p>
<h4 id="the-mutex-reloaded"><a class="header" href="#the-mutex-reloaded">The Mutex: Reloaded</a></h4>
<p>Hãy thử một cách tiếp cận khác: đặt lệnh <strong>lock</strong> và <strong>unlock</strong> mutex <strong>bên trong mỗi vòng lặp</strong>:</p>
<pre><code class="language-c">/* phiên bản code đã chỉnh sửa của hàm countElems:
 * lock được đặt BÊN TRONG vòng for!
 */
// phần lõi của chương trình
for (i = start; i &lt; end; i++) {
    val = array[i];
    pthread_mutex_lock(&amp;m); // giành mutex lock
    counts[val] = counts[val] + 1;
    pthread_mutex_unlock(&amp;m); // nhả mutex lock
}
</code></pre>
<p>Thoạt nhìn, đây có vẻ là giải pháp tốt hơn vì mỗi thread có thể vào vòng lặp song song, chỉ tuần tự hóa khi chạm tới lock.<br />
Critical section lúc này rất nhỏ, chỉ bao gồm dòng <code>counts[val] = counts[val] + 1</code>.</p>
<p>Trước tiên, hãy kiểm tra tính đúng đắn của phiên bản này:</p>
<pre><code>$ ./countElems_p_v3 10000000 1 1
Counts array:
999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207

$ ./countElems_p_v3 10000000 1 2
Counts array:
999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207

$ ./countElems_p_v3 10000000 1 4
Counts array:
999170 1001044 999908 1000431 999998 1001479 999709 997250 1000804 1000207
</code></pre>
<p>Tốt — phiên bản này cũng cho kết quả <strong>nhất quán</strong> bất kể số lượng thread.</p>
<p>Bây giờ, hãy xem hiệu năng:</p>
<pre><code>$ ./countElems_p_v3 100000000 0 1
Time for Step 1 is 1.92225 s

$ ./countElems_p_v3 100000000 0 2
Time for Step 1 is 10.9704 s

$ ./countElems_p_v3 100000000 0 4
Time for Step 1 is 9.13662 s
</code></pre>
<p>Chạy phiên bản này cho kết quả <strong>chậm hơn đáng kể</strong>!</p>
<p>Hóa ra, việc <strong>lock</strong> và <strong>unlock</strong> mutex là các thao tác <strong>tốn kém</strong>.<br />
Hãy nhớ lại phần thảo luận về <a href="../C12-CodeOpt/loops_functions.html#_function_inlining">tối ưu hóa lời gọi hàm</a>:<br />
gọi một hàm lặp đi lặp lại (và không cần thiết) trong vòng lặp có thể là nguyên nhân chính gây chậm chương trình.</p>
<p>Trong cách dùng mutex trước đây, mỗi thread chỉ lock và unlock <strong>một lần</strong>.<br />
Trong giải pháp hiện tại, mỗi thread lock và unlock <strong>n/t</strong> lần, trong đó:</p>
<ul>
<li><em>n</em> là kích thước mảng</li>
<li><em>t</em> là số lượng thread</li>
<li><em>n/t</em> là số phần tử mảng được gán cho mỗi thread</li>
</ul>
<p>Kết quả là chi phí của các thao tác mutex bổ sung làm chậm đáng kể việc thực thi vòng lặp.</p>
<h4 id="the-mutex-revisited"><a class="header" href="#the-mutex-revisited">The Mutex: Revisited</a></h4>
<p>Ngoài việc bảo vệ critical section để đảm bảo tính đúng đắn, một giải pháp lý tưởng sẽ:</p>
<ol>
<li>Sử dụng lock và unlock <strong>ít nhất có thể</strong>.</li>
<li>Giảm kích thước critical section xuống <strong>nhỏ nhất có thể</strong>.</li>
</ol>
<p>Phiên bản đầu tiên đáp ứng yêu cầu (1), trong khi phiên bản thứ hai cố gắng đạt yêu cầu (2).<br />
Thoạt nhìn, hai yêu cầu này có vẻ <strong>mâu thuẫn</strong>.<br />
Liệu có cách nào để đạt được <strong>cả hai</strong> (và đồng thời tăng tốc chương trình) không?</p>
<p>Trong lần thử tiếp theo, mỗi thread sẽ duy trì một mảng đếm (<em>counts array</em>) <strong>cục bộ</strong> trên stack của nó.<br />
Vì mảng này là <strong>local</strong> cho từng thread, thread có thể truy cập mà <strong>không cần lock</strong> — không có nguy cơ race condition trên dữ liệu không được chia sẻ.</p>
<p>Mỗi thread sẽ xử lý phần mảng được gán và điền vào mảng đếm cục bộ của mình.<br />
Sau khi đếm xong tất cả giá trị trong phần dữ liệu của mình, mỗi thread sẽ:</p>
<ol>
<li><strong>Lock</strong> mutex chia sẻ (vào critical section).</li>
<li>Cộng giá trị từ mảng đếm cục bộ vào mảng <code>counts</code> chia sẻ.</li>
<li><strong>Unlock</strong> mutex chia sẻ (thoát critical section).</li>
</ol>
<p>Việc giới hạn mỗi thread chỉ cập nhật mảng <code>counts</code> chia sẻ <strong>một lần</strong> giúp giảm đáng kể tranh chấp trên biến chia sẻ và giảm thiểu các thao tác mutex tốn kém.</p>
<p>Dưới đây là phiên bản <code>countElems</code> đã chỉnh sửa.<br />
Toàn bộ mã nguồn của chương trình cuối cùng này có thể xem tại<br />
(<a href="_attachments/countElems_p_v3.c">countElems_p_v3.c</a>):</p>
<pre><code class="language-c">/*parallel version of step 1 of CountSort algorithm (final attempt w/mutexes):
 * extracts arguments from args value
 * calculates component of the array that thread is responsible for counting
 * computes the frequency of all the elements in assigned component and stores
 * the associated counts of each element in counts array
*/
void *countElems( void *args ) {
    //extract arguments
    //ommitted for brevity
    int *array = myargs-&gt;ap;
    long *counts = myargs-&gt;countp;

    //local declaration of counts array, initializes every element to zero.
    long local_counts[MAX] = {0};

    //assign work to the thread
    long chunk = length / nthreads; //nominal chunk size
    long start = myid * chunk;
    long end = (myid + 1) * chunk;
    long val;
    if (myid == nthreads-1)
        end = length;

    long i;

    //heart of the program
    for (i = start; i &lt; end; i++) {
        val = array[i];

        //updates local counts array
        local_counts[val] = local_counts[val] + 1;
    }

    //update to global counts array
    pthread_mutex_lock(&amp;mutex); //acquire the mutex lock
    for (i = 0; i &lt; MAX; i++) {
        counts[i] += local_counts[i];
    }
    pthread_mutex_unlock(&amp;mutex); //release the mutex lock

    return NULL;
}
</code></pre>
<p>Phiên bản này có một vài đặc điểm bổ sung:</p>
<ul>
<li>
<p>Sự xuất hiện của <code>local_counts</code>, một mảng <strong>cục bộ</strong> trong phạm vi của từng thread (tức là được cấp phát trên stack của thread đó). Giống như <code>counts</code>, <code>local_counts</code> chứa <code>MAX</code> phần tử, với <code>MAX</code> là giá trị lớn nhất mà bất kỳ phần tử nào trong mảng đầu vào có thể có.</p>
</li>
<li>
<p>Mỗi thread cập nhật <code>local_counts</code> theo tốc độ riêng của nó, <strong>không</strong> có tranh chấp (contention) đối với biến chia sẻ.</p>
</li>
<li>
<p>Chỉ <strong>một</strong> lần gọi <code>pthread_mutex_lock</code> được dùng để bảo vệ việc mỗi thread cập nhật mảng <code>counts</code> toàn cục, và điều này chỉ diễn ra <strong>một lần</strong> ở cuối quá trình thực thi của thread.</p>
</li>
</ul>
<p>Bằng cách này, chúng ta giảm thời gian mỗi thread phải ở trong <strong>critical section</strong> xuống chỉ còn việc cập nhật mảng <code>counts</code> chia sẻ.<br />
Mặc dù tại một thời điểm chỉ một thread có thể vào critical section, nhưng thời gian mỗi thread ở đó <strong>tỷ lệ với <code>MAX</code></strong>, chứ không phải <em>n</em> (độ dài mảng toàn cục).<br />
Vì <code>MAX</code> nhỏ hơn rất nhiều so với <em>n</em>, chúng ta kỳ vọng sẽ thấy cải thiện về hiệu năng.</p>
<p>Bây giờ, hãy benchmark phiên bản này của chương trình:</p>
<pre><code>$ ./countElems_p_v3 100000000 0 1
Time for Step 1 is 0.334574 s

$ ./countElems_p_v3 100000000 0 2
Time for Step 1 is 0.209347 s

$ ./countElems_p_v3 100000000 0 4
Time for Step 1 is 0.130745 s
</code></pre>
<p>Thật tuyệt vời! Chương trình của chúng ta không chỉ cho ra kết quả <strong>đúng</strong>, mà còn chạy <strong>nhanh hơn</strong> khi tăng số lượng thread.</p>
<p>Bài học rút ra ở đây là: để <strong>tối thiểu hóa</strong> critical section một cách hiệu quả, hãy sử dụng <strong>biến cục bộ</strong> để thu thập các giá trị trung gian.<br />
Sau khi hoàn thành phần công việc nặng cần song song hóa, hãy dùng mutex để cập nhật an toàn các biến chia sẻ.</p>
<h4 id="deadlock"><a class="header" href="#deadlock">Deadlock</a></h4>
<p>Trong một số chương trình, các thread đang chờ nhau có thể phụ thuộc lẫn nhau.<br />
Một tình huống gọi là <strong>deadlock</strong> có thể xảy ra khi nhiều cấu trúc đồng bộ hóa như mutex được áp dụng <strong>sai cách</strong>.<br />
Một thread bị deadlock sẽ bị chặn bởi một thread khác, và thread đó <strong>cũng</strong> đang bị chặn bởi một thread đang bị chặn khác.<br />
<strong>Kẹt xe</strong> (gridlock), khi các xe ở mọi hướng không thể di chuyển vì bị chặn bởi các xe khác, là một ví dụ thực tế phổ biến của deadlock tại các giao lộ đông đúc.</p>
<p>Để minh họa deadlock trong code, hãy xét ví dụ sử dụng multithreading để triển khai một ứng dụng ngân hàng.<br />
Mỗi tài khoản người dùng được định nghĩa bởi số dư (<strong>balance</strong>) và một mutex riêng (đảm bảo không có race condition khi cập nhật số dư):</p>
<pre><code class="language-c">struct account {
    pthread_mutex_t lock;
    int balance;
};
</code></pre>
<p>Xét một cài đặt đơn giản của hàm <code>Transfer</code> để chuyển tiền từ một tài khoản ngân hàng sang tài khoản khác:</p>
<pre><code class="language-c">void *Transfer(void *args){
    // bỏ phần truyền tham số để dễ đọc hơn
    //...

    pthread_mutex_lock(&amp;fromAcct-&gt;lock);
    pthread_mutex_lock(&amp;toAcct-&gt;lock);

    fromAcct-&gt;balance -= amt;
    toAcct-&gt;balance += amt;

    pthread_mutex_unlock(&amp;fromAcct-&gt;lock);
    pthread_mutex_unlock(&amp;toAcct-&gt;lock);

    return NULL;
}
</code></pre>
<p>Giả sử Thread 0 và Thread 1 chạy đồng thời, lần lượt đại diện cho người dùng A và B.<br />
Xét tình huống A và B muốn chuyển tiền cho nhau:</p>
<ul>
<li>A muốn chuyển 20 đô cho B</li>
<li>B muốn chuyển 40 đô cho A</li>
</ul>
<p>Trong luồng thực thi được minh họa ở <strong>Hình 1</strong>, cả hai thread cùng lúc thực thi hàm <code>Transfer</code>:</p>
<ul>
<li>Thread 0 giữ khóa (<code>lock</code>) của <code>acctA</code></li>
<li>Thread 1 giữ khóa của <code>acctB</code></li>
</ul>
<p>Để tiếp tục, Thread 0 cần giữ khóa của <code>acctB</code> — nhưng khóa này đang do Thread 1 giữ.<br />
Tương tự, Thread 1 cần giữ khóa của <code>acctA</code> — nhưng khóa này đang do Thread 0 giữ.</p>
<p>Vì cả hai thread đều <strong>chặn</strong> nhau, chúng rơi vào trạng thái <strong>deadlock</strong>.</p>
<p><img src="_images/deadlock.png" alt="Two threads deadlocked with each other" /></p>
<p><strong>Hình 1.</strong> Ví dụ về deadlock</p>
<p>Mặc dù <strong>OS</strong> (hệ điều hành) cung cấp một số cơ chế bảo vệ chống lại deadlock, lập trình viên vẫn cần cẩn trọng khi viết mã có thể làm tăng khả năng xảy ra deadlock.<br />
Ví dụ, kịch bản ở trên có thể tránh được bằng cách <strong>sắp xếp lại</strong> các thao tác khóa sao cho mỗi cặp <strong>lock/unlock</strong> chỉ bao quanh câu lệnh cập nhật số dư tương ứng:</p>
<pre><code class="language-c">void *Transfer(void *args){
    // bỏ phần truyền tham số để dễ đọc hơn
    //...

    pthread_mutex_lock(&amp;fromAcct-&gt;lock);
    fromAcct-&gt;balance -= amt;
    pthread_mutex_unlock(&amp;fromAcct-&gt;lock);

    pthread_mutex_lock(&amp;toAcct-&gt;lock);
    toAcct-&gt;balance += amt;
    pthread_mutex_unlock(&amp;toAcct-&gt;lock);

    return NULL;
}
</code></pre>
<p>Deadlock không phải là tình huống chỉ xảy ra với <strong>thread</strong>.<br />
Các <strong>process</strong> (đặc biệt là những process có giao tiếp với nhau) cũng có thể bị deadlock.<br />
Lập trình viên cần chú ý đến các <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) mà họ sử dụng và hậu quả của việc sử dụng chúng <strong>không đúng cách</strong>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C14-SharedMemory/synchronization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C14-SharedMemory/semaphores.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C14-SharedMemory/synchronization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C14-SharedMemory/semaphores.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
