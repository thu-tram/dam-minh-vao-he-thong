<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implicit Threading with OpenMP - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html" class="active"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="147-Đa-luồng-ngầm-định-với-openmp-implicit-threading-with-openmp"><a class="header" href="#147-Đa-luồng-ngầm-định-với-openmp-implicit-threading-with-openmp">14.7. Đa luồng ngầm định với OpenMP (Implicit Threading with OpenMP)</a></h2>
<p>Cho đến nay, chúng ta đã trình bày lập trình bộ nhớ chia sẻ bằng <strong>POSIX threads</strong> (Pthreads).<br />
Mặc dù Pthreads rất hữu ích cho các ứng dụng đơn giản, nhưng khi chương trình trở nên phức tạp hơn, chúng lại ngày càng khó sử dụng.<br />
Pthreads là một ví dụ của <strong>explicit parallel programming</strong> (lập trình song song tường minh) với threads, yêu cầu lập trình viên phải chỉ rõ <strong>chính xác</strong> mỗi thread cần làm gì và khi nào thread đó bắt đầu hoặc kết thúc.</p>
<p>Với Pthreads, việc <em>bổ sung dần</em> (incrementally) khả năng song song vào một chương trình tuần tự hiện có cũng là một thách thức.<br />
Nói cách khác, ta thường phải viết lại toàn bộ chương trình để sử dụng threads — điều này thường không mong muốn khi cần song song hóa một codebase lớn và đã tồn tại từ trước.</p>
<p>Thư viện <strong>Open Multiprocessing</strong> (<strong>OpenMP</strong>) cung cấp một giải pháp <em>ngầm định</em> thay thế cho Pthreads.<br />
OpenMP được tích hợp sẵn trong GCC và các trình biên dịch phổ biến khác như LLVM và Clang, và có thể dùng với các ngôn ngữ C, C++ và Fortran.<br />
Ưu điểm chính của OpenMP là cho phép lập trình viên song song hóa các thành phần của mã C tuần tự hiện có bằng cách thêm <strong>pragma</strong> (chỉ thị đặc biệt cho trình biên dịch) vào các phần của mã.<br />
Các pragma dành riêng cho OpenMP bắt đầu bằng <code>#pragma omp</code>.</p>
<p>Việc trình bày chi tiết OpenMP nằm ngoài phạm vi của cuốn sách này, nhưng chúng ta sẽ đề cập đến một số pragma thường gặp và minh họa cách sử dụng chúng trong bối cảnh một số ứng dụng ví dụ.</p>
<h3 id="1471-các-pragma-thường-dùng-common-pragmas"><a class="header" href="#1471-các-pragma-thường-dùng-common-pragmas">14.7.1. Các pragma thường dùng (Common Pragmas)</a></h3>
<p>Dưới đây là một số pragma được sử dụng phổ biến trong các chương trình OpenMP:</p>
<p><code>#pragma omp parallel</code></p>
<p>:   Tạo một <strong>team</strong> (nhóm) các thread và cho mỗi thread chạy đoạn mã trong phạm vi của pragma (thường là một lời gọi hàm).<br />
Việc gọi pragma này thường tương đương với việc gọi cặp hàm <code>pthread_create</code> và <code>pthread_join</code> <a href="posix.html#_creating_and_joining_threads">đã thảo luận trong phần Pthreads</a>.<br />
Pragma này có thể đi kèm một số <strong>clause</strong> (mệnh đề), bao gồm:</p>
<pre><code>- `num_threads`: chỉ định số lượng thread cần tạo.
- `private`: danh sách các biến sẽ là **private** (cục bộ) cho từng thread. Các biến private cũng có thể được khai báo trong phạm vi của pragma. Mỗi thread sẽ có bản sao riêng của từng biến.
- `shared`: danh sách các biến sẽ được **shared** (chia sẻ) giữa các thread. Chỉ có **một bản sao** của biến được chia sẻ giữa tất cả các thread.
- `default`: chỉ định việc xác định biến nào là shared sẽ do trình biên dịch quyết định hay không. Trong hầu hết các trường hợp, ta nên dùng `default(none)` và chỉ rõ biến nào là shared, biến nào là private.
</code></pre>
<p><code>#pragma omp for</code></p>
<p>:   Chỉ định rằng mỗi thread sẽ thực thi một <strong>tập con</strong> các vòng lặp của một vòng <code>for</code>.<br />
Mặc dù việc lập lịch (scheduling) vòng lặp phụ thuộc vào hệ thống, mặc định thường là phương pháp <strong>chunking</strong> (chia khối) đã đề cập trong <a href="posix.html#_revisiting_scalar_multiplication">ví dụ nhân vô hướng</a>.<br />
Đây là dạng lập lịch <strong>static</strong>: mỗi thread được gán một khối cố định và xử lý các vòng lặp trong khối đó.</p>
<pre><code>OpenMP cũng hỗ trợ lập lịch **dynamic**: mỗi thread nhận một số vòng lặp, và khi hoàn thành sẽ yêu cầu một nhóm vòng lặp mới.  
Chính sách lập lịch có thể được đặt bằng clause:

- `schedule(dynamic)`: chỉ định sử dụng lập lịch **dynamic**. Mặc dù hữu ích trong một số trường hợp, lập lịch static (mặc định) thường nhanh hơn.
</code></pre>
<p><code>#pragma omp parallel for</code></p>
<p>:   Kết hợp giữa <code>omp parallel</code> và <code>omp for</code>.<br />
Khác với <code>omp for</code>, pragma này <strong>tạo team thread</strong> trước, rồi mới gán cho mỗi thread một tập vòng lặp để thực thi.</p>
<p><code>#pragma omp critical</code></p>
<p>:   Chỉ định rằng đoạn mã trong phạm vi của pragma là một <strong>critical section</strong> — chỉ một thread được thực thi đoạn mã này tại một thời điểm để đảm bảo tính đúng đắn.</p>
<p>Ngoài ra, OpenMP còn cung cấp một số <strong>hàm</strong> hữu ích cho thread khi thực thi, ví dụ:</p>
<ul>
<li><code>omp_get_num_threads</code>: trả về số lượng thread trong team hiện tại.</li>
<li><code>omp_set_num_threads</code>: đặt số lượng thread mà một team sẽ có.</li>
<li><code>omp_get_thread_num</code>: trả về <strong>ID</strong> của thread đang gọi hàm.</li>
</ul>
<blockquote>
<p><strong>Lưu ý:</strong><br />
<code>omp parallel for</code> <strong>chỉ hoạt động với vòng lặp <code>for</code></strong>.<br />
Các loại vòng lặp khác như <code>while</code> hoặc <code>do</code>-<code>while</code> <strong>không được hỗ trợ</strong>.</p>
</blockquote>
<h3 id="1472-hello-threading-phiên-bản-openmp"><a class="header" href="#1472-hello-threading-phiên-bản-openmp">14.7.2. Hello Threading: Phiên bản OpenMP</a></h3>
<p>Hãy cùng xem lại chương trình “Hello World”<br />
(<a href="_attachments/hellothreads.c">hellothreads.c</a>), nhưng lần này sử dụng <strong>OpenMP</strong> thay vì <strong>Pthreads</strong>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;omp.h&gt;

void HelloWorld( void ) {
    long myid = omp_get_thread_num();
    printf( &quot;Hello world! I am thread %ld\n&quot;, myid );
}

int main( int argc, char** argv ) {
    long nthreads;

    if (argc !=2) {
        fprintf(stderr, &quot;usage: %s &lt;n&gt;\n&quot;, argv[0]);
        fprintf(stderr, &quot;where &lt;n&gt; is the number of threads\n&quot;);
        return 1;
    }

    nthreads = strtol( argv[1], NULL, 10 );

    #pragma omp parallel num_threads(nthreads)
        HelloWorld();

    return 0;
}
</code></pre>
<p>Lưu ý rằng chương trình OpenMP <strong>ngắn hơn rất nhiều</strong> so với phiên bản Pthreads.<br />
Để truy cập các hàm thư viện OpenMP, ta include file header <code>omp.h</code>.<br />
Pragma <code>omp parallel num_threads(nthreads)</code> trong hàm <code>main</code> sẽ tạo ra một nhóm thread, trong đó mỗi thread sẽ gọi hàm <code>HelloWorld</code>.</p>
<p>Mệnh đề <code>num_threads(nthreads)</code> chỉ định tổng số thread sẽ được tạo.<br />
Pragma này cũng sẽ <strong>join</strong> (hợp nhất) tất cả các thread đã tạo về lại tiến trình đơn luồng.<br />
Nói cách khác, toàn bộ công việc cấp thấp như tạo và join thread được <strong>trừu tượng hóa</strong> khỏi lập trình viên và chỉ cần một pragma duy nhất để thực hiện.<br />
Vì lý do này, OpenMP được xem là một thư viện <strong>implicit threading</strong> (đa luồng ngầm định).</p>
<p>OpenMP cũng trừu tượng hóa việc quản lý <strong>thread ID</strong>.<br />
Trong ngữ cảnh của <code>HelloWorld</code>, hàm <code>omp_get_thread_num</code> sẽ lấy ra <strong>ID duy nhất</strong> gắn với thread đang chạy nó.</p>
<h4 id="biên-dịch-mã-nguồn"><a class="header" href="#biên-dịch-mã-nguồn">Biên dịch mã nguồn</a></h4>
<p>Hãy biên dịch và chạy chương trình này bằng cách truyền cờ <code>-fopenmp</code> cho trình biên dịch, báo hiệu rằng chúng ta đang biên dịch với OpenMP:</p>
<pre><code>$ gcc -o hello_mp hello_mp.c -fopenmp

$ ./hello_mp 4
Hello world! I am thread 2
Hello world! I am thread 3
Hello world! I am thread 0
Hello world! I am thread 1
</code></pre>
<p>Vì thứ tự thực thi của các thread có thể thay đổi ở những lần chạy sau, chạy lại chương trình này sẽ cho ra một chuỗi thông báo khác:</p>
<pre><code>$ ./hello_mp 4
Hello world! I am thread 3
Hello world! I am thread 2
Hello world! I am thread 1
Hello world! I am thread 0
</code></pre>
<p>Hành vi này giống với <a href="posix.html#_hello_threading_writing_your_first_multithreaded_program">ví dụ dùng Pthreads</a> mà chúng ta đã thấy trước đó.</p>
<h3 id="1473-ví-dụ-phức-tạp-hơn-countsort-với-openmp"><a class="header" href="#1473-ví-dụ-phức-tạp-hơn-countsort-với-openmp">14.7.3. Ví dụ phức tạp hơn: CountSort với OpenMP</a></h3>
<p>Một ưu điểm mạnh mẽ của OpenMP là nó cho phép lập trình viên <strong>song song hóa dần dần</strong> (incrementally parallelize) mã nguồn của mình.<br />
Để thấy điều này trong thực tế, hãy song song hóa thuật toán <strong>CountSort</strong> phức tạp hơn mà chúng ta đã thảo luận trước đó trong chương này (mã tuần tự nằm tại: <a href="_attachments/countSort.c">countSort.c</a>).</p>
<p>Hãy nhớ rằng thuật toán này sắp xếp các mảng chứa một phạm vi giá trị nhỏ.<br />
Hàm <code>main</code> của chương trình tuần tự trông như sau:</p>
<pre><code class="language-c">int main( int argc, char **argv ) {
    //parse args (omitted for brevity)

    srand(10); //use of static seed ensures the output is the same every run

    //generate random array of elements of specified length
    //(omitted for brevity)

    //allocate counts array and initializes all elements to zero.
    int counts[MAX] = {0};

    countElems(counts, array, length); //calls step 1
    writeArray(counts, array); //calls step2

    free(array); //free memory

    return 0;
}
</code></pre>
<p>Hàm <code>main</code>, sau khi phân tích các tham số dòng lệnh và tạo một mảng ngẫu nhiên, sẽ gọi hàm <code>countsElems</code> rồi đến hàm <code>writeArray</code>.</p>
<h4 id="song-song-hóa-countelems-bằng-openmp"><a class="header" href="#song-song-hóa-countelems-bằng-openmp">Song song hóa CountElems bằng OpenMP</a></h4>
<p>Có nhiều cách để song song hóa chương trình trên.<br />
Một cách (được minh họa trong ví dụ sau) là sử dụng <strong>pragma</strong> <code>omp parallel</code> trong ngữ cảnh của các hàm <code>countElems</code> và <code>writeArray</code>.<br />
Kết quả là <strong>không cần</strong> thay đổi gì trong hàm <code>main</code>.<br />
Phiên bản đầy đủ của chương trình có tại: <a href="_attachments/countSort_mp.c">countSort_mp.c</a>.</p>
<p>Trước tiên, hãy xem cách song song hóa hàm <code>countElems</code> bằng OpenMP:</p>
<pre><code class="language-c">void countElems(int *counts, int *array, long length) {

    #pragma omp parallel default(none) shared(counts, array, length)
    {
        int val, i, local[MAX] = {0};
        #pragma omp for
        for (i = 0; i &lt; length; i++) {
            val = array[i];
            local[val]++;
        }

       #pragma omp critical
       {
           for (i = 0; i &lt; MAX; i++) {
               counts[i] += local[i];
           }
       }
   }
}
</code></pre>
<p>Trong phiên bản này của mã, ba pragma được sử dụng:</p>
<ul>
<li>
<p><strong><code>#pragma omp parallel</code></strong>: chỉ định rằng một <strong>team</strong> (nhóm) các thread sẽ được tạo.<br />
Lệnh <code>omp_set_num_threads(nthreads)</code> trong <code>main</code> đặt kích thước mặc định của team thread là <code>nthreads</code>.<br />
Nếu không dùng hàm <code>omp_set_num_threads</code>, số lượng thread sẽ mặc định bằng số lượng core trong hệ thống.<br />
Nhắc lại: pragma <code>omp parallel</code> sẽ <strong>ngầm định</strong> tạo thread ở đầu khối và <strong>join</strong> chúng ở cuối khối.<br />
Dấu ngoặc nhọn <code>{}</code> được dùng để xác định phạm vi.<br />
Mệnh đề <code>shared</code> khai báo rằng các biến <code>counts</code>, <code>array</code> và <code>length</code> là <strong>shared</strong> (toàn cục) giữa tất cả các thread.<br />
Do đó, các biến <code>val</code>, <code>i</code> và <code>local[MAX]</code> sẽ được khai báo <strong>cục bộ</strong> trong từng thread.</p>
</li>
<li>
<p><strong><code>#pragma omp for</code></strong>: song song hóa vòng lặp <code>for</code>, chia số vòng lặp cho các thread.<br />
OpenMP sẽ tính toán cách chia vòng lặp tối ưu.<br />
Như đã đề cập trước đó, chiến lược mặc định thường là phương pháp <strong>chunking</strong>, trong đó mỗi thread nhận xấp xỉ cùng số vòng lặp để xử lý.<br />
Như vậy, mỗi thread sẽ đọc một phần của mảng <code>array</code> chia sẻ và cộng dồn kết quả vào mảng <code>local</code> cục bộ của nó.</p>
</li>
<li>
<p><strong><code>#pragma omp critical</code></strong>: chỉ định rằng đoạn mã trong phạm vi critical section chỉ được thực thi bởi <strong>một thread</strong> tại một thời điểm.<br />
Điều này tương đương với việc dùng <strong>mutex</strong> trong phiên bản Pthreads của chương trình.<br />
Ở đây, mỗi thread sẽ lần lượt cập nhật mảng <code>counts</code> chia sẻ.</p>
</li>
</ul>
<p>Hãy đánh giá hiệu năng của hàm này khi chạy với 100 triệu phần tử:</p>
<pre><code>$ ./countElems_mp 100000000 1
Run Time for Phase 1 is 0.249893

$ ./countElems_mp 100000000 2
Run Time for Phase 1 is 0.124462

$ ./countElems_mp 100000000 4
Run Time for Phase 1 is 0.068749
</code></pre>
<p>Kết quả rất tốt: hàm đạt <strong>speedup</strong> bằng 2 khi chạy với 2 thread, và <strong>speedup</strong> 3.63 khi chạy với 4 thread.<br />
Hiệu năng thậm chí còn tốt hơn cả phiên bản Pthreads!</p>
<h4 id="hàm-writearray-trong-openmp"><a class="header" href="#hàm-writearray-trong-openmp">Hàm <code>writeArray</code> trong OpenMP</a></h4>
<p>Song song hóa hàm <code>writeArray</code> <strong>khó hơn nhiều</strong>.<br />
Đoạn mã sau minh họa một giải pháp khả thi:</p>
<pre><code class="language-c">void writeArray(int *counts, int *array) {
    int i;

    // giả định số lượng thread không vượt quá MAX
    #pragma omp parallel for schedule(dynamic)
    for (i = 0; i &lt; MAX; i++) {
        int j = 0, amt, start = 0;
        for (j = 0; j &lt; i; j++) {  // tính toán vị trí bắt đầu &quot;thực&quot;
            start += counts[j];
        }

        amt = counts[i]; // số lượng phần tử cần ghi

        // ghi đè amt phần tử bằng giá trị i, bắt đầu từ vị trí start
        for (j = start; j &lt; start + amt; j++) {
            array[j] = i;
        }
    }
}
</code></pre>
<p>Trước khi song song hóa, chúng tôi đã thay đổi hàm này vì <a href="_attachments/countSort.c">phiên bản cũ</a> của <code>writeArray</code> khiến biến <code>j</code> phụ thuộc vào các vòng lặp trước đó.<br />
Trong phiên bản mới, mỗi thread sẽ tính toán giá trị <code>start</code> duy nhất của mình dựa trên tổng của tất cả các phần tử trước đó trong <code>counts</code>.</p>
<p>Khi loại bỏ sự phụ thuộc này, việc song song hóa trở nên khá đơn giản.<br />
Pragma <code>#pragma omp parallel for</code> sẽ tạo ra một nhóm thread và song song hóa vòng lặp <code>for</code> bằng cách gán cho mỗi thread một tập con các vòng lặp cần thực hiện.<br />
Nhắc lại, pragma này là sự kết hợp của <code>omp parallel</code> và <code>omp for</code> (đã được sử dụng trong phần song song hóa hàm <code>countElems</code>).</p>
<p>Cách lập lịch theo kiểu <strong>chunking</strong> (như trong hàm <code>countElems</code> trước đó) <strong>không phù hợp</strong> ở đây, vì có khả năng mỗi phần tử trong <code>counts</code> có tần suất rất khác nhau.<br />
Điều này dẫn đến việc các thread sẽ không có khối lượng công việc bằng nhau, khiến một số thread bị gán nhiều việc hơn các thread khác.<br />
Do đó, ta sử dụng mệnh đề <code>schedule(dynamic)</code>, để mỗi thread hoàn thành vòng lặp được gán trước khi yêu cầu một vòng lặp mới từ bộ quản lý thread.</p>
<p>Vì mỗi thread ghi vào các vị trí khác nhau trong mảng, nên <strong>không cần</strong> dùng mutual exclusion (loại trừ lẫn nhau) cho hàm này.</p>
<p>Hãy chú ý xem mã OpenMP gọn gàng hơn nhiều so với phiên bản dùng POSIX threads.<br />
Mã rất dễ đọc và chỉ cần chỉnh sửa rất ít.<br />
Đây là một trong những sức mạnh của <strong>abstraction</strong> (trừu tượng hóa), khi các chi tiết triển khai được ẩn khỏi lập trình viên.</p>
<p>Tuy nhiên, một sự đánh đổi cần thiết của abstraction là <strong>quyền kiểm soát</strong>.<br />
Lập trình viên giả định rằng trình biên dịch “đủ thông minh” để xử lý các chi tiết song song hóa, nhờ đó việc song song hóa ứng dụng trở nên dễ dàng hơn.<br />
Tuy nhiên, lập trình viên sẽ không còn đưa ra các quyết định chi tiết về cách song song hóa đó.<br />
Nếu không hiểu rõ cách các pragma OpenMP thực thi bên trong, sẽ khó để debug một ứng dụng OpenMP hoặc biết pragma nào là phù hợp nhất để dùng trong một tình huống cụ thể.</p>
<h3 id="1474-tìm-hiểu-thêm-về-openmp"><a class="header" href="#1474-tìm-hiểu-thêm-về-openmp">14.7.4. Tìm hiểu thêm về OpenMP</a></h3>
<p>Phần thảo luận sâu hơn về OpenMP nằm ngoài phạm vi của cuốn sách này, nhưng có một số tài nguyên miễn phí hữu ích<sup class="footnote-reference"><a href="#1">1</a></sup><sup class="footnote-reference"><a href="#2">2</a></sup> để học OpenMP.</p>
<h3 id="tài-liệu-tham-khảo"><a class="header" href="#tài-liệu-tham-khảo">Tài liệu tham khảo:</a></h3>
<ol>
<li>
<p>Blaise Barney. “OpenMP”.<br />
<a href="https://hpc.llnl.gov/tuts/openMP/">https://hpc.llnl.gov/tuts/openMP/</a></p>
</li>
<li>
<p>Richard Brown và Libby Shoop. “Multicore Programming with OpenMP”.<br />
<em>CSinParallel: Parallel Computing in the Computer Science curriculum</em>.<br />
<a href="http://selkie.macalester.edu/csinparallel/modules/MulticoreProgramming/build/html/index.html">http://selkie.macalester.edu/csinparallel/modules/MulticoreProgramming/build/html/index.html</a></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C14-SharedMemory/thread_safety.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C14-SharedMemory/summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C14-SharedMemory/thread_safety.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C14-SharedMemory/summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
