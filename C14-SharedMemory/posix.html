<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>POSIX Threads - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html" class="active"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="142-hello-threading-writing-your-first-multithreaded-program"><a class="header" href="#142-hello-threading-writing-your-first-multithreaded-program">14.2. Hello Threading! Writing Your First Multithreaded Program</a></h2>
<p>In this section, we examine the ubiquitous POSIX thread library
<strong>Pthreads</strong>. POSIX is an acronym for Portable Operating System
Interface. It is an IEEE standard that specifies how UNIX systems look,
act, and feel. The POSIX threads API is available on almost all
UNIX-like operating systems, each of which meets the standard in its
entirety or to some great degree. So, if you write parallel code using
POSIX threads on a Linux machine, it will certainly work on other Linux
machines, and it will likely work on machines running macOS or other
UNIX variants.</p>
<p>Let's begin by analyzing an example &quot;Hello World&quot; Pthreads program
(<a href="_attachments/hellothreads.c">hellothreads.c</a>). For brevity, we have
excluded error handling in the listing, though the <a href="_attachments/hellothreads.c">downloadable
version</a> contains sample error handling.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

/* The &quot;thread function&quot; passed to pthread_create.  Each thread executes this
 * function and terminates when it returns from this function. */
void *HelloWorld(void *id) {

    /* We know the argument is a pointer to a long, so we cast it from a
     * generic (void *) to a (long *). */
    long *myid = (long *) id;

    printf(&quot;Hello world! I am thread %ld\n&quot;, *myid);

    return NULL; // We don't need our threads to return anything.
}

int main(int argc, char **argv) {
    int i;
    int nthreads; //number of threads
    pthread_t *thread_array; //pointer to future thread array
    long *thread_ids;

    // Read the number of threads to create from the command line.
    if (argc !=2) {
        fprintf(stderr, &quot;usage: %s &lt;n&gt;\n&quot;, argv[0]);
        fprintf(stderr, &quot;where &lt;n&gt; is the number of threads\n&quot;);
        return 1;
    }
    nthreads = strtol(argv[1], NULL, 10);

    // Allocate space for thread structs and identifiers.
    thread_array = malloc(nthreads * sizeof(pthread_t));
    thread_ids = malloc(nthreads * sizeof(long));

    // Assign each thread an ID and create all the threads.
    for (i = 0; i &lt; nthreads; i++) {
        thread_ids[i] = i;
        pthread_create(&amp;thread_array[i], NULL, HelloWorld, &amp;thread_ids[i]);
    }

    /* Join all the threads. Main will pause in this loop until all threads
     * have returned from the thread function. */
    for (i = 0; i &lt; nthreads; i++) {
        pthread_join(thread_array[i], NULL);
    }

    free(thread_array);
    free(thread_ids);

    return 0;
}
</code></pre>
<p>Let's examine this program in smaller components.</p>
<ul>
<li>
<p>Notice the inclusion of the <code>pthread.h</code> header file, which declares
<code>pthread</code> types and functions.</p>
</li>
<li>
<p>Next, the <code>HelloWorld</code> function defines the <strong>thread function</strong> that
we later pass to <code>pthread_create</code>. A thread function is analogous to
a <code>main</code> function for a worker (created) thread --- a thread begins
execution at the start of its thread function and terminates when it
reaches the end. Each thread executes the thread function using its
private execution state (i.e., its own stack memory and register
values). Note also that the thread function is of type <code>void*</code>.
Specifying an <a href="../C2-C_depth/advanced_voidstar.html#_c_voidstar_recasting_"><strong>anonymous
pointer</strong></a>
in this context allows programmers to write thread functions that
deal with arguments and return values of different types.</p>
</li>
<li>
<p>Lastly, in the <code>main</code> function, the main thread initializes the
program state before creating and joining the worker threads.</p>
</li>
</ul>
<h3 id="1421-creating-and-joining-threads"><a class="header" href="#1421-creating-and-joining-threads">14.2.1. Creating and Joining Threads</a></h3>
<p>The program first starts as a single-threaded process. As it executes
the <code>main</code> function, it reads the number of threads to create, and it
allocates memory for two arrays: <code>thread_array</code> and <code>thread_ids</code>. The
<code>thread_array</code> array contains the set of addresses for each thread
created. The <code>thread_ids</code> array stores the set of arguments that each
thread is passed. In this example, each thread is passed the address of
its rank (or ID, represented by <code>thread_ids[i]</code>).</p>
<p>After all the preliminary variables are allocated and initialized, the
<code>main</code> thread executes the two major steps of multithreading:</p>
<ul>
<li>
<p>The <strong>creation</strong> step, in which the main thread spawns one or more
worker threads. After being spawned, each worker thread runs within
its own execution context concurrently with the other threads and
processes on the system.</p>
</li>
<li>
<p>The <strong>join</strong> step, in which the main thread waits for all the
workers to complete before proceeding as a single-thread process.
Joining a thread that has terminated frees the thread's execution
context and resources. Attempting to join a thread that <em>hasn't</em>
terminated blocks the caller until the thread terminates, similar to
the semantics of the <a href="../C13-OS/processes.html#_exit_and_wait">wait function for
processes</a>.</p>
</li>
</ul>
<p>The Pthreads library offers a <code>pthread_create</code> function for creating
threads and a <code>pthread_join</code> function for joining them. The
<code>pthread_create</code> function has the following signature:</p>
<pre><code>pthread_create(pthread_t *thread, const pthread_attr_t *attr,
               void *thread_function, void *thread_args)
</code></pre>
<p>The function takes a pointer to a thread struct (of type <code>pthread_t</code>), a
pointer to an attribute struct (normally set to <code>NULL</code>), the name of the
function the thread should execute, and the array of arguments to pass
to the thread function when it starts.</p>
<p>The Hello World program calls <code>pthread_create</code> in the <code>main</code> function
using:</p>
<pre><code>pthread_create(&amp;thread_array[i], NULL, HelloWorld, &amp;thread_ids[i]);
</code></pre>
<p>Here:</p>
<ul>
<li>
<p><code>&amp;thread_array[i]</code> contains the address of thread <em>i</em>. The
<code>pthread_create</code> function allocates a <code>pthread_t</code> thread object and
stores its address at this location, enabling the programmer to
reference the thread later (e.g., when joining it).</p>
</li>
<li>
<p><code>NULL</code> specifies that the thread should be created with default
attributes. In most programs, it is safe to leave this second
parameter as <code>NULL</code>.</p>
</li>
<li>
<p><code>HelloWorld</code> names the thread function that the created thread
should execute. This function behaves like the &quot;main&quot; function for
the thread. For an arbitrary thread function (e.g., <code>function</code>), its
prototype must match the form <code>void * function(void *)</code>.</p>
</li>
<li>
<p><code>&amp;thread_ids[i]</code> specifies the address of the arguments to be passed
to thread <em>i</em>. In this case, <code>thread_ids[i]</code> contains a single
<code>long</code> representing the thread's ID. Since the last argument to
<code>pthread_create</code> must be a pointer, we pass the <em>address</em> of the
thread's ID.</p>
</li>
</ul>
<p>To generate several threads that execute the <code>HelloWorld</code> thread
function, the program assigns each thread a unique ID and creates each
thread within a <code>for</code> loop:</p>
<pre><code>for (i = 0; i &lt; nthreads; i++) {
    thread_ids[i] = i;
    pthread_create(&amp;thread_array[i], NULL, HelloWorld, &amp;thread_ids[i]);
}
</code></pre>
<p>The OS schedules the execution of each created thread; the user cannot
make any assumption on the order in which the threads will execute.</p>
<p>The <code>pthread_join</code> function suspends the execution of its caller until
the thread it references terminates. Its signature is:</p>
<pre><code>pthread_join(pthread_t thread, void **return_val)
</code></pre>
<p>The <code>pthread_join</code> takes as input a <code>pthread_t</code> struct, indicating which
thread to wait on, and an optional pointer argument that specifies where
the thread's return value should be stored.</p>
<p>The Hello World program calls <code>pthread_join</code> in <code>main</code> using:</p>
<pre><code>pthread_join(thread_array[t], NULL);
</code></pre>
<p>This line indicates that the main thread must wait on the termination of
thread <code>t</code>. Passing <code>NULL</code> as the second argument indicates that the
program does not use the thread's return value.</p>
<p>In the previous program, <code>main</code> calls <code>pthread_join</code> in a loop because
<em>all</em> of the worker threads need to terminate before the <code>main</code> function
proceeds to clean up memory and terminate the process:</p>
<pre><code>for (i = 0; i &lt; nthreads; i++) {
    pthread_join(thread_array[i], NULL);
}
</code></pre>
<h3 id="1422-the-thread-function"><a class="header" href="#1422-the-thread-function">14.2.2. The Thread Function</a></h3>
<p>In the previous program, each spawned thread prints out
<code>Hello world! I am thread n</code>, where <code>n</code> is the thread's unique id. After
the thread prints out its message, it terminates. Let's take a closer
look at the <code>HelloWorld</code> function:</p>
<pre><code>void *HelloWorld(void *id) {
    long *myid = (long*)id;

    printf(&quot;Hello world! I am thread %ld\n&quot;, *myid);

    return NULL;
}
</code></pre>
<p>Recall that <code>pthread_create</code> passes the arguments to the thread function
using the <code>thread_args</code> parameter. In the <code>pthread_create</code> function in
<code>main</code>, the Hello World program specified that this parameter is in fact
the thread's ID. Note that the parameter to <code>HelloWorld</code> must be
declared as a generic or <a href="../C2-C_depth/advanced_voidstar.html#_c_voidstar_recasting_">anonymous pointer
(<code>void *</code>)</a>.
The Pthreads library uses <code>void *</code> to make <code>pthread_create</code> more general
purpose by not prescribing a parameter type. As a programmer, the
<code>void *</code> is mildly inconvenient given that it must be recast before use.
Here, we <em>know</em> the parameter is of type <code>long *</code> because that's what we
passed to <code>pthread_create</code> in <code>main</code>. Thus, we can safely cast the value
as a <code>long *</code> and dereference the pointer to access the <code>long</code> value.
Many parallel programs follow this structure.</p>
<p>Similar to the thread function's parameter, the Pthreads library avoids
prescribing the thread function's return type by specifying another
<code>void *</code> --- the programmer is free to return any pointer from the
thread function. If the program needs to access the thread's return
value, it can retrieve it via the second argument to <code>pthread_join</code>. In
our example, the thread has no need to return a value, so it simply
returns a <code>NULL</code> pointer.</p>
<h3 id="1423-running-the-code"><a class="header" href="#1423-running-the-code">14.2.3. Running the Code</a></h3>
<p>The command that follows shows how to use GCC to compile
<a href="_attachments/hellothreads.c">hellothreads.c</a>. Building a Pthreads
application requires that the <code>-pthread</code> linker flag be passed to GCC to
ensure that the Pthreads functions and types are accessible:</p>
<pre><code>$ gcc -o hellothreads hellothreads.c -pthread
</code></pre>
<p>Running the program without a command line argument results in a usage
message:</p>
<pre><code>$ ./hellothreads
usage: ./hellothreads &lt;n&gt;
where &lt;n&gt; is the number of threads
</code></pre>
<p>Running the program with four threads yields the following output:</p>
<pre><code>$ ./hellothreads 4
Hello world! I am thread 1
Hello world! I am thread 2
Hello world! I am thread 3
Hello world! I am thread 0
</code></pre>
<p>Notice that each thread prints its unique ID number. In this run, thread
1's output displays first, followed by threads 2, 3, and 0. If we run
the program again, we may see the output displayed in a different order:</p>
<pre><code>$ ./hellothreads 4
Hello world! I am thread 0
Hello world! I am thread 1
Hello world! I am thread 2
Hello world! I am thread 3
</code></pre>
<p>Recall that the operating system's scheduler determines the thread
execution order. From a user's perspective, the order is <em>effectively
random</em> due to being influenced by many factors that vary outside the
user's control (e.g., available system resources, the system receiving
input, or OS scheduling). Since all threads are running concurrently
with one another and each thread executes a call to <code>printf</code> (which
prints to <code>stdout</code>), the first thread that prints to <code>stdout</code> will have
its output show up first. Subsequent executions may (or may not) result
in different output.</p>
<p>+-----------------------------------+-----------------------------------+
|                                   |                          |
|                                   | Thread Execution Order            |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | You should <em>never</em> make any       |
|                                   | assumptions about the order in    |
|                                   | which threads will execute. If    |
|                                   | the correctness of your program   |
|                                   | requires that threads run in a    |
|                                   | particular order, you must add    |
|                                   | [<strong>sync                           |
|                                   | hronization</strong>](synchronization.ht |
|                                   | ml#_synchronizing_threads) |
|                                   | to your program to prevent        |
|                                   | threads from running when they    |
|                                   | shouldn't.                        |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+</p>
<h3 id="1424-revisiting-scalar-multiplication"><a class="header" href="#1424-revisiting-scalar-multiplication">14.2.4. Revisiting Scalar Multiplication</a></h3>
<p>Let's explore how to create a multithreaded implementation of the
<a href="multicore.html#_an_example_scalar_multiplication">scalar
multiplication</a>
program from the previous section. Recall that our general strategy for
parallelizing <code>scalar_multiply</code> is to:</p>
<ol>
<li>
<p>Create multiple threads,</p>
</li>
<li>
<p>Assign each thread a subset of the input array,</p>
</li>
<li>
<p>Instruct each thread to multiply the elements in its array subset by
<code>s</code>.</p>
</li>
</ol>
<p>The following is a thread function that accomplishes this task. Notice
that we have moved <code>array</code>, <code>length</code>, and <code>s</code> to the global scope of the
program.</p>
<pre><code>long *array; //allocated in main
long length; //set in main (1 billion)
long nthreads; //number of threads
long s; //scalar

void *scalar_multiply(void *id) {
    long *myid = (long *) id;
    int i;

    //assign each thread its own chunk of elements to process
    long chunk = length / nthreads;
    long start = *myid * chunk;
    long end  = start + chunk;
    if (*myid == nthreads - 1) {
        end = length;
    }

    //perform scalar multiplication on assigned chunk
    for (i = start; i &lt; end; i++) {
        array[i] *= s;
    }

    return NULL;
}
</code></pre>
<p>Let's break this down into parts. Recall that the first step is to
assign each thread a component of the array. The following lines
accomplish this task:</p>
<pre><code>long chunk = length / nthreads;
long start = *myid * chunk;
long end  = start + chunk;
</code></pre>
<p>The variable <code>chunk</code> stores the number of elements that each thread is
assigned. To ensure that each thread gets roughly the same amount of
work, we first set the chunk size to the number of elements divided by
the number of threads, or <code>length / nthreads</code>.</p>
<p>Next, we assign each thread a distinct range of elements to process.
Each thread computes its range's <code>start</code> and <code>end</code> index using the
<code>chunk</code> size and its unique thread ID.</p>
<p>For example, with four threads (with IDs 0-3) operating over an array
with 100 million elements, each thread is responsible for processing a
25 million element <code>chunk</code>. Incorporating the thread ID assigns each
thread a unique subset of the input.</p>
<p>The next two lines account for the case in which <code>length</code> is not evenly
divisible by the number of threads:</p>
<pre><code>if (*myid == nthreads - 1) {
    end = length;
}
</code></pre>
<p>Suppose that we specified three rather than four threads. The nominal
chunk size would be 33,333,333 elements, leaving one element unaccounted
for. The code in the previous example would assign the remaining element
to the last thread.</p>
<p>+-----------------------------------+-----------------------------------+
|                                   |                          |
|                                   | Creating balanced input           |
|                                   | :::                               |
|                                   |                                   |
|                                   | ::: paragraph                     |
|                                   | The chunking code just shown is   |
|                                   | imperfect. In the case where the  |
|                                   | number of threads does not evenly |
|                                   | divide the input, the remainder   |
|                                   | is assigned to the last thread.   |
|                                   | Consider a sample run in which    |
|                                   | the array has 100 elements, and   |
|                                   | 12 threads are specified. The     |
|                                   | nominal chunk size would be 8,    |
|                                   | and the remainder would be 4.     |
|                                   | With the example code, the first  |
|                                   | 11 threads will each have 8       |
|                                   | assigned elements, whereas the    |
|                                   | last thread will be assigned 12   |
|                                   | elements. Consequently, the last  |
|                                   | thread performs 50% more work     |
|                                   | than the other threads. A         |
|                                   | potentially better way to chunk   |
|                                   | this example is to have the first |
|                                   | 4 threads process 9 elements      |
|                                   | each, while the last 8 threads    |
|                                   | process 8 elements each. This     |
|                                   | will result in better <strong>load      |
|                                   | balancing</strong> of the input across   |
|                                   | the threads.                      |
|                                   | :::                               |
+-----------------------------------+-----------------------------------+</p>
<p>With an appropriate local <code>start</code> and <code>end</code> index computed, each thread
is now ready to perform scalar multiplication on its component of the
array. The last portion of the <code>scalar_multiply</code> function accomplishes
this:</p>
<pre><code>for (i = start; i &lt; end; i++) {
    array[i] *= s;
}
</code></pre>
<h3 id="1425-improving-scalar-multiplication-multiple-arguments"><a class="header" href="#1425-improving-scalar-multiplication-multiple-arguments">14.2.5. Improving Scalar Multiplication: Multiple Arguments</a></h3>
<p>A key weakness of the previous implementation is the wide use of global
variables. Our original discussion of <a href="../C2-C_depth/scope_memory.html#_parts_of_program_memory_and_scope">global
variables</a>
showed that although useful, global variables should generally be
avoided in C. To reduce the number of global variables in the program,
one solution is to declare a <code>t_arg</code> struct as follows in the global
scope:</p>
<pre><code>struct t_arg {
    int *array; // pointer to shared array
    long length; // num elements in array
    long s; //scaling factor
    long numthreads; // total number of threads
    long id; //  logical thread id
};
</code></pre>
<p>Our main function would, in addition to allocating <code>array</code> and setting
local variables <code>length</code>, <code>nthreads</code>, and <code>s</code> (our scaling factor),
allocate an array of <code>t_arg</code> records:</p>
<pre><code>long nthreads = strtol(argv[1], NULL, 10); //get number of threads
long length = strtol(argv[2], NULL, 10); //get length of array
long s = strtol( argv[3], NULL, 10 ); //get scaling factor

int *array = malloc(length*sizeof(int));

//allocate space for thread structs and identifiers
pthread_t *thread_array = malloc(nthreads * sizeof(pthread_t));
struct t_arg *thread_args = malloc(nthreads * sizeof(struct t_arg));

//Populate thread arguments for all the threads
for (i = 0; i &lt; nthreads; i++){
    thread_args[i].array = array;
    thread_args[i].length = length;
    thread_args[i].s = s;
    thread_args[i].numthreads = nthreads;
    thread_args[i].id = i;
}
</code></pre>
<p>Later in <code>main</code>, when <code>pthread_create</code> is called, the thread's
associated <code>t_args</code> struct is passed as an argument:</p>
<pre><code>for (i = 0; i &lt; nthreads; i++){
    pthread_create(&amp;thread_array[i], NULL, scalar_multiply, &amp;thread_args[i]);
}
</code></pre>
<p>Lastly, our <code>scalar_multiply</code> function would look like the following:</p>
<pre><code>void * scalar_multiply(void* args) {
    //cast to a struct t_arg from void*
    struct t_arg * myargs = (struct t_arg *) args;

    //extract all variables from struct
    long myid =  myargs-&gt;id;
    long length = myargs-&gt;length;
    long s = myargs-&gt;s;
    long nthreads = myargs-&gt;numthreads;
    int * ap = myargs-&gt;array; //pointer to array in main

    //code as before
    long chunk = length/nthreads;
    long start = myid * chunk;
    long end  = start + chunk;
    if (myid == nthreads-1) {
        end = length;
    }

    int i;
    for (i = start; i &lt; end; i++) {
        ap[i] *= s;
    }

    return NULL;
}
</code></pre>
<p>Implementing this program fully is an exercise we leave to the reader.
Please note that error handling has been omitted for the sake of
brevity.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C14-SharedMemory/multicore.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C14-SharedMemory/synchronization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C14-SharedMemory/multicore.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C14-SharedMemory/synchronization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
