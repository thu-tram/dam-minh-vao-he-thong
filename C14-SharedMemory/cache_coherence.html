<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cache Coherence - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html" class="active"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="145-tính-nhất-quán-bộ-nhớ-đệm-cache-coherence-và-chia-sẻ-sai-false-sharing"><a class="header" href="#145-tính-nhất-quán-bộ-nhớ-đệm-cache-coherence-và-chia-sẻ-sai-false-sharing">14.5. Tính nhất quán bộ nhớ đệm (Cache Coherence) và Chia sẻ sai (False Sharing)</a></h2>
<p><strong>Multicore cache</strong> (bộ nhớ đệm trên hệ thống đa lõi) có thể ảnh hưởng sâu sắc đến hiệu năng của một chương trình <strong>multithreaded</strong> (đa luồng).<br />
Trước tiên, hãy cùng điểm lại nhanh một số <a href="../C11-MemHierarchy/caching.html#_cpu_caches">khái niệm cơ bản liên quan đến thiết kế cache</a>:</p>
<ul>
<li>
<p>Dữ liệu/lệnh không được vận chuyển <strong>từng phần tử riêng lẻ</strong> vào cache.<br />
Thay vào đó, dữ liệu được truyền theo <strong>block</strong> (khối), và kích thước block thường <strong>lớn hơn</strong> ở các mức thấp hơn của <strong>memory hierarchy</strong> (hệ thống phân cấp bộ nhớ).</p>
</li>
<li>
<p>Mỗi cache được tổ chức thành một tập hợp (<strong>set</strong>), mỗi set chứa một số <strong>line</strong> (dòng).<br />
Mỗi line lưu trữ một block dữ liệu.</p>
</li>
<li>
<p>Các bit riêng lẻ của <strong>memory address</strong> (địa chỉ bộ nhớ) được dùng để xác định <strong>set</strong>, <strong>tag</strong>, và <strong>block offset</strong> trong cache — nơi sẽ ghi block dữ liệu.</p>
</li>
<li>
<p><strong>Cache hit</strong> xảy ra khi block dữ liệu mong muốn đã tồn tại trong cache.<br />
Ngược lại, <strong>cache miss</strong> xảy ra khi block không có trong cache, và hệ thống sẽ tìm kiếm ở mức thấp hơn của memory hierarchy (có thể là cache cấp thấp hơn hoặc <strong>main memory</strong>).</p>
</li>
<li>
<p><strong>Valid bit</strong> cho biết block tại một line cụ thể trong cache có thể được sử dụng an toàn hay không.<br />
Nếu valid bit = 0, block dữ liệu tại line đó <strong>không thể</strong> được sử dụng (ví dụ: block có thể chứa dữ liệu từ một process đã thoát).</p>
</li>
<li>
<p>Dữ liệu được ghi vào cache/bộ nhớ dựa trên hai chiến lược chính:</p>
<ul>
<li><strong>Write-through</strong>: dữ liệu được ghi đồng thời vào cache và main memory.</li>
<li><strong>Write-back</strong>: dữ liệu chỉ được ghi vào cache và sẽ được ghi xuống các mức thấp hơn trong hierarchy <strong>sau khi</strong> block bị loại bỏ (evict) khỏi cache.</li>
</ul>
</li>
</ul>
<h3 id="1451-cache-trên-hệ-thống-đa-lõi-caches-on-multicore-systems"><a class="header" href="#1451-cache-trên-hệ-thống-đa-lõi-caches-on-multicore-systems">14.5.1. Cache trên hệ thống đa lõi (Caches on Multicore Systems)</a></h3>
<p><a href="../C11-MemHierarchy/coherency.html#_looking_ahead_caching_on_multicore_processors">Nhớ lại</a> rằng, trong <strong>shared memory architecture</strong> (kiến trúc bộ nhớ chia sẻ), mỗi <strong>core</strong> có thể có cache riêng, và nhiều core có thể chia sẻ một cache chung.</p>
<p><strong>Hình 1</strong> minh họa một ví dụ CPU hai lõi (<strong>dual-core CPU</strong>).<br />
Mặc dù mỗi core có <strong>L1 cache</strong> riêng, nhưng cả hai core chia sẻ chung một <strong>L2 cache</strong>.</p>
<p><img src="_images/multicore-cache.png" alt="dual core processor with separate L1 caches and shared L2 cache" /></p>
<p><strong>Hình 1.</strong> Ví dụ CPU hai lõi với L1 cache riêng và L2 cache dùng chung</p>
<p>Nhiều <strong>thread</strong> trong cùng một chương trình thực thi có thể chạy các <strong>function</strong> khác nhau.<br />
Nếu không có <a href="../C11-MemHierarchy/coherency.html#_cache_coherency"><strong>cache coherence strategy</strong></a> (chiến lược đảm bảo tính nhất quán bộ nhớ đệm) để đảm bảo mỗi cache duy trì một góc nhìn nhất quán về bộ nhớ chia sẻ, các biến chia sẻ có thể bị cập nhật <strong>không đồng bộ</strong>.</p>
<p>Ví dụ: xét CPU hai lõi trong <strong>Hình 1</strong>, mỗi core đang chạy một thread riêng biệt <strong>đồng thời</strong>:</p>
<ul>
<li>Thread trên <strong>Core 0</strong> có biến cục bộ <code>x</code>.</li>
<li>Thread trên <strong>Core 1</strong> có biến cục bộ <code>y</code>.</li>
<li>Cả hai thread cùng chia sẻ quyền truy cập biến toàn cục <code>g</code>.</li>
</ul>
<p><strong>Bảng 1</strong> cho thấy một kịch bản thực thi có thể xảy ra:</p>
<div class="table-wrapper"><table><thead><tr><th>Time</th><th>Core 0</th><th>Core 1</th></tr></thead><tbody>
<tr><td>0</td><td>g = 5</td><td>(other work)</td></tr>
<tr><td>1</td><td>(other work)</td><td>y = g * 4</td></tr>
<tr><td>2</td><td>x += g</td><td>y += g * 2</td></tr>
</tbody></table>
</div>
<p><strong>Bảng 1.</strong> Chia sẻ dữ liệu gây vấn đề do caching</p>
<p>Giả sử giá trị ban đầu của <code>g</code> là <strong>10</strong>, và giá trị ban đầu của <code>x</code> và <code>y</code> đều là <strong>0</strong>.<br />
Vậy giá trị cuối cùng của <code>y</code> sau chuỗi thao tác này là bao nhiêu?</p>
<p>Không có <strong>cache coherence</strong>, đây là câu hỏi rất khó trả lời, vì tồn tại ít nhất <strong>ba bản sao</strong> của <code>g</code>:</p>
<ol>
<li>Một bản trong <strong>L1 cache</strong> của Core 0.</li>
<li>Một bản trong <strong>L1 cache</strong> của Core 1.</li>
<li>Một bản khác trong <strong>L2 cache</strong> dùng chung.</li>
</ol>
<p><img src="_images/mc-cache-example.png" alt="A problematic update to the caches" /></p>
<p><strong>Hình 2.</strong> Một cập nhật gây vấn đề đối với cache không sử dụng cơ chế <strong>cache coherency</strong></p>
<p><strong>Hình 2</strong> minh họa một kết quả sai có thể xảy ra sau khi chuỗi thao tác trong <strong>Bảng 1</strong> hoàn tất.<br />
Giả sử L1 cache sử dụng <strong>write-back policy</strong> (chính sách ghi-lùi).<br />
Khi thread chạy trên <strong>Core 0</strong> ghi giá trị <code>5</code> vào <code>g</code>, nó chỉ cập nhật giá trị <code>g</code> trong <strong>L1 cache</strong> của Core 0.<br />
Giá trị <code>g</code> trong <strong>L1 cache</strong> của Core 1 vẫn là <code>10</code>, và bản sao trong <strong>L2 cache</strong> dùng chung cũng vẫn là <code>10</code>.<br />
Ngay cả khi sử dụng <strong>write-through policy</strong> (chính sách ghi-xuyên), cũng không có gì đảm bảo rằng bản sao <code>g</code> trong L1 cache của Core 1 sẽ được cập nhật!<br />
Trong trường hợp này, <code>y</code> sẽ có giá trị cuối cùng là <strong>60</strong>.</p>
<p>Một <strong>cache coherence strategy</strong> (chiến lược đảm bảo tính nhất quán bộ nhớ đệm) sẽ <strong>invalide</strong> (vô hiệu hóa) hoặc <strong>update</strong> (cập nhật) các bản sao dữ liệu chia sẻ trong các cache khác khi một cache ghi dữ liệu vào giá trị chia sẻ đó.<br />
<strong>Protocol Modified Shared Invalid (MSI)</strong> (xem chi tiết trong <a href="../C11-MemHierarchy/coherency.html#_the_msi_protocol">Chương 11.6</a>) là một ví dụ về <strong>invalidating cache coherence protocol</strong> (giao thức nhất quán bộ nhớ đệm kiểu vô hiệu hóa).</p>
<p>Một kỹ thuật phổ biến để triển khai MSI là <strong>snooping</strong>.<br />
Một <strong>snoopy cache</strong> sẽ “nghe lén” (snoop) trên <strong>memory bus</strong> để phát hiện các tín hiệu ghi.<br />
Nếu snoopy cache phát hiện một thao tác ghi vào một <strong>shared cache block</strong> (khối cache chia sẻ), nó sẽ <strong>invalidate</strong> line chứa block đó.<br />
Kết quả là chỉ còn <strong>một bản hợp lệ duy nhất</strong> của block nằm trong cache vừa được ghi, trong khi <strong>tất cả các bản sao khác</strong> của block trong các cache khác sẽ bị đánh dấu là <strong>invalid</strong>.</p>
<p>Việc áp dụng giao thức MSI với snooping sẽ cho ra kết quả đúng là gán giá trị <strong>30</strong> cho biến <code>y</code> trong ví dụ trước.</p>
<h3 id="1452-false-sharing"><a class="header" href="#1452-false-sharing">14.5.2. False Sharing</a></h3>
<p><strong>Cache coherence</strong> đảm bảo tính đúng đắn, nhưng nó cũng có thể gây ảnh hưởng tiêu cực đến hiệu năng.<br />
Hãy nhớ rằng khi thread trên Core 0 cập nhật <code>g</code>, <strong>snoopy cache</strong> sẽ <strong>invalidate</strong> không chỉ <code>g</code>, mà <strong>toàn bộ cache line</strong> chứa <code>g</code>.</p>
<p>Xét <a href="_attachments/countElems_p.c">phiên bản thử nghiệm ban đầu</a> của chúng ta khi <strong>parallelize</strong> (song song hóa) hàm <code>countElems</code> trong thuật toán <strong>CountSort</strong>.<br />
Để tiện theo dõi, hàm này được trích lại ở đây:</p>
<pre><code class="language-c">/*parallel version of step 1 (first cut) of CountSort algorithm:
 * extracts arguments from args value
 * calculates portion of the array this thread is responsible for counting
 * computes the frequency of all the elements in assigned component and stores
 * the associated counts of each element in counts array
*/
void *countElems(void *args){
    //extract arguments
    //ommitted for brevity
    int *array = myargs-&gt;ap;
    long *counts = myargs-&gt;countp;

    //assign work to the thread
    //compute chunk, start, and end
    //ommited for brevity

    long i;
    //heart of the program
    for (i = start; i &lt; end; i++){
        val = array[i];
        counts[val] = counts[val] + 1;
    }

    return NULL;
}
</code></pre>
<p>Trong phần thảo luận trước về hàm này, chúng ta đã chỉ ra rằng <strong>data race</strong> có thể khiến mảng <code>counts</code> không được điền đúng tập giá trị đếm.<br />
Bây giờ, hãy xem điều gì xảy ra nếu chúng ta thử <strong>đo thời gian</strong> chạy hàm này.<br />
Ta thêm code đo thời gian vào <code>main</code> bằng <code>gettimeofday</code> giống hệt như trong <a href="_attachments/countElems_p_v3.c">countElems_p_v3.c</a>.</p>
<p>Kết quả benchmark phiên bản ban đầu của <code>countElems</code> trên 100 triệu phần tử như sau:</p>
<pre><code>$ ./countElems_p 100000000 0 1
Time for Step 1 is 0.336239 s

$ ./countElems_p 100000000 0 2
Time for Step 1 is 0.799464 s

$ ./countElems_p 100000000 0 4
Time for Step 1 is 0.767003 s
</code></pre>
<p>Ngay cả <strong>khi không có bất kỳ cơ chế đồng bộ nào</strong>, phiên bản này của chương trình <strong>vẫn chạy chậm hơn</strong> khi số lượng thread tăng lên!</p>
<p>Để hiểu chuyện gì đang xảy ra, hãy xem lại mảng <code>counts</code>.<br />
Mảng <code>counts</code> lưu tần suất xuất hiện của mỗi số trong mảng đầu vào.<br />
Giá trị lớn nhất được xác định bởi biến <code>MAX</code>.<br />
Trong chương trình ví dụ, <code>MAX = 10</code>.<br />
Nói cách khác, mảng <code>counts</code> chiếm <strong>40 byte</strong> dung lượng.</p>
<p>Hãy nhớ rằng thông tin <a href="../C11-MemHierarchy/coherency.html#_looking_ahead_caching_on_multicore_processors">cache details</a> trên hệ thống Linux nằm trong thư mục <code>/sys/devices/system/cpu/</code>.<br />
Mỗi <strong>logical core</strong> có thư mục con <code>cpuk</code> (trong đó <code>k</code> là số thứ tự core).<br />
Mỗi thư mục <code>cpu</code> lại có các thư mục <code>index</code> riêng, biểu thị các cache có sẵn cho core đó.</p>
<p>Các thư mục <code>index</code> chứa nhiều tệp mô tả chi tiết về cache của từng logical core.<br />
Nội dung ví dụ của thư mục <code>index0</code> (thường tương ứng với L1 cache trên Linux) như sau:</p>
<pre><code>$ ls /sys/devices/system/cpu/cpu0/cache/index0
coherency_line_size      power            type
level                    shared_cpu_list  uevent
number_of_sets           shared_cpu_map   ways_of_associativity
physical_line_partition  size
</code></pre>
<p>Để biết kích thước <strong>cache line</strong> của L1 cache, dùng lệnh:</p>
<pre><code>$ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size
64
</code></pre>
<p>Kết quả cho thấy <strong>L1 cache line size</strong> của máy là <strong>64 byte</strong>.<br />
Điều này có nghĩa là mảng <code>counts</code> 40 byte <strong>nằm gọn trong một cache line</strong>.</p>
<p>Hãy nhớ rằng với các <strong>invalidating cache coherence protocol</strong> như MSI, mỗi khi chương trình cập nhật một biến chia sẻ, <strong>toàn bộ cache line</strong> trong các cache khác chứa biến đó sẽ bị <strong>invalidate</strong>.</p>
<p>Xem điều gì xảy ra khi hai thread chạy hàm trên.<br />
Một kịch bản thực thi có thể xảy ra được thể hiện trong <strong>Bảng 2</strong> (giả sử mỗi thread chạy trên một core riêng, và biến <code>x</code> là biến cục bộ của từng thread):</p>
<div class="table-wrapper"><table><thead><tr><th>Time</th><th>Thread 0</th><th>Thread 1</th></tr></thead><tbody>
<tr><td><em>i</em></td><td>Reads array[x] (1)</td><td>...</td></tr>
<tr><td><em>i+1</em></td><td>Increments counts[1]</td><td>Reads array[x] (4)</td></tr>
<tr><td></td><td>(<strong>invalidates cache line</strong>)</td><td></td></tr>
<tr><td><em>i+2</em></td><td>Reads array[x] (6)</td><td>Increments counts[4]</td></tr>
<tr><td></td><td></td><td>(<strong>invalidates cache line</strong>)</td></tr>
<tr><td><em>i+3</em></td><td>Increments counts[6]</td><td>Reads array[x] (2)</td></tr>
<tr><td></td><td>(<strong>invalidates cache line</strong>)</td><td></td></tr>
<tr><td><em>i+4</em></td><td>Reads array[x] (3)</td><td>Increments counts[2]</td></tr>
<tr><td></td><td></td><td>(<strong>invalidates cache line</strong>)</td></tr>
<tr><td><em>i+5</em></td><td>Increments counts[3]</td><td>...</td></tr>
<tr><td></td><td>(<strong>invalidates cache line</strong>)</td><td></td></tr>
</tbody></table>
</div>
<p><strong>Bảng 2.</strong> Một chuỗi thực thi có thể xảy ra của hai thread chạy <code>countElems</code></p>
<ul>
<li>
<p>Ở bước thời gian <em>i</em>, <strong>Thread 0</strong> đọc giá trị tại <code>array[x]</code> trong phần dữ liệu của nó, giá trị này là <code>1</code> trong ví dụ này.</p>
</li>
<li>
<p>Trong các bước thời gian từ <em>i + 1</em> đến <em>i + 5</em>, mỗi thread đọc một giá trị từ <code>array[x]</code>.<br />
Lưu ý rằng mỗi thread đang truy cập các phần tử <strong>khác nhau</strong> của mảng.<br />
Không chỉ vậy, mỗi lần đọc <code>array</code> trong chuỗi thực thi mẫu này đều trả về giá trị <strong>duy nhất</strong> (nên không có <strong>race condition</strong> trong chuỗi thực thi này).<br />
Sau khi đọc giá trị từ <code>array[x]</code>, mỗi thread sẽ tăng giá trị tương ứng trong <code>counts</code>.</p>
</li>
<li>
<p>Hãy nhớ rằng mảng <code>counts</code> <strong>nằm gọn trong một cache line</strong> của L1 cache.<br />
Do đó, <strong>mỗi lần ghi</strong> vào <code>counts</code> sẽ <strong>invalidate</strong> (vô hiệu hóa) <strong>toàn bộ cache line</strong> này trong <strong>mọi L1 cache khác</strong>.</p>
</li>
<li>
<p>Kết quả là, mặc dù đang cập nhật <strong>các vị trí bộ nhớ khác nhau</strong> trong <code>counts</code>, nhưng bất kỳ cache line nào chứa <code>counts</code> cũng sẽ bị <strong>invalidate</strong> với <strong>mỗi lần cập nhật</strong> <code>counts</code>!</p>
</li>
</ul>
<p>Việc invalidation buộc tất cả các L1 cache phải cập nhật lại cache line này bằng một phiên bản “hợp lệ” từ L2.<br />
Việc lặp đi lặp lại quá trình invalidation và ghi đè cache line từ L1 cache là một ví dụ về <strong>thrashing</strong> — khi các xung đột lặp lại trong cache gây ra hàng loạt <strong>cache miss</strong>.</p>
<p>Khi số lượng core tăng, vấn đề càng trở nên nghiêm trọng, vì lúc này có nhiều L1 cache hơn cùng thực hiện invalidation trên cache line.<br />
Kết quả là, việc thêm thread mới sẽ làm <strong>thời gian chạy chậm lại</strong>, mặc dù mỗi thread đang truy cập các phần tử <strong>khác nhau</strong> của mảng <code>counts</code>!</p>
<p>Đây là một ví dụ về <strong>false sharing</strong> — hiện tượng “ảo giác” rằng các phần tử riêng lẻ đang được nhiều core chia sẻ.<br />
Trong ví dụ trước, có vẻ như tất cả các core đang truy cập cùng một phần tử của <code>counts</code>, mặc dù thực tế không phải vậy.</p>
<h3 id="1453-khắc-phục-false-sharing"><a class="header" href="#1453-khắc-phục-false-sharing">14.5.3. Khắc phục False Sharing</a></h3>
<p>Một cách để khắc phục false sharing là <strong>padding</strong> (đệm) mảng (trong trường hợp này là <code>counts</code>) bằng các phần tử bổ sung để nó <strong>không vừa</strong> trong một cache line.<br />
Tuy nhiên, padding có thể gây <strong>lãng phí bộ nhớ</strong> và có thể <strong>không loại bỏ hoàn toàn vấn đề</strong> trên mọi kiến trúc (ví dụ: hai máy khác nhau có kích thước L1 cache khác nhau).<br />
Trong hầu hết các trường hợp, việc viết code để hỗ trợ nhiều kích thước cache thường <strong>không đáng</strong> so với lợi ích hiệu năng thu được.</p>
<p>Một giải pháp tốt hơn là để các thread ghi vào <strong>local storage</strong> (bộ nhớ cục bộ) bất cứ khi nào có thể.<br />
Trong ngữ cảnh này, local storage là vùng nhớ <strong>cục bộ</strong> cho một thread.<br />
Giải pháp sau đây giảm false sharing bằng cách thực hiện cập nhật vào một biến <code>counts</code> cục bộ được khai báo riêng, gọi là <code>local_counts</code>.</p>
<p>Hãy xem lại phiên bản cuối cùng của hàm <code>countElems</code> (trích từ <a href="_attachments/countElems_p_v3.c">countElems_p_v3.c</a>):</p>
<pre><code class="language-c">/*parallel version of CountSort algorithm step 1 (final attempt with mutexes):
 * extracts arguments from args value
 * calculates the portion of the array this thread is responsible for counting
 * computes the frequency of all the elements in assigned component and stores
 * the associated counts of each element in counts array
*/
void *countElems( void *args ){
    //extract arguments
    //omitted for brevity
    int *array = myargs-&gt;ap;
    long *counts = myargs-&gt;countp;

    long local_counts[MAX] = {0}; //local declaration of counts array

    //assign work to the thread
    //compute chunk, start, and end values (omitted for brevity)

    long i;

    //heart of the program
    for (i = start; i &lt; end; i++){
        val = array[i];
        local_counts[val] = local_counts[val] + 1; //update local counts array
    }

    //update to global counts array
    pthread_mutex_lock(&amp;mutex); //acquire the mutex lock
    for (i = 0; i &lt; MAX; i++){
        counts[i] += local_counts[i];
    }
    pthread_mutex_unlock(&amp;mutex); //release the mutex lock

    return NULL;
}
</code></pre>
<p>Việc sử dụng <code>local_counts</code> để cộng dồn tần suất thay vì <code>counts</code> là nguyên nhân chính giúp giảm false sharing trong ví dụ này:</p>
<pre><code class="language-c">for (i = start; i &lt; end; i++){
    val = array[i];
    local_counts[val] = local_counts[val] + 1; // cập nhật mảng đếm cục bộ
}
</code></pre>
<p>Vì <strong>cache coherence</strong> được thiết kế để duy trì góc nhìn nhất quán về bộ nhớ chia sẻ, nên invalidation chỉ xảy ra khi <strong>ghi</strong> vào <strong>giá trị chia sẻ</strong> trong bộ nhớ.<br />
Do <code>local_counts</code> <strong>không được chia sẻ</strong> giữa các thread, việc ghi vào nó sẽ <strong>không</strong> làm invalidate cache line tương ứng.</p>
<p>Trong phần cuối của code, <strong>mutex</strong> đảm bảo tính đúng đắn bằng cách chỉ cho phép <strong>một thread</strong> cập nhật mảng <code>counts</code> chia sẻ tại một thời điểm:</p>
<pre><code class="language-c">// cập nhật mảng counts toàn cục
pthread_mutex_lock(&amp;mutex); // khóa mutex
for (i = 0; i &lt; MAX; i++){
    counts[i] += local_counts[i];
}
pthread_mutex_unlock(&amp;mutex); // mở khóa mutex
</code></pre>
<p>Vì <code>counts</code> nằm trên <strong>một cache line duy nhất</strong>, nó vẫn sẽ bị invalidate với mỗi lần ghi.<br />
Điểm khác biệt là chi phí ở đây <strong>tối đa</strong> là <code>MAX × t</code> lần ghi so với <code>n</code> lần ghi,<br />
trong đó <code>n</code> là độ dài mảng đầu vào và <code>t</code> là số lượng thread được sử dụng.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C14-SharedMemory/performance_advanced.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C14-SharedMemory/thread_safety.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C14-SharedMemory/performance_advanced.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C14-SharedMemory/thread_safety.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
