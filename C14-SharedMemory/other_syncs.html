<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Other Synchronization Constructs - Đắm mình vào hệ thống - Dive into Systems</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../copyright.html"><strong aria-hidden="true">1.1.</strong> Copyright</a></li><li class="chapter-item expanded "><a href="../acknowledgements.html"><strong aria-hidden="true">1.2.</strong> Acknowledgements</a></li><li class="chapter-item expanded "><a href="../preface.html"><strong aria-hidden="true">1.3.</strong> Preface</a></li></ol></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/index.html"><strong aria-hidden="true">3.</strong> Binary and Data Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/bases.html"><strong aria-hidden="true">3.1.</strong> Number Bases and Unsigned Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/conversion.html"><strong aria-hidden="true">3.2.</strong> Converting Between Bases</a></li><li class="chapter-item expanded "><a href="../C4-Binary/signed.html"><strong aria-hidden="true">3.3.</strong> Signed Binary Integers</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic.html"><strong aria-hidden="true">3.4.</strong> Binary Integer Arithmetic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_addition.html"><strong aria-hidden="true">3.4.1.</strong> Addition</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_subtraction.html"><strong aria-hidden="true">3.4.2.</strong> Subtraction</a></li><li class="chapter-item expanded "><a href="../C4-Binary/arithmetic_mult_div.html"><strong aria-hidden="true">3.4.3.</strong> Multiplication & Division</a></li></ol></li><li class="chapter-item expanded "><a href="../C4-Binary/overflow.html"><strong aria-hidden="true">3.5.</strong> Overflow</a></li><li class="chapter-item expanded "><a href="../C4-Binary/bitwise.html"><strong aria-hidden="true">3.6.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../C4-Binary/byte_order.html"><strong aria-hidden="true">3.7.</strong> Integer Byte Order</a></li><li class="chapter-item expanded "><a href="../C4-Binary/floating_point.html"><strong aria-hidden="true">3.8.</strong> Real Numbers in Binary</a></li><li class="chapter-item expanded "><a href="../C4-Binary/summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/index.html"><strong aria-hidden="true">4.</strong> What von Neumann Knew: Computer Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/hist.html"><strong aria-hidden="true">4.1.</strong> The Origins of Modern Computing</a></li><li class="chapter-item expanded "><a href="../C5-Arch/von.html"><strong aria-hidden="true">4.2.</strong> The von Neumann Architecture</a></li><li class="chapter-item expanded "><a href="../C5-Arch/gates.html"><strong aria-hidden="true">4.3.</strong> Logic Gates</a></li><li class="chapter-item expanded "><a href="../C5-Arch/circuits.html"><strong aria-hidden="true">4.4.</strong> Circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C5-Arch/arithlogiccircs.html"><strong aria-hidden="true">4.4.1.</strong> Arithmetic and Logic Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/controlcircs.html"><strong aria-hidden="true">4.4.2.</strong> Control Circuits</a></li><li class="chapter-item expanded "><a href="../C5-Arch/storagecircs.html"><strong aria-hidden="true">4.4.3.</strong> Storage Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="../C5-Arch/cpu.html"><strong aria-hidden="true">4.5.</strong> Building a Processor</a></li><li class="chapter-item expanded "><a href="../C5-Arch/instrexec.html"><strong aria-hidden="true">4.6.</strong> The Processor’s Execution of Program Instructions</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining.html"><strong aria-hidden="true">4.7.</strong> Pipelining Instruction Execution</a></li><li class="chapter-item expanded "><a href="../C5-Arch/pipelining_advanced.html"><strong aria-hidden="true">4.8.</strong> Advanced Pipelining Considerations</a></li><li class="chapter-item expanded "><a href="../C5-Arch/modern.html"><strong aria-hidden="true">4.9.</strong> Looking Ahead: CPUs Today</a></li><li class="chapter-item expanded "><a href="../C5-Arch/summary.html"><strong aria-hidden="true">4.10.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C6-asm_intro/index.html"><strong aria-hidden="true">5.</strong> Under the C: Dive into Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/index.html"><strong aria-hidden="true">6.</strong> -bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/basics.html"><strong aria-hidden="true">6.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/common.html"><strong aria-hidden="true">6.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arithmetic.html"><strong aria-hidden="true">6.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/conditional_control_loops.html"><strong aria-hidden="true">6.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C7-x86_64/preliminaries.html"><strong aria-hidden="true">6.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/if_statements.html"><strong aria-hidden="true">6.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/loops.html"><strong aria-hidden="true">6.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C7-x86_64/functions.html"><strong aria-hidden="true">6.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/recursion.html"><strong aria-hidden="true">6.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/arrays.html"><strong aria-hidden="true">6.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/matrices.html"><strong aria-hidden="true">6.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/structs.html"><strong aria-hidden="true">6.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C7-x86_64/buffer_overflow.html"><strong aria-hidden="true">6.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/index.html"><strong aria-hidden="true">7.</strong> 64-bit x86 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/basics.html"><strong aria-hidden="true">7.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C8-IA32/common.html"><strong aria-hidden="true">7.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arithmetic.html"><strong aria-hidden="true">7.3.</strong> Additional Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C8-IA32/conditional_control_loops.html"><strong aria-hidden="true">7.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C8-IA32/preliminaries.html"><strong aria-hidden="true">7.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C8-IA32/if_statements.html"><strong aria-hidden="true">7.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C8-IA32/loops.html"><strong aria-hidden="true">7.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C8-IA32/functions.html"><strong aria-hidden="true">7.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/recursion.html"><strong aria-hidden="true">7.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C8-IA32/arrays.html"><strong aria-hidden="true">7.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/matrices.html"><strong aria-hidden="true">7.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/structs.html"><strong aria-hidden="true">7.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C8-IA32/buffer_overflow.html"><strong aria-hidden="true">7.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/index.html"><strong aria-hidden="true">8.</strong> ARMv8 Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/basics.html"><strong aria-hidden="true">8.1.</strong> Assembly Basics</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/common.html"><strong aria-hidden="true">8.2.</strong> Common Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arithmetic.html"><strong aria-hidden="true">8.3.</strong> Arithmetic Instructions</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/conditional_control_loops.html"><strong aria-hidden="true">8.4.</strong> Conditional Control and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C9-ARM64/preliminaries.html"><strong aria-hidden="true">8.4.1.</strong> Preliminaries</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/if_statements.html"><strong aria-hidden="true">8.4.2.</strong> If Statements</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/loops.html"><strong aria-hidden="true">8.4.3.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="../C9-ARM64/functions.html"><strong aria-hidden="true">8.5.</strong> Functions in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/recursion.html"><strong aria-hidden="true">8.6.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/arrays.html"><strong aria-hidden="true">8.7.</strong> Arrays in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/matrices.html"><strong aria-hidden="true">8.8.</strong> Matrices in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/structs.html"><strong aria-hidden="true">8.9.</strong> Structs in Assembly</a></li><li class="chapter-item expanded "><a href="../C9-ARM64/buffer_overflow.html"><strong aria-hidden="true">8.10.</strong> Buffer Overflows</a></li></ol></li><li class="chapter-item expanded "><a href="../C10-asm_takeaways/index.html"><strong aria-hidden="true">9.</strong> Key Assembly Takeaways</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/index.html"><strong aria-hidden="true">10.</strong> Storage and the Memory Hierarchy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C11-MemHierarchy/mem_hierarchy.html"><strong aria-hidden="true">10.1.</strong> The Memory Hierarchy</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/devices.html"><strong aria-hidden="true">10.2.</strong> Storage Devices</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/locality.html"><strong aria-hidden="true">10.3.</strong> Locality</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/caching.html"><strong aria-hidden="true">10.4.</strong> Caching</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/cachegrind.html"><strong aria-hidden="true">10.5.</strong> Cache Analysis and Cachegrind</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/coherency.html"><strong aria-hidden="true">10.6.</strong> Looking Ahead: Caching on Multicore Processors</a></li><li class="chapter-item expanded "><a href="../C11-MemHierarchy/summary.html"><strong aria-hidden="true">10.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/index.html"><strong aria-hidden="true">11.</strong> Code Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C12-CodeOpt/basic.html"><strong aria-hidden="true">11.1.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/loops_functions.html"><strong aria-hidden="true">11.2.</strong> Other Compiler Optimizations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/memory_considerations.html"><strong aria-hidden="true">11.3.</strong> Memory Considerations</a></li><li class="chapter-item expanded "><a href="../C12-CodeOpt/summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/index.html"><strong aria-hidden="true">12.</strong> The Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/impl.html"><strong aria-hidden="true">12.1.</strong> Booting and Running</a></li><li class="chapter-item expanded "><a href="../C13-OS/processes.html"><strong aria-hidden="true">12.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="../C13-OS/vm.html"><strong aria-hidden="true">12.3.</strong> Virtual Memory</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc.html"><strong aria-hidden="true">12.4.</strong> Interprocess Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C13-OS/ipc_signals.html"><strong aria-hidden="true">12.4.1.</strong> Signals</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_msging.html"><strong aria-hidden="true">12.4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../C13-OS/ipc_shm.html"><strong aria-hidden="true">12.4.3.</strong> Shared Memory</a></li></ol></li><li class="chapter-item expanded "><a href="../C13-OS/advanced.html"><strong aria-hidden="true">12.5.</strong> Summary and Other OS Functionality</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/index.html"><strong aria-hidden="true">13.</strong> Leveraging Shared Memory in the Multicore Era</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/multicore.html"><strong aria-hidden="true">13.1.</strong> Programming Multicore Systems</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/posix.html"><strong aria-hidden="true">13.2.</strong> POSIX Threads</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/synchronization.html"><strong aria-hidden="true">13.3.</strong> Synchronizing Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/mutex.html"><strong aria-hidden="true">13.3.1.</strong> Mutual Exclusion</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/semaphores.html"><strong aria-hidden="true">13.3.2.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/other_syncs.html" class="active"><strong aria-hidden="true">13.3.3.</strong> Other Synchronization Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance.html"><strong aria-hidden="true">13.4.</strong> Measuring Parallel Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_basics.html"><strong aria-hidden="true">13.4.1.</strong> Parallel Performance Basics</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/performance_advanced.html"><strong aria-hidden="true">13.4.2.</strong> Advanced Topics</a></li></ol></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/cache_coherence.html"><strong aria-hidden="true">13.5.</strong> Cache Coherence</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/thread_safety.html"><strong aria-hidden="true">13.6.</strong> Thread Safety</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/openmp.html"><strong aria-hidden="true">13.7.</strong> Implicit Threading with OpenMP</a></li><li class="chapter-item expanded "><a href="../C14-SharedMemory/summary.html"><strong aria-hidden="true">13.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../C15-Parallel/index.html"><strong aria-hidden="true">14.</strong> Looking Ahead: Other Parallel Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C15-Parallel/gpu.html"><strong aria-hidden="true">14.1.</strong> Hardware Acceleration and CUDA</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/distrmem.html"><strong aria-hidden="true">14.2.</strong> Distributed Memory Systems</a></li><li class="chapter-item expanded "><a href="../C15-Parallel/cloud.html"><strong aria-hidden="true">14.3.</strong> To Exascale and Beyond</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Đắm mình vào hệ thống - Dive into Systems</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="1433-các-cấu-trúc-đồng-bộ-hóa-khác-other-synchronization-constructs"><a class="header" href="#1433-các-cấu-trúc-đồng-bộ-hóa-khác-other-synchronization-constructs">14.3.3. Các cấu trúc đồng bộ hóa khác (Other Synchronization Constructs)</a></h3>
<p><strong>Mutex</strong> và <strong>semaphore</strong> không phải là những ví dụ duy nhất về cấu trúc đồng bộ hóa có thể được sử dụng trong ngữ cảnh các chương trình đa luồng.<br />
Trong tiểu mục này, chúng ta sẽ thảo luận ngắn gọn về hai cấu trúc đồng bộ hóa khác là <strong>barrier</strong> và <strong>condition variable</strong>, cả hai đều là một phần của thư viện <strong>Pthreads</strong>.</p>
<h4 id="barriers"><a class="header" href="#barriers">Barriers</a></h4>
<p><strong>Barrier</strong> là một loại cấu trúc đồng bộ hóa buộc <strong>tất cả</strong> các thread phải đạt đến một điểm chung trong quá trình thực thi trước khi cho phép chúng tiếp tục chạy song song.<br />
Pthreads cung cấp một primitive đồng bộ hóa dạng barrier.<br />
Để sử dụng barrier của Pthreads, cần thực hiện các bước sau:</p>
<ul>
<li>Khai báo một biến barrier toàn cục (ví dụ: <code>pthread_barrier_t barrier</code>)</li>
<li>Khởi tạo barrier trong <code>main</code> (<code>pthread_barrier_init(&amp;barrier)</code>)</li>
<li>Hủy barrier trong <code>main</code> sau khi sử dụng (<code>pthread_barrier_destroy(&amp;barrier)</code>)</li>
<li>Sử dụng hàm <code>pthread_barrier_wait</code> để tạo một điểm đồng bộ hóa.</li>
</ul>
<p>Chương trình sau minh họa cách sử dụng barrier trong một hàm có tên <code>threadEx</code>:</p>
<pre><code class="language-c">void *threadEx(void *args){
    // parse args
    // ...
    long myid = myargs-&gt;id;
    int nthreads = myargs-&gt;numthreads;
    int *array = myargs-&gt;array;

    printf(&quot;Thread %ld starting thread work!\n&quot;, myid);
    pthread_barrier_wait(&amp;barrier); // forced synchronization point
    printf(&quot;All threads have reached the barrier!\n&quot;);
    for (i = start; i &lt; end; i++) {
        array[i] = array[i] * 2;
    }
    printf(&quot;Thread %ld done with work!\n&quot;, myid);

    return NULL;
}
</code></pre>
<p>Trong ví dụ này, <strong>không thread nào</strong> có thể bắt đầu xử lý phần mảng được gán cho đến khi <strong>tất cả</strong> các thread đã in ra thông báo rằng chúng bắt đầu làm việc.<br />
Nếu không có barrier, có thể một thread đã hoàn thành công việc trước khi các thread khác kịp in thông báo bắt đầu.<br />
Lưu ý rằng <strong>vẫn</strong> có thể xảy ra trường hợp một thread in thông báo hoàn thành công việc trước khi một thread khác thực sự kết thúc.</p>
<h4 id="condition-variables"><a class="header" href="#condition-variables">Condition Variables</a></h4>
<p><strong>Condition variable</strong> buộc một thread phải <strong>block</strong> (chặn) cho đến khi một điều kiện cụ thể được thỏa coden.<br />
Cấu trúc này hữu ích trong các tình huống mà một điều kiện phải được đáp ứng trước khi thread thực hiện công việc.<br />
Nếu không có condition variable, thread sẽ phải liên tục kiểm tra xem điều kiện đã được đáp ứng chưa, gây tốn CPU.</p>
<p>Condition variable <strong>luôn</strong> được sử dụng cùng với mutex.<br />
Trong loại cấu trúc đồng bộ hóa này, mutex đảm bảo <strong>mutual exclusion</strong> (loại trừ lẫn nhau), trong khi condition variable đảm bảo rằng điều kiện cụ thể được đáp ứng trước khi một thread giành được mutex.</p>
<p>Condition variable trong POSIX có kiểu <code>pthread_cond_t</code>.<br />
Giống như mutex và barrier, condition variable phải được <strong>khởi tạo trước khi sử dụng</strong> và <strong>hủy sau khi sử dụng</strong>.</p>
<ul>
<li>Để khởi tạo condition variable, dùng hàm <code>pthread_cond_init</code>.</li>
<li>Để hủy condition variable, dùng hàm <code>pthread_cond_destroy</code>.</li>
</ul>
<p>Hai hàm thường được gọi khi sử dụng condition variable là <code>pthread_cond_wait</code> và <code>pthread_cond_signal</code>.<br />
Cả hai hàm này đều yêu cầu <strong>địa chỉ của một mutex</strong> ngoài địa chỉ của condition variable:</p>
<ul>
<li>
<p><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>: nhận địa chỉ của condition variable <code>cond</code> và mutex <code>mutex</code> làm tham số.<br />
Hàm này khiến thread gọi nó bị block trên condition variable <code>cond</code> cho đến khi một thread khác <strong>signal</strong> (đánh thức) nó.</p>
</li>
<li>
<p><code>pthread_cond_signal(&amp;cond)</code>: khiến thread gọi hàm này <strong>đánh thức</strong> một thread khác đang chờ trên condition variable <code>cond</code> (theo ưu tiên lập lịch).<br />
Nếu không có thread nào đang bị block trên condition đó, hàm sẽ không có tác dụng.<br />
Khác với <code>pthread_cond_wait</code>, hàm <code>pthread_cond_signal</code> có thể được gọi bởi một thread <strong>bất kể</strong> nó có đang giữ mutex liên quan hay không.</p>
</li>
</ul>
<h4 id="ví-dụ-về-condition-variable"><a class="header" href="#ví-dụ-về-condition-variable">Ví dụ về Condition Variable</a></h4>
<p>Thông thường, condition variable hữu ích nhất khi một nhóm thread đang chờ một nhóm khác hoàn thành một hành động nào đó.<br />
Trong ví dụ sau, chúng ta sử dụng nhiều thread để mô phỏng một nhóm <strong>nông dân</strong> thu thập trứng từ một nhóm <strong>gà</strong>.<br />
&quot;Chicken&quot; và &quot;Farmer&quot; đại diện cho hai lớp thread riêng biệt.<br />
Toàn bộ mã nguồn của chương trình này có thể tải tại <a href="_attachments/layeggs.c">layeggs.c</a>.<br />
Lưu ý rằng đoạn code liệt kê ở đây đã lược bỏ nhiều phần chú thích/xử lý lỗi để ngắn gọn.</p>
<pre><code class="language-c">int main(int argc, char **argv){
    //... declarations omitted for brevity

    // these will be shared by all threads via pointer fields in t_args
    int num_eggs;           // number of eggs ready to collect
    pthread_mutex_t mutex;  // mutex associated with cond variable
    pthread_cond_t  eggs;   // used to block/wake-up farmer waiting for eggs

    //... args parsing removed for brevity

    num_eggs = 0; // number of eggs ready to collect
    ret = pthread_mutex_init(&amp;mutex, NULL); //initialize the mutex
    pthread_cond_init(&amp;eggs, NULL); //initialize the condition variable

    //... thread_array and thread_args creation/filling omitted for brevity

    // create some chicken and farmer threads
    for (i = 0; i &lt; (2 * nthreads); i++) {
        if ( (i % 2) == 0 ) {
            ret = pthread_create(&amp;thread_array[i], NULL,
                                 chicken, &amp;thread_args[i]);
        }
        else {
            ret = pthread_create(&amp;thread_array[i], NULL,
                                 farmer, &amp;thread_args[i] );
        }
    }

    // wait for chicken and farmer threads to exit
    for (i = 0; i &lt; (2 * nthreads); i++)  {
        ret = pthread_join(thread_array[i], NULL);
    }

    // clean-up program state
    pthread_mutex_destroy(&amp;mutex); //destroy the mutex
    pthread_cond_destroy(&amp;eggs);   //destroy the cond var

    return 0;
}
</code></pre>
<p>Hàm <code>main</code> tạo một biến chia sẻ <code>num_eggs</code> (biểu thị tổng số trứng hiện có tại bất kỳ thời điểm nào), một <code>mutex</code> chia sẻ (được sử dụng mỗi khi một thread truy cập <code>num_eggs</code>), và một condition variable chia sẻ <code>eggs</code>.<br />
Sau đó, nó tạo <strong>hai thread Chicken</strong> và <strong>hai thread Farmer</strong>.</p>
<p>Mỗi <strong>Chicken thread</strong> (thread “gà”) chịu trách nhiệm đẻ một số lượng trứng nhất định:</p>
<pre><code class="language-c">void *chicken(void *args ) {
    struct t_arg *myargs = (struct t_arg *)args;
    int *num_eggs, i, num;

    num_eggs = myargs-&gt;num_eggs;
    i = 0;

    // lay some eggs
    for (i = 0; i &lt; myargs-&gt;total_eggs; i++) {
        usleep(EGGTIME); //chicken sleeps

        pthread_mutex_lock(myargs-&gt;mutex);
        *num_eggs = *num_eggs + 1;  // update number of eggs
        num = *num_eggs;
        pthread_cond_signal(myargs-&gt;eggs); // wake a sleeping farmer (squawk)
        pthread_mutex_unlock(myargs-&gt;mutex);

        printf(&quot;chicken %d created egg %d available %d\n&quot;,myargs-&gt;id,i,num);
    }
    return NULL;
}
</code></pre>
<p>Để đẻ một quả trứng, Chicken thread sẽ <strong>ngủ</strong> một lúc, sau đó <strong>giành mutex</strong> và cập nhật tổng số trứng hiện có (<code>num_eggs</code>) tăng thêm 1.<br />
Trước khi <strong>nhả mutex</strong>, Chicken thread sẽ <strong>đánh thức</strong> một Farmer thread đang ngủ (có thể là bằng tiếng kêu “cục tác”).<br />
Chicken thread lặp lại chu trình này cho đến khi đẻ hết số trứng mà nó dự định (<code>total_eggs</code>).</p>
<p>Mỗi <strong>Farmer thread</strong> (thread “nông dân”) chịu trách nhiệm thu thập <code>total_eggs</code> quả trứng từ đàn gà (có thể là để ăn sáng):</p>
<pre><code class="language-c">void *farmer(void *args ) {
    struct t_arg * myargs = (struct t_arg *)args;
    int *num_eggs, i, num;

    num_eggs = myargs-&gt;num_eggs;

    i = 0;

    for (i = 0; i &lt; myargs-&gt;total_eggs; i++) {
        pthread_mutex_lock(myargs-&gt;mutex);
        while (*num_eggs == 0 ) { // no eggs to collect
            // wait for a chicken to lay an egg
            pthread_cond_wait(myargs-&gt;eggs, myargs-&gt;mutex);
        }

        // we hold mutex lock here and num_eggs &gt; 0
        num = *num_eggs;
        *num_eggs = *num_eggs - 1;
        pthread_mutex_unlock(myargs-&gt;mutex);

        printf(&quot;farmer %d gathered egg %d available %d\n&quot;,myargs-&gt;id,i,num);
    }
    return NULL;
}
</code></pre>
<p>Mỗi Farmer thread sẽ <strong>giành mutex</strong> trước khi kiểm tra biến chia sẻ <code>num_eggs</code> để xem có trứng nào sẵn sàng không (<code>*num_eggs == 0</code>).<br />
Trong khi <strong>không có</strong> trứng, Farmer thread sẽ <strong>block</strong> (tức là “ngủ”).</p>
<p>Sau khi Farmer thread được “đánh thức” bởi tín hiệu từ một Chicken thread, nó sẽ kiểm tra lại xem trứng vẫn còn không (vì có thể một Farmer khác đã lấy trước).<br />
Nếu còn, Farmer sẽ “thu thập” trứng (giảm <code>num_eggs</code> đi 1) và <strong>nhả mutex</strong>.</p>
<p>Theo cách này, Chicken và Farmer phối hợp nhịp nhàng để đẻ và thu thập trứng.<br />
<strong>Condition variable</strong> đảm bảo rằng không Farmer thread nào thu thập trứng cho đến khi trứng được đẻ bởi một Chicken thread.</p>
<h4 id="broadcasting"><a class="header" href="#broadcasting">Broadcasting</a></h4>
<p>Một hàm khác được sử dụng với condition variable là <code>pthread_cond_broadcast</code>, hữu ích khi <strong>nhiều thread</strong> đang bị block trên cùng một điều kiện.<br />
Gọi <code>pthread_cond_broadcast(&amp;cond)</code> sẽ <strong>đánh thức tất cả</strong> các thread đang bị block trên condition <code>cond</code>.</p>
<p>Trong ví dụ tiếp theo, chúng ta sẽ thấy cách condition variable có thể triển khai cơ chế <strong>barrier</strong> đã được thảo luận trước đó:</p>
<pre><code class="language-c">// mutex (initialized in main)
pthread_mutex_t mutex;

// condition variable signifying the barrier (initialized in main)
pthread_cond_t barrier;

void *threadEx_v2(void *args){
    // parse args
    // ...

    long myid = myargs-&gt;id;
    int nthreads = myargs-&gt;numthreads;
    int *array = myargs-&gt;array

    // counter denoting the number of threads that reached the barrier
    int *n_reached = myargs-&gt;n_reached;

    // start barrier code
    pthread_mutex_lock(&amp;mutex);
    *n_reached++;

    printf(&quot;Thread %ld starting work!\n&quot;, myid)

    // if some threads have not reached the barrier
    while (*n_reached &lt; nthreads) {
        pthread_cond_wait(&amp;barrier, &amp;mutex);
    }
    // all threads have reached the barrier
    printf(&quot;all threads have reached the barrier!\n&quot;);
    pthread_cond_broadcast(&amp;barrier);

    pthread_mutex_unlock(&amp;mutex);
    // end barrier code

    // normal thread work
    for (i = start; i &lt; end; i++) {
        array[i] = array[i] * 2;
    }
    printf(&quot;Thread %ld done with work!\n&quot;, myid);

    return NULL;
}
</code></pre>
<p>Hàm <code>threadEx_v2</code> có chức năng giống hệt <code>threadEx</code>.<br />
Trong ví dụ này, condition variable được đặt tên là <code>barrier</code>.<br />
Khi mỗi thread giành được lock, nó sẽ tăng biến <code>n_reached</code> — số lượng thread đã đến điểm barrier.<br />
Trong khi số thread đã đến barrier <strong>nhỏ hơn</strong> tổng số thread, thread sẽ <strong>chờ</strong> trên condition variable <code>barrier</code> và mutex <code>mutex</code>.</p>
<p>Tuy nhiên, khi <strong>thread cuối cùng</strong> đến barrier, nó sẽ gọi <code>pthread_cond_broadcast(&amp;barrier)</code>, giải phóng <strong>tất cả</strong> các thread khác đang chờ trên condition variable <code>barrier</code>, cho phép chúng tiếp tục thực thi.</p>
<p>Ví dụ này hữu ích để minh họa hàm <code>pthread_cond_broadcast</code>;<br />
tuy nhiên, tốt nhất là nên sử dụng <strong>Pthreads barrier primitive</strong> bất cứ khi nào cần barrier trong chương trình.</p>
<p>Một câu hỏi mà sinh viên thường đặt ra là:<br />
Vòng lặp <code>while</code> bao quanh lời gọi <code>pthread_cond_wait</code> trong code <code>farmer</code> và <code>threadEx_v2</code> có thể thay bằng câu lệnh <code>if</code> không?</p>
<p>Câu trả lời là <strong>không</strong> — vòng lặp <code>while</code> này <strong>hoàn toàn cần thiết</strong> vì hai lý do chính:</p>
<ol>
<li>
<p><strong>Điều kiện có thể thay đổi</strong> trước khi thread vừa được đánh thức kịp tiếp tục thực thi.<br />
Vòng lặp <code>while</code> đảm bảo điều kiện được kiểm tra lại một lần cuối.</p>
</li>
<li>
<p>Hàm <code>pthread_cond_wait</code> có thể gặp <strong>spurious wakeups</strong> — tình huống một thread bị đánh thức <strong>nhầm</strong> ngay cả khi điều kiện chưa được thỏa coden.</p>
</li>
</ol>
<p>Vòng lặp <code>while</code> ở đây chính là một ví dụ của <strong>predicate loop</strong>, buộc phải kiểm tra lại condition variable trước khi nhả mutex.<br />
Vì vậy, việc sử dụng <strong>predicate loop</strong> là <strong>thực hành đúng đắn</strong> khi làm việc với condition variable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C14-SharedMemory/semaphores.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../C14-SharedMemory/performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C14-SharedMemory/semaphores.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../C14-SharedMemory/performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
